[{"content":"说明 本文的原理简析基于 React 17.0.2 ，且只讨论 Legacy Mode ，不涉及 Concurrent Mode 。\n函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。\n先看概括 React 设计理念的公式：\nUI = render(data) React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。\n类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。\n不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：\n/** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + this.props.user); }; handleClick = () =\u0026gt; { setTimeout(this.showMessage, 3000); }; render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt;; } } 如果在点击 Follow 后，在 setTimeout 回调触发之前，传入组件的 props.user 改变了，那么 showMessage 将会提示你关注了改变后的 props.user 。\n可以点击 这个示例 自己动手操作，点击页面上的 Follow(class) ，并在三秒之内通过上方的 select 切换 user 。\n按照数据应和渲染结果绑定的设计理念，alert 的表现也是渲染结果的一部分，应与点击按钮那一刻的状态绑定。\n问题在于，在类组件中是通过 this 访问 props 的，而 this 是可变的。具体到这个例子，点击按钮时的 this.props 和三秒之后的 this.props 是不一样的。\n函数组件与数据捕获 将上文的类组件改为函数组件：\nfunction ProfilePage(props) { const showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + props.user); }; const handleClick = () =\u0026gt; { setTimeout(showMessage, 3000); }; return ( \u0026lt;button onClick={handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt; ); } 然后以同样的方式操作，会发现函数组件的表现与类组件不同：\n可以点击 这个示例 自己动手操作，点击页面上的 Follow(function) ，并在三秒之内通过上方的 select 切换 user 。\n在函数组件的 showMessage 函数中，被访问的 props 在函数执行的时刻就被“捕获”了，只要确保 props 是不可变的，在 setTimeout 中访问到的 props.user 就是点击按钮那一刻的值。\n生命周期函数与副作用 在类组件中，副作用通常是在 componentDidMount 或 componentDidUpdate 生命周期函数中执行的。\n 函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量），修改参数或改变外部存储。\n 假设有一个聊天室页面，该页面需要根据不同的聊天室ID与后端建立对应的 websocket 连接。在类组件中，我们可以在 componentDidMount 和 componentDidUpdate 中根据当前的 ID 执行建立、销毁 websocket 连接的操作。但我们需要在两个生命周期函数中写这段逻辑。如果还有其它的副作用需要执行，我们就需要在这两个生命周期函数中重复多个逻辑。\n在函数组件中，函数的主要任务就是通过数据渲染出视图，相应的副作用则可以通过 useEffect Hook 执行，代码不再需要分散到各个生命周期函数中，逻辑清晰。\nuseState 我们先通过 useState 这个最常用的 Hook 来分析 Hook 的实现原理。\n先看一下 React 给出的 Hook 的使用原则：\n   只在最顶层使用 Hook ，不要在循环、条件或嵌套函数中调用 Hook\n  只在 React 函数中调用 Hook ，即只在 React 函数组件和自定义 Hook 中调用 React Hook\n   React 也给出了说明：React 要求每次渲染时 Hook 的调用顺序保持一致，这样 React 就能正确地将内部 state 和对应的 Hook 进行关联。\n背后的原因是：Hook 是通过链表实现的。在一个函数组件中多次调用 useState 将会创建一个单向环状链表。\n先看一个示例（Code Sandbox: React Conditionally Hook）：\nimport { useState } from \u0026#34;react\u0026#34;; let isMounted = false; // 组件初次渲染时，两个 useState 都会执行。 // 点击按钮触发更新渲染时，只会执行第二个 useState export default function App() { let valueA, setValueA, valueB, setValueB; console.log(\u0026#34;isMounted ?\u0026#34;, isMounted); if (!isMounted) { [valueA, setValueA] = useState(\u0026#34;initial value a\u0026#34;); console.log(\u0026#34;valueA =\u0026#34;, valueA); isMounted = true; } [valueB, setValueB] = useState(\u0026#34;initial value b\u0026#34;); console.log(\u0026#34;valueB =\u0026#34;, valueB); return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;React conditionally hook example\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt;A: {valueA}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;B: {valueB}\u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { setValueA(\u0026#34;changed value a\u0026#34;); setValueB(\u0026#34;changed value b\u0026#34;); }} \u0026gt; Click to change values \u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;Click the button and view the console output\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 挂载该组件，页面将正常显示。点击按钮改变 valueB 的值，React 将会报错，我们查看控制台的输出信息：\nisMounted ? false valueA = initial value a valueB = initial value b isMounted ? true valueB = changed value a 注意第二次渲染时控制台的输出：valueB = changed value a，明明调用的是[valueB, setValueB] = useState(\u0026quot;initial value b\u0026quot;)，为什么valueB的值变成了changed value a？\n带着疑问我们看看源码中 React 做了哪些事情。\nmount 阶段 在函数组件初次渲染时，调用 useState 实际上最终是调用了 mountState 函数：\nfunction mountState\u0026lt;S\u0026gt;( initialState: (() =\u0026gt; S) | S, ): [S, Dispatch\u0026lt;BasicStateAction\u0026lt;S\u0026gt;\u0026gt;] { // 创建新的 hook 对象  const hook = mountWorkInProgressHook(); if (typeof initialState === \u0026#39;function\u0026#39;) { initialState = initialState(); } // 设置 hook 的初始值  hook.memoizedState = hook.baseState = initialState; // 创建 hook 队列  const queue = (hook.queue = { pending: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), }); // 创建 dispatch  const dispatch: Dispatch\u0026lt; BasicStateAction\u0026lt;S\u0026gt;, \u0026gt; = (queue.dispatch = (dispatchAction.bind( null, currentlyRenderingFiber, queue, ): any)); return [hook.memoizedState, dispatch]; } mountState 函数通过 mountWorkInProgressHook 函数创建了新的 hook 对象，然后为 hook 赋予初始值、创建 dispatch 函数，最后返回。\n再看看 mountWorkInProgressHook 是如何创建 hook 对象的：\nfunction mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list  currentlyRenderingFiber.memoizedState = workInProgressHook = hook; } else { // Append to the end of the list  workInProgressHook = workInProgressHook.next = hook; } return workInProgressHook; } 上例的 mount 阶段调用了两次 useState ，并产生如下的 Hook 链表：\nhook: { memoizedState: \u0026#39;initial value a\u0026#39; } ⬇ hook: { memoizedState: \u0026#39;initial value b\u0026#39; } 点击按钮之后，将会调用如下代码：\nonClick={() =\u0026gt; { setValueA(\u0026#34;changed value a\u0026#34;); setValueB(\u0026#34;changed value b\u0026#34;); }} 在 onClick 事件中多次调用的 setState 将会合并，并异步触发更新。\nReact 将执行之前通过调用 mountState 返回的两个 dispatch ，更新两个 hook 节点的 memoizedState ，更新后的 hook 链表如下：\nhook: { memoizedState: \u0026#39;changed value a\u0026#39; } ⬇ hook: { memoizedState: \u0026#39;changed value b\u0026#39; } 随后进入异步的 update 阶段，重新执行函数组件。\nupdate 阶段 在 update 阶段，useState 最终调用了 updateReducer 函数：\nfunction updateReducer\u0026lt;S, I, A\u0026gt;( reducer: (S, A) =\u0026gt; S, initialArg: I, init?: I =\u0026gt; S, ): [S, Dispatch\u0026lt;A\u0026gt;] { // 按照顺序从之前的链表获取当前 hook  const hook = updateWorkInProgressHook(); const queue = hook.queue; queue.lastRenderedReducer = reducer; // ...  // 获取 newState 并赋值给 hook.memoizedState  hook.memoizedState = newState; // ...  const dispatch: Dispatch\u0026lt;A\u0026gt; = (queue.dispatch: any); return [hook.memoizedState, dispatch]; } updateReducer 中逻辑较多，这里有所省略。简单来说，它会按顺序遍历之前构建的链表，取出对应的数据进行渲染。\n上例的 update 阶段，第一个 useState 将被跳过，只调用了第二个 useState ，并将返回值赋值给 valueB：\n但对于 React 来说，这是该函数组件第一次调用 useState ，因此 React 按照顺序取出第一个 hook ，并返回对应的 memoizedState 和 dispatch ：\nhook: { memoizedState: \u0026#39;changed value a\u0026#39; } // 实际被取出的 hook ，因此 valueB = \u0026#39;changed value a\u0026#39; ⬇ hook: { memoizedState: \u0026#39;changed value b\u0026#39; } 以上就是对 useState Hook 的原理简析。\nuseEffect 先提出两个问题：\n 若父子组件都使用了 useEffect ，他们的执行顺序是怎么样的？ 同级兄弟组件之间的 useEffect 执行顺序又是怎么样的？  读者可以带着疑问继续往下阅读。\n首先看一段 React 官方文档对 useEffect 的说明：\n 传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用\n React 是如何实现这一点的呢？这涉及到 Fiber 架构的工作流程，这里简单展开说一下。\nFiber 架构工作流程 React 将组件树渲染到真实 DOM 的过程分为两大阶段： render 与 commit 。\n在 render 阶段，React 会为每个 React 元素生成一个 Fiber 节点，节点之间通过指针连接起来，形成 Fiber 树。可以将 Fiber 树理解为虚拟 DOM ，它保存着 React 如何渲染真实 DOM 的各种信息。Fiber 树是一个基于单链表的树结构，类似于下图结构：\n每个 Fiber 节点会有三个指针属性：\n child 指向该节点子节点列表的第一个节点 sibling 指向该节点的下一个兄弟节点 return 指向该节点的父节点  React 以上图中箭头标识的顺序创建、走访所有 Fiber 节点，可以理解为一个递归过程（请注意，只有 Legacy 模式下的 render 过程才是一个同步的递归过程）。\n在“递”阶段，React 会从根节点开始向下深度优先遍历，为每个 Fiber 节点调用 beginWork 函数。该函数会创建子 Fiber 节点，并将两个 Fiber 节点连接起来。当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。\n在“归”阶段，React 会调用 completeWork 处理 Fiber 节点。当某个 Fiber 节点执行完 completeWork ，如果其存在兄弟 Fiber 节点，会进入其兄弟 Fiber 节点的“递”阶段。如果不存在兄弟 Fiber 节点，会进入父 Fiber 节点的“归”阶段。\n整个递归过程最终会回到根节点。到此 render 阶段结束，进入 commit 阶段。\n在 commit 阶段，React 会将 Fiber 树同步到真实 DOM 。这一阶段的主要工作就是操作 DOM ，除此之外会有一些其他工作，例如执行 effect 。\nrender - beginWork 阶段 在 beginWork 函数创建 Fiber 节点的过程中有大量逻辑，这里只需要关注其中会执行组件的 render 函数。对于函数组件，就会执行其中可能存在的 useEffect Hook 。\n在函数组件初次渲染时，调用 useEffect 最终会执行 mountEffect 函数：\nfunction mountEffect( create: () =\u0026gt; (() =\u0026gt; void) | void, deps: Array\u0026lt;mixed\u0026gt; | void | null, ): void { // ...  return mountEffectImpl( UpdateEffect | PassiveEffect, HookPassive, create, deps, ); } 它实际调用了 mountEffectImpl 函数：\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps): void { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; currentlyRenderingFiber.flags |= fiberFlags; hook.memoizedState = pushEffect( HookHasEffect | hookFlags, // create 就是实际传入的 effect 函数  create, undefined, // nextDeps 是传入的依赖项数组  nextDeps, ); } mountEffectImpl 创建了一个新的 hook 对象，并将其 memoizedState 属性设置为 pushEffect 的返回值。\n再来看看 pushEffect 函数做了什么：\nfunction pushEffect(tag, create, destroy, deps) { // 创建 effect 对象  const effect: Effect = { tag, create, destroy, deps, // Circular  next: (null: any), }; // componentUpdateQueue 是当前正在执行渲染函数的 Fiber 节点所维护的一个队列  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any); if (componentUpdateQueue === null) { // componentUpdateQueue 不存在，则创建一个  componentUpdateQueue = createFunctionComponentUpdateQueue(); currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any); // componentUpdateQueue 是一个单向环状链表  componentUpdateQueue.lastEffect = effect.next = effect; } else { const lastEffect = componentUpdateQueue.lastEffect; if (lastEffect === null) { componentUpdateQueue.lastEffect = effect.next = effect; } else { // 维护单向环状链表的数据结构  const firstEffect = lastEffect.next; lastEffect.next = effect; effect.next = firstEffect; componentUpdateQueue.lastEffect = effect; } } return effect; } 总结一下 pushEffect 所做的事情：\n 根据传入的参数创建新的 effect 对象 获取或创建当前正在执行渲染的 Fiber 节点的 Fiber.updateQueue 将新的 effect 赋值给 Fiber.updateQueue.lastEffect，并维护 effect 的单向环状链表数据结构 返回 effect 对象  因此 hook.memoizedState 中保存的是一个 effect 对象，而该对象是一个 effect 单向环状链表中的一员。函数组件所对应的 Fiber 数据结构中， Fiber.updateQueue.lastEffect 始终指向最后一个 effect 。\nbeginWork 阶段最终会为该 Fiber 节点创建 effect 链表，该链表的顺序与组件中调用 useEffect 的顺序保持一致。\nrender - completeWork 阶段 我们先不关注 completeWork 函数做了什么。\n在 completeWork 函数执行结束后，其上层函数 completeUnitOfWork 会检测当前 Fiber 节点是否存在 effect 链表，若存在就将该 Fiber 节点添加到父 Fiber 节点所维护的一份 effectList 链表中。可以参考源码中的注释：completeUnitOfWork 。（请注意，这里父节点的 effectList 是一个 Fiber 节点链表，与子节点里的 Fiber.updateQueue 中维护的 effectList 不是同一个概念）\n最终所有具有 effect 的 Fiber 节点在递归过程结束后会形成一个链表，维护在根节点的 effectList 中，其顺序与节点执行 completeWork 的顺序一致。\n上文有一点没有提到：除了 useEffect 产生的 effect 之外，React 也会将待进行的 DOM 更新操作标记成 effect ，保存在 effect 链表中。commit 阶段将根据 effectList 执行所有的 DOM 更新。\ncommit 阶段 这里先不关注 commit 阶段是如何更新 DOM 的，只关注 useEffect 所产生副作用的执行时机。\n在 React 完成 DOM 更新之后，将调用 commitLayoutEffects 函数，其中调用了 commitLayoutEffectOnFiber 函数，该函数是 commitLifeCycles 函数的别名：\nfunction commitLifeCycles( finishedRoot: FiberRoot, current: Fiber | null, finishedWork: Fiber, committedLanes: Lanes, ): void { switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: { // At this point layout effects have already been destroyed (during mutation phase).  // This is done to prevent sibling component effects from interfering with each other,  // e.g. a destroy function in one component should never override a ref set  // by a create function in another component during the same commit.  if ( enableProfilerTimer \u0026amp;\u0026amp; enableProfilerCommitHooks \u0026amp;\u0026amp; finishedWork.mode \u0026amp; ProfileMode ) { try { startLayoutEffectTimer(); commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); } finally { recordLayoutEffectDuration(finishedWork); } } else { commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); } // useEffect 产生的 effect 属于 PassiveEffect ，将在这里调度执行  schedulePassiveEffects(finishedWork); return; } // ...  } // ... } 再来看看 schedulePassiveEffects 做了什么：\nfunction schedulePassiveEffects(finishedWork: Fiber) { const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any); const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null; if (lastEffect !== null) { const firstEffect = lastEffect.next; let effect = firstEffect; do { const {next, tag} = effect; if ( (tag \u0026amp; HookPassive) !== NoHookEffect \u0026amp;\u0026amp; (tag \u0026amp; HookHasEffect) !== NoHookEffect ) { // 将 effect 的销毁函数推入队列 pendingPassiveHookEffectsUnmount  // 相当于 pendingPassiveHookEffectsUnmount.push(effect, finishedWork);  enqueuePendingPassiveHookEffectUnmount(finishedWork, effect); // 将 effect 的执行函数推入队列 pendingPassiveHookEffectsMount  // 相当于 pendingPassiveHookEffectsMount.push(effect, finishedWork)  enqueuePendingPassiveHookEffectMount(finishedWork, effect); } // 移动指针，走访整个链表  effect = next; } while (effect !== firstEffect); } } schedulePassiveEffects 遍历 effect 链表，将 effect 的销毁函数、执行函数推入了队列。那么队列中的函数是什么时候执行的呢？这涉及到 React 的调度机制，这里不再展开叙述。我们先简单认为这两个队列将在某个时机异步执行，其执行函数就是 flushPassiveEffects ，该函数最终会调用 flushPassiveEffectsImpl ：\nfunction flushPassiveEffectsImpl() { // ...  // 阶段一：执行销毁函数  const unmountEffects = pendingPassiveHookEffectsUnmount; pendingPassiveHookEffectsUnmount = []; for (let i = 0; i \u0026lt; unmountEffects.length; i += 2) { const effect = ((unmountEffects[i]: any): HookEffect); const fiber = ((unmountEffects[i + 1]: any): Fiber); const destroy = effect.destroy; effect.destroy = undefined; // ...  // 如果存在销毁函数则执行，这里省略了一些不相关的逻辑  if (typeof destroy === \u0026#39;function\u0026#39;) { try { destroy(); } finally { // ...  } } } // 阶段二：执行副作用函数  const mountEffects = pendingPassiveHookEffectsMount; pendingPassiveHookEffectsMount = []; for (let i = 0; i \u0026lt; mountEffects.length; i += 2) { const effect = ((mountEffects[i]: any): HookEffect); const fiber = ((mountEffects[i + 1]: any): Fiber); // ...  // 重新执行副作用函数，这里省略了一些不相关的逻辑  try { effect.destroy = create(); } finally { // ...  } } // ... } flushPassiveEffectsImpl 先依次执行了所有 effect 销毁函数，然后再依次执行 effect 执行函数。到这里，整个 useEffect 的执行过程结束。\n现在已经可以回答上文的问题了：\n 若父子组件都使用了 useEffect ，子组件的 effect 将先执行。 同级兄弟组件， effect 将会按照组件顺序依次执行。  useRef  useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。\n ref 是 reference（引用）的缩写。React 推荐使用不可变数据，但某些情况下用户希望使用可变数据，ref 就提供了这样的能力。\nuseRef Hook 的实现 useRef Hook 的 hook.memoizedState 中保存着 ref 对象。例如：\nconst ref = useRef('hello') // ref = hook.memoizedState = { current: 'hello' } 这可以从 useRef 实际调用的 mountRef 、 updateRef 函数看出：\nfunction mountRef\u0026lt;T\u0026gt;(initialValue: T): {|current: T|} { const hook = mountWorkInProgressHook(); const ref = {current: initialValue}; hook.memoizedState = ref; return ref; } function updateRef\u0026lt;T\u0026gt;(initialValue: T): {|current: T|} { const hook = updateWorkInProgressHook(); return hook.memoizedState; } React 元素的 Refs React 支持通过 Refs 访问 DOM 元素或者类组件：\n// DOM 元素 \u0026lt;div ref={domRef}\u0026gt;\u0026lt;/div\u0026gt; // React 类组件 \u0026lt;ClassComponent ref={classComponentRef} /\u0026gt; 对于元素上的 ref 声明，React 是如何对 ref.current 赋值的呢？\n在 render 的 beginWork 阶段，React 将通过 beginWork: markRef 函数为含有 ref 属性的 Fiber 添加 flag: Ref 。\n// ReactFiberFlags.js 中定义的 Ref flag export const Ref = 0b000000000010000000; // beginWork 阶段的 markRef function markRef(current: Fiber | null, workInProgress: Fiber) { const ref = workInProgress.ref; if ( (current === null \u0026amp;\u0026amp; ref !== null) || (current !== null \u0026amp;\u0026amp; current.ref !== ref) ) { // Schedule a Ref effect  workInProgress.flags |= Ref; } } markRef 将在 finishClassComponent 函数和 updateHostComponent 函数中调用。其中 finishClassComponent 用于类组件， updateHostComponent 用于原生 DOM 元素。\nfunction finishClassComponent( current: Fiber | null, workInProgress: Fiber, Component: any, shouldUpdate: boolean, hasContext: boolean, renderLanes: Lanes, ) { // 即使 shouldComponentUpdate 返回了 false ，Refs 也应该更新  markRef(current, workInProgress); const didCaptureError = (workInProgress.flags \u0026amp; DidCapture) !== NoFlags; if (!shouldUpdate \u0026amp;\u0026amp; !didCaptureError) { // Context providers should defer to sCU for rendering  if (hasContext) { invalidateContextProvider(workInProgress, Component, false); } return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes); } // ... } function updateHostComponent( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes, ) { // ...  markRef(current, workInProgress); reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } 另外在 render 的 completeWork 阶段，React 将通过 completeWork: markRef 为需要进行 ref 更新的节点进行标记：\nfunction markRef(workInProgress: Fiber) { workInProgress.flags |= Ref; } function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes, ): Fiber | null { // ...  switch (workInProgress.tag) { // ...  case HostComponent: { // ...  if (current !== null \u0026amp;\u0026amp; workInProgress.stateNode != null) { // ...  // 更新节点的情形，ref 属性发生变化  if (current.ref !== workInProgress.ref) { markRef(workInProgress); } } else { // ...  // 新建节点的情形，节点存在 ref 属性  if (workInProgress.ref !== null) { markRef(workInProgress); } } return null; } // ...  } // ... } 在 commit 阶段，React 将为需要操作 ref 的 Fiber 节点执行两类操作：清除之前的 ref 、赋值新的 ref 。\n有两种情形需要清除之前的 ref ，第一种是 Fiber 节点包含 flag: Ref ，通过 commitMutationEffects 函数执行：\nfunction commitMutationEffects( root: FiberRoot, renderPriorityLevel: ReactPriorityLevel, ) { while (nextEffect !== null) { const flags = nextEffect.flags; // ...  if (flags \u0026amp; Ref) { const current = nextEffect.alternate; if (current !== null) { commitDetachRef(current); } } // ...  } // ... } commitDetachRef 是实际执行 ref 清除的函数：\nfunction commitDetachRef(current: Fiber) { const currentRef = current.ref; if (currentRef !== null) { if (typeof currentRef === \u0026#39;function\u0026#39;) { currentRef(null); } else { currentRef.current = null; } } } 第二种情形是 Fiber 节点需要被移除：\nfunction commitMutationEffects( root: FiberRoot, renderPriorityLevel: ReactPriorityLevel, ) { while (nextEffect !== null) { // ...  const flags = nextEffect.flags; // ...  const primaryFlags = flags \u0026amp; (Placement | Update | Deletion | Hydrating); switch (primaryFlags) { // ...  // 需要删除节点  case Deletion: { commitDeletion(root, nextEffect, renderPriorityLevel); break; } } // ...  } } commitDeletion 函数最终会调用 safelyDetachRef 函数，负责 ref 清除的工作：\nfunction safelyDetachRef(current: Fiber) { const ref = current.ref; if (ref !== null) { if (typeof ref === \u0026#39;function\u0026#39;) { // ...  try { ref(null); } catch (refError) { captureCommitPhaseError(current, refError); } } else { ref.current = null; } } } 完成 ref 的清除除工作后，接下来是 ref 的赋值工作，在 commitLayoutEffect 函数中会执行 commitAttachRef 函数：\nfunction commitAttachRef(finishedWork: Fiber) { const ref = finishedWork.ref; if (ref !== null) { const instance = finishedWork.stateNode; let instanceToUse; switch (finishedWork.tag) { // 原生 DOM 元素  case HostComponent: instanceToUse = getPublicInstance(instance); break; // 类组件  default: instanceToUse = instance; } // ...  if (typeof ref === \u0026#39;function\u0026#39;) { ref(instanceToUse); } else { // ...  ref.current = instanceToUse; } } } useCallback 与 useMemo 相比于上文的几种 Hook ，useCallback 和 useMemo 的实现比较简单。\nmount 阶段 先看 mount 阶段 mountCallback 与 mountMemo 的实现：\nfunction mountCallback\u0026lt;T\u0026gt;(callback: T, deps: Array\u0026lt;mixed\u0026gt; | void | null): T { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; hook.memoizedState = [callback, nextDeps]; return callback; } function mountMemo\u0026lt;T\u0026gt;( nextCreate: () =\u0026gt; T, deps: Array\u0026lt;mixed\u0026gt; | void | null, ): T { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; } 两者的区别在于：mountCallback 保存传入的函数与依赖项，mountMemo 保存传入函数的执行结果与依赖项。\nupdate 阶段 在 update 阶段，useCallback 与 useMemo 将会比较依赖项，若依赖项改变则保存新值，否则返回之前保存的值。\nfunction updateCallback\u0026lt;T\u0026gt;(callback: T, deps: Array\u0026lt;mixed\u0026gt; | void | null): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { if (nextDeps !== null) { const prevDeps: Array\u0026lt;mixed\u0026gt; | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { return prevState[0]; } } } hook.memoizedState = [callback, nextDeps]; return callback; } function updateMemo\u0026lt;T\u0026gt;( nextCreate: () =\u0026gt; T, deps: Array\u0026lt;mixed\u0026gt; | void | null, ): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { // Assume these are defined. If they\u0026#39;re not, areHookInputsEqual will warn.  if (nextDeps !== null) { const prevDeps: Array\u0026lt;mixed\u0026gt; | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { return prevState[0]; } } } const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; } 比较函数 areHookInputsEqual 的实现如下：\nfunction areHookInputsEqual( nextDeps: Array\u0026lt;mixed\u0026gt;, prevDeps: Array\u0026lt;mixed\u0026gt; | null, ) { // ...  if (prevDeps === null) { // ...  return false; } // ...  for (let i = 0; i \u0026lt; prevDeps.length \u0026amp;\u0026amp; i \u0026lt; nextDeps.length; i++) { // is 是 Object.is 的 polyfill  if (is(nextDeps[i], prevDeps[i])) { continue; } return false; } return true; } areHookInputsEqual 对依赖项进行了浅层的 Object.is 比较，因此修改依赖项的深层数据并不会触发 useCallback 和 useMemo 重新计算的逻辑。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/","summary":"说明 本文的原理简析基于 React 17.0.2 ，且只讨论 Legacy Mode ，不涉及 Concurrent Mode 。\n函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。\n先看概括 React 设计理念的公式：\nUI = render(data) React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。\n类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。\n不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：\n/** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + this.props.user); }; handleClick = () =\u0026gt; { setTimeout(this.showMessage, 3000); }; render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt;; } } 如果在点击 Follow 后，在 setTimeout 回调触发之前，传入组件的 props.","title":"React Hooks 原理简析"},{"content":"CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。\n举一个经典的例子：\n用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：\nhttps://bank.example.com/withdraw?account=AccoutName\u0026amp;amount=1000\u0026amp;for=PayeeName。\n攻击者在一个恶意网站上放置如下代码：\n\u0026lt;img src=\u0026quot;https://bank.example.com/withdraw?account=Alice\u0026amp;amount=1000\u0026amp;for=Badman\u0026quot; /\u0026gt;。\n如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。\n注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。\nCSRF 防御 CSRF 具备两个特点：\n CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。\n检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。\n这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。\nCSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。\n大部分 Web 框架都带有这种功能，例如 Django：\n\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt;{% csrf_token %}\u0026lt;/form\u0026gt; 渲染后的效果：\n\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrfmiddlewaretoken\u0026#34; value=\u0026#34;KbyUmhTLMpYj7CD2di7JKP1P3qmLlkPt\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 但 CSRF token 的防御方式也有不足。因为 token 是唯一且随机的，如果每次请求都使用一个唯一的 token，则服务器对于每一个请求都需要进行校验，工作量与服务器压力都会增加。使用会话（session）等级的 token 代替的话，负担将没有那么重。但在大型网站中，使用 session 等级的 CSRF token 会带来一些问题。大型网站很可能会使用分布式环境，用户的多个 http 请求可能会落到不同的服务器之上，那么分布式环境中的 session 信息需要存储在公共存储空间中，比如 redis 里。访问 session 中的 CSRF token 会带来性能问题。目前很多网站采用 Encrypted Token 模式解决该问题。在该模式下，token 不是随机生成的字符串，而是一个计算出来的结果（通常使用一些用户信息、时间戳、随机数等加密生成）。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。\nSameSite cookies 为了从源头解决 CSRF 的问题，Google Chrome 版本 51 引入了 SetCookie SameSite 规范作为可选属性。SameSite 是 http 响应头 Set-Cookie 的属性之一。该属性用于声明该 cookie 是否仅限于同一站点使用。目前该属性尚未纳入 http 标准，还是草案阶段，但大部分现代浏览器已经支持（链接：SameSite#浏览器兼容性）。\nSameSite 可以被设置为三个值：Strict、Lax、None\nSameSite=Strict 该规则最为严格，浏览器将仅发送第一方上下文请求的 cookie（源自设置 cookie 的站点的请求）。如果请求源自于当前位置不同的 URL，则不会发送使用被该 Strict 属性标记的任何 cookie。\nSet-Cookie: CookieName=CookieValue; SameSite=Strict; 该规则过于严格，可能造成不好的用户体验。例如：某网站有一个 GitHub 的跳转链接，用户点击跳转到 GitHub 网站后，由于 cookie 被标记为 SameSite=Strict，跳转过去后将是未登录状态。\nSameSite=Lax(浏览器默认值) Lax 规则相对宽松一些，在满足下述两条规则的情况下，浏览器会在跨源请求中携带 cookie：\n 请求为顶级导航。可以理解为通过超链接跳转到 cookie 所在网站。 请求方法是安全的，包括 GET、HEAD、OPTIONS 请求。  Set-Cookie: CookieName=CookieValue; SameSite=Lax; 举几个例子用来说明 Lax 与 Strict 之间的区别：\n 用户访问了 a.com 网站，并点击网站中的一个链接导航至 b.com，则发起 b.com 请求的请求源是 a.com，是一个跨源请求，则 Strict cookies 不会被发送。但这是一个顶级导航，因此 Lax cookies 会被发送。 用户访问了 a.com 网站，该网站中有一个 iframe 请求 b.com，这种情况下 Lax cookies 也不会被发送。因为这不是一次顶级导航。 用户访问了 a.com 网站，该网站对 b.com 网站发起了一次 POST 请求，这种情况下 Lax cookies 也不会被发送。因为请求方法不是安全方法。  SameSite=None cookie 将同时在第一方上下文和跨源请求中发送；但是，必须将该值显式设置为 None ，且设置 Secure 属性。这也意味着所有请求必须遵循 https 协议。\nSet-Cookie: CookieName=CookieValue; SameSite=None; Secure; ","permalink":"https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/","summary":"CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。\n举一个经典的例子：\n用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：\nhttps://bank.example.com/withdraw?account=AccoutName\u0026amp;amount=1000\u0026amp;for=PayeeName。\n攻击者在一个恶意网站上放置如下代码：\n\u0026lt;img src=\u0026quot;https://bank.example.com/withdraw?account=Alice\u0026amp;amount=1000\u0026amp;for=Badman\u0026quot; /\u0026gt;。\n如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。\n注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。\nCSRF 防御 CSRF 具备两个特点：\n CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。\n检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。\n这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。\nCSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。","title":"CSRF的原理与防御"},{"content":"概览与术语 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法，最常用到的排序方式之一就是数值顺序。\n排序算法依照稳定性可分为稳定算法和不稳定算法。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，则在排序过的列表中 R 也将会是在 S 之前。\n排序算法依照排序过程中占用空间的方式分为 In-place 算法 与 Out-place 算法。In-place 是原地算法，基本上不需要额外的辅助空间，可允许固定数量的辅助变量。非原地算法就是 Out-place，其开辟的辅助空间与问题规模相关。例如，冒泡排序只需要数据在原序列中交换位置，不需要额外的辅助空间，是 In-place 算法。\n不同的排序算法会有不同的时间复杂度（最差、平均、和最好性能），下表列出了十种经典排序算法的概览：\n冒泡排序（Bubble Sort） 一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为：越的元素会经由交换慢慢“浮”到数列的顶端。\n冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。\n算法描述\n 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到没有任何一对数字需要比较； 可选的优化步骤：某次步骤 1~3 执行过程中没有元素发生交换，则证明该序列已经有序，不需要再进行下一次序列遍历。  动图演示\n代码实现\n// TypeScript实现 export function bubbleSort(arr: number[]) { const len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { let sorted = true; for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { sorted = false; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } if (sorted) break; } return arr; } 算法分析\n冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。\n最好时间复杂度：O(n)，当数据已经有序时\n最坏时间复杂度：O(n2)，当数据完全反序时\n平均时间复杂度：O(n2)\n空间复杂度：O(1)\n稳定性：稳定\n选择排序（Selection Sort） 选择排序是一种简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。\n算法描述\n 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置； 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾； 重复步骤 2，直到所有元素排序完毕。  动图演示\n代码实现\n// TypeScript实现 export function selectionSort(arr: number[]) { const len = arr.length; let minIndex: number; for (let i = 0; i \u0026lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j \u0026lt; len; j++) { if (arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } if (minIndex !== i) { [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } } return arr; } 算法分析\n选择排序的比较次数与关键字的初始状态无关，总的比较次数 N=(n-1)+(n-2)+\u0026hellip;+1=n*(n-1)/2。交换次数 O(n)，最好情况是，已经有序，交换 0 次；最坏情况是，逆序，交换 n-1 次。交换次数比冒泡排序较少，由于交换所需 CPU 时间比比较所需的 CPU 时间多，n 值较小时，选择排序比冒泡排序快。\n原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。\n最好时间复杂度：O(n2)\n最坏时间复杂度：O(n2)\n平均时间复杂度：O(n2)\n空间复杂度：O(1)\n稳定性：不稳定。最小（大）元素与已排序序列末尾之后一位元素进行交换时，末尾之后一位的元素与其他非最小（大）元素的相对位置发生了变化。\n插入排序（Insertion Sort） 插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用原地排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n算法描述\n 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5，直到所有元素排序完毕。  动图演示\n代码实现\n// TypeScript实现 export function insertionSort(arr: number[]) { const len = arr.length; let j: number; let temp: number; for (let i = 1; i \u0026lt; len; i++) { temp = arr[i]; j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = temp; } return arr; } 算法分析\n如果目标是把 n 个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 n-1 次即可。最坏情况是，序列是降序排列，那么此时需要进行的比较共有 1 + 2 + \u0026hellip; + (n - 1) = n*(n-1)/2 次。平均来说插入排序算法复杂度为 O(n2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。\n最好时间复杂度：O(n)\n最坏时间复杂度：O(n2)\n平均时间复杂度：O(n2)\n空间复杂度：O(1)\n稳定性：稳定\n希尔排序（Shell Sort） 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。该算法时按其设计者希尔（Donald Shell）的名字命名的，由 1959 年公布。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位  希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。\n为了更好的理解希尔排序是什么，用一个实际的例子来进行说明：\n现在我们要对数组 [13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10] 进行希尔排序，第一次我们将步长定为 5，那么我们将数组排列成一个表，每行的数量是 5：\n13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 每一轮希尔排序的过程就是对上表中的每列进行插入排序，排序后结果为：\n10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 请注意，将数组排列成表只是为了让我们更好的理解希尔排序（逻辑分组），真正的排序过程并不会这样做。我们将这四行拼起来就是第一轮希尔排序完成后数组的状态：[10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45]。第二次，我们将步长减小，定为 3：\n10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 再对每列进行一轮插入排序，结果为：\n10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94 此时，数组已经大致有序了，此时对其进行插入排序效率较高。于是我们以步长 1 再进行希尔排序（其实就是插入排序），完成整个排序过程。\n希尔排序的步长序列\n步长的选择是希尔排序的重要部分，对希尔排序的效率有很大的影响。只要最终步长为 1 任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为普通插入排序，这就保证了数据一定会被排序。\nDonald Shell 最初建议步长选择为 n/2 并且每次对步长取半直到步长达到 1。虽然这样取可以比 O(n2)类的算法（插入排序）更好，但还是有优化平均时间复杂度和最差时间复杂度的余地。下表列出了三种步长序列及其相应的最坏情况时间复杂度：\n   步长序列 最坏情况时间复杂度     n/2i O(n2)   2k-1 O(n3/2)   2i3j O(nlog2n)    已知的最好步长序列是由 Sedgewick 提出的(1, 5, 19, 41, 109,\u0026hellip;)，该序列的项来自 9 * 4i - 9 * 2i + 1 和 2i+2 * (2i+2 - 3) + 1 这两个算式。用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。\n算法描述\n 确定好步长序列 t1, t2, \u0026hellip;, tk，最终步长 tk 应为 1； 对于某一步长 t，进行如下排序过程：将所有元素按照步长划分为 m 组。例如：[ a[0] , a[0 + t], a[0 + 2t], ... ]为一组，[ a[1], a[1 + t], a[1 + 2t], ... ]为一组。然后对每组单独进行插入排序； 根据步长序列，重复步骤 2，直到完成整个排序过程。  动图演示\n代码实现\n// TypeScript实现 export function shellSort(arr: number[]) { const len = arr.length; // 步长序列 n / 2^i  for (let gap = len \u0026gt;\u0026gt; 1; gap \u0026gt; 0; gap \u0026gt;\u0026gt;= 1) { // 执行插入排序  // i = 0 默认已排序，所以从 0 + gap 的位置开始执行插入  for (let i = gap; i \u0026lt; len; i++) { const temp = arr[i]; let j = i - gap; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp) { arr[j + gap] = arr[j]; j -= gap; } arr[j + gap] = temp; } } return arr; } 算法分析\n希尔排序是插入排序的改进版，其复杂度受所选步长序列影响。相关分析可见上文。\n空间复杂度：O(1)\n稳定性：不稳定。对单独的分组进行插入排序时，该组元素与其他分组元素的相对位置发生了变化。\n归并排序（Merge Sort） 归并排序，是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，有两种实现方式：\n 自上而下的递归； 自下而上的迭代；  这里需要指出，在《数据结构与算法 JavaScript 描述》中，作者认为递归法在 JavaScript 中不可行，因为该算法的递归栈太深了:\n However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.\n 是因为在 JavaScript 引擎中，有对调用栈深度的限制，不同浏览器/解析引擎的值可能不一样。你可以执行如下代码来了解确切的限制值：\nvar i = 0; function inc() { i++; inc(); } try { inc(); } catch (e) { console.log(\u0026#34;Maximum stack size is\u0026#34;, i, \u0026#34;in your current browser\u0026#34;); } // 在 Node.js 环境执行得到的输出： // Maximum stack size is 15678 in your current browser 假定最大调用栈深度限制为x，那么当数据量大于 2x 时，JavaScript 环境中执行递归方式的归并算法就会出错。\n算法描述\n这里给出迭代法的描述：\n 对于长度为 n 的序列，将其视为每组大小为 1 的 n 组（视为每个元素为一组）； 执行归并操作：将每相邻的 2 组合并成一个有序的新组。例如：组 1 与组 2 合并，成为新的组 1，组 3 与组 4 合并成为新的组 2； 重复步骤 2，直到组的总数为 1，此时序列排序完毕。  动图演示\n下图演示的归并顺序是递归实现的，归并操作进行的顺序与迭代法不同，但是不影响理解其核心思想。\n代码实现\n// TypeScript实现 export function mergeSort(arr: number[]) { const len = arr.length; if (len \u0026lt; 2) return arr; const _helperArr = new Array(len); /** * 对于相邻的两组序列，可以知道： * 左边界为左侧序列的起始下标 * 中间点为左右序列的分界点，是左侧序列最后元素下标+1，也是右侧序列的起始下标 * 右边界为右侧序列的右边界，也是右侧序列的最后元素下标+1 * @param leftIdx 左侧边界 * @param midIdx 中间点 * @param rightIdx 右侧边界 * @param originArr 原始数组 * @param helperArr 辅助数组 */ function merge( leftIdx: number, midIdx: number, rightIdx: number, originArr: number[], helperArr: number[] ) { let i = leftIdx; let j = midIdx; let helperArrIndex = leftIdx; // 先将归并后的数组填充到辅助数组中  while (i \u0026lt; midIdx \u0026amp;\u0026amp; j \u0026lt; rightIdx) { if (originArr[i] \u0026lt; originArr[j]) { helperArr[helperArrIndex] = originArr[i]; i++; } else { helperArr[helperArrIndex] = originArr[j]; j++; } helperArrIndex++; } while (i \u0026lt; midIdx) { helperArr[helperArrIndex] = originArr[i]; i++; helperArrIndex++; } while (j \u0026lt; rightIdx) { helperArr[helperArrIndex] = originArr[j]; j++; helperArrIndex++; } // 将序列从辅助数组中复制到原数组  for ( helperArrIndex = leftIdx; helperArrIndex \u0026lt; rightIdx; helperArrIndex++ ) { originArr[helperArrIndex] = helperArr[helperArrIndex]; } } let groupSize = 1; while (Math.ceil(len / groupSize) \u0026gt; 1) { for (let i = 0; i \u0026lt; len; i += groupSize * 2) { // 合并每相邻两组，得到新的有序组  let midIdx: number, rightIdx: number; midIdx = (midIdx = i + groupSize) \u0026gt; len ? len : midIdx; rightIdx = (rightIdx = i + groupSize * 2) \u0026gt; len ? len : rightIdx; merge(i, midIdx, rightIdx, arr, _helperArr); } // 分组大小翻倍  groupSize \u0026lt;\u0026lt;= 1; } return arr; } 算法分析\n时间复杂度：不难得出归并操作总共会进行 O(logn)层，对于每一层来说，执行归并过程中每个元素都会被操作一次，也就是每层的时间复杂度为 O(n)，所以综合的时间复杂度为 O(nlogn)。\n空间复杂度：进行归并操作时，需要一个辅助数组保存归并后的序列，其空间复杂度为 O(n)。\n稳定性：稳定\n快速排序（Quick Sort） 快速排序，又称分区交换排序（partition-exchange sort），简称快排，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn)次比较。在最坏状况下则需要 O(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。\n算法描述\n快速排序使用分治策略来把一个序列分为较小和较大的 2 个子序列，然后递归地排序两个子序列。\n 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）； 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成； 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序，直到子序列长度为 1。  动图演示\n代码实现\n// TypeScript实现 export function quickSort( arr: number[], left: number = 0, right: number = arr.length - 1 ) { if (left \u0026gt;= right) return arr; const partitionIdx = partition(arr, left, right); quickSort(arr, left, partitionIdx - 1); quickSort(arr, partitionIdx + 1, right); return arr; } // 对于序列的左、中、右三个值，取中值作为基准值 function getPivotIndex(arr: number[], left: number, right: number) { const mid = left + ((right - left) \u0026gt;\u0026gt; 1); const midValue = arr[mid]; const leftValue = arr[left]; const rightValue = arr[right]; if (leftValue \u0026lt;= rightValue) { if (midValue \u0026lt; leftValue) { return left; } else if (midValue \u0026gt; rightValue) { return right; } else { return mid; } } else { if (midValue \u0026lt; rightValue) { return right; } else if (midValue \u0026gt; leftValue) { return left; } else { return mid; } } } /** * 对于给定的子序列，取一个基准值，并根据基准值分成左右区间 * 返回最后基准值所在的下标 */ function partition(arr: number[], left: number, right: number) { const pivotIdx = getPivotIndex(arr, left, right); // 先将基准值放在最左侧  [arr[pivotIdx], arr[left]] = [arr[left], arr[pivotIdx]]; let i = left + 1; let leftPartIdx = left; // 前后指针法分区  // leftPartIdx 代表了左侧序列最后一个元素的下标  // 搜索指针会一直向前移动  while (i \u0026lt;= right) { // 如果搜索指针找到的元素小于等于基准值  // 则表示该元素应该纳入左侧序列  if (arr[i] \u0026lt; arr[left]) { // 存在距离，说明 leftPartIdx 右侧元素是大于 pivot 的  // 则交换两个元素，将较小元素放置到左侧序列的右侧  if (i - leftPartIdx \u0026gt; 1) { [arr[leftPartIdx + 1], arr[i]] = [arr[i], arr[leftPartIdx + 1]]; } // 左侧序列的长度+1  leftPartIdx++; } i++; } // 将基准值与左侧序列最后一位元素交换  [arr[leftPartIdx], arr[left]] = [arr[left], arr[leftPartIdx]]; return leftPartIdx; } 算法分析\n时间复杂度分析：在最好的情况，每次我们运行一次分割，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作 logn 次嵌套的调用。在同一层次结构的多个程序调用中，分区操作会访问每个元素一遍，总共全部仅需要 O(n)的时间。综合起来其时间复杂度是 O(nlogn)。\n空间复杂度分析：快速排序算法所使用的空间，依照使用的版本而定。这里分析使用原地（in-place）分割的快速排序版本。对于 O(logn)层深度的嵌套调用，算法需要在每一层存储一个固定数量的信息。最好的情况最多需要 O(logn)次的嵌套递归调用，所以它需要 O(logn)的空间。最坏情况下需要 O(n)次嵌套递归调用，因此需要 O(n)的空间。\n最好时间复杂度：O(nlogn)\n最坏时间复杂度：O(n2)。假定每次分割某一侧都没有子片段，则调用树的深度是 O(n)，结合上文看每层处理需要 O(n)时间，综合起来就是 O(n2)。\n平均时间复杂度：O(nlogn)\n空间复杂度：对于 in-place 版本，平均 O(logn)，最坏 O(n)。\n稳定性：不稳定\n堆排序（Heap Sort） 堆排序是利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。要理解堆排序，首先要了解一下二叉树与堆。\n二叉树与堆\n二叉树：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。\n一棵有 9 个节点且深度为 3 的二叉树\n完全二叉树：在一颗二叉树中，若满足以下两个条件，则称其为完全二叉树：\n 除最后一层外的其余层都是满的 最后一层要么是满的，要么在右边缺少连续若干节点  深度为 3 的完全二叉树 0 / \\ 1 2 / \\ / \\ 3 4 5 6 对于完全二叉树，还可以用数组来储存。如果某个节点的索引为 i，（假设根节点的索引为 0）则在它左子节点的索引会是 2i+1，右子节点会是 2i+2；而它的父节点（如果有）索引则为 (i-1)/2。\n以上文为例：\n一个存储在数组中的完全二叉树\n堆：在完全二叉树的基础上，若二叉树满足以下条件，则称其为二叉堆：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。\n当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。\n此外，由于完全二叉树的特性，它可以用数组来进行表示。下例是一个最小堆和一个最大堆以及它们相应的数组表示：\n 最小堆 最大堆 1 11 / \\ / \\ 2 3 9 10 / \\ / \\ / \\ / \\ 4 5 6 7 5 6 7 8 / \\ / \\ / \\ / \\ 8 9 10 11 1 2 3 4 位置: 0 1 2 3 4 5 6 7 8 9 10 左堆: 1 2 3 4 5 6 7 8 9 10 11 右堆: 11 9 10 5 6 7 8 1 2 3 4 了解以上内容后，接下来我们讨论堆排序的原理。\n算法描述\n 初始化最大堆：将序列调整成一个最大堆，此时堆顶元素为最大值； 堆排序过程：取出堆顶元素，将剩下的堆继续调整为最大堆； 重复过程 2，直到所有元素被取出。  初始化最大堆\n对于一颗完全二叉树，执行如下算法就可以将其调整为最大二叉堆：\n 从树的倒数第二层，调整每个节点（最大堆调整），使其成为最大二叉堆节点； 往上一层，重复步骤 1，直到根节点。  最大堆调整算法(MAX-HEAPIFY)：\n 对比节点和其左右子节点，若子节点大于该节点，将最大的子节点和该节点交换位置； 若步骤一执行了交换操作，则对于被交换的子节点，再次执行步骤 1。  借助下图进行说明：\n上图中，依次对节点 5、4、3、2、1 进行了最大堆调整，最终整个二叉树成为一个最大堆。分析其原理：\n 先对第 3 层（节点 5、4）进行最大堆调整后，每一个节点都是最大堆（执行完 MAX-HEAPIFY(A,4)）； 对第 2 层（节点 3、2）进行最大堆调整，若第二层的某个节点与其某一侧子节点进行了交换，则只需要继续往下调整该侧子树，因为另一侧子树已经满足最大堆属性； 继续调整第 1 层，完成整个最大堆的调整。  堆排序过程\n 将堆顶元素取出； 将最后一个元素放到堆顶，并对堆顶执行最大堆调整算法； 重复步骤 1、2，直到所有元素都被取出。  参考下图便于理解：\n动图演示\n代码实现\n// TypeScript实现 export function heapSort(arr: number[]) { let len = arr.length; // build max heap  for (let i = Math.floor((len - 1) / 2); i \u0026gt;= 0; i--) { maxHeapify(arr, i, len); } // sort loop  while (len) { [arr[0], arr[len - 1]] = [arr[len - 1], arr[0]]; len--; maxHeapify(arr, 0, len); } return arr; } function maxHeapify(arr: number[], index: number, heapSize: number) { let maxIdx: number; let leftIdx: number; let rightIdx: number; while (true) { maxIdx = index; leftIdx = 2 * maxIdx + 1; rightIdx = 2 * maxIdx + 2; if (leftIdx \u0026lt; heapSize \u0026amp;\u0026amp; arr[leftIdx] \u0026gt; arr[maxIdx]) { maxIdx = leftIdx; } if (rightIdx \u0026lt; heapSize \u0026amp;\u0026amp; arr[rightIdx] \u0026gt; arr[maxIdx]) { maxIdx = rightIdx; } if (maxIdx !== index) { [arr[maxIdx], arr[index]] = [arr[index], arr[maxIdx]]; index = maxIdx; } else { break; } } } 算法分析\n最好时间复杂度：O(nlogn)\n最坏时间复杂度：O(nlogn)\n平均时间复杂度：O(nlogn)\n空间复杂度：O(1)\n稳定性：不稳定\n计数排序（Counting Sort） 计数排序是一种稳定的线性时间排序算法。该算法于 1954 年由 Harold H. Seward 提出。计数排序使用一个额外的数组 C ，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。\n算法描述\n通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1。算法的步骤如下：\n 找出待排序的数组中最大和最小的元素 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素 i 放在新数组的第 C[i]项，每放一个元素就将 C[i]减去 1  动图演示\n代码实现\n// TypeScript实现 export function countingSort(arr: number[]) { let max = arr[0]; let min = arr[0]; // 找出最大值、最小值  for (const n of arr) { if (n \u0026gt; max) { max = n; } if (n \u0026lt; min) { min = n; } } // 根据最大值、最小值初始化计数数组  const count_arr: number[] = new Array(max - min + 1); // 计数  for (const n of arr) { count_arr[n - min] = count_arr[n - min] ? count_arr[n - min] + 1 : 1; } // 累加  for (let i = 1; i \u0026lt; count_arr.length; i++) { if (!count_arr[i]) count_arr[i] = 0; count_arr[i] += count_arr[i - 1]; } const res = new Array(arr.length); // 根据位置信息重新排列数组  // 将 arr[i] 元素放置到 res 数组中正确的排序位置  // 为了保持稳定性，需要采用倒序  for (let i = arr.length - 1; i \u0026gt;= 0; i--) { res[--count_arr[arr[i] - min]] = arr[i]; } return res; } 算法分析\n计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。\n最好时间复杂度：O(n+k)\n最坏时间复杂度：O(n+k)\n平均时间复杂度：O(n+k)\n空间复杂度：O(k)\n稳定性：稳定\n桶排序（Bucket Sort） 桶排序工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（可以根据情况使用最佳的排序算法）。\n算法描述\n 设置一个定量的数组当作空桶子； 寻访序列，并且把项目一个一个放到对应的桶子去； 对每个不是空的桶子进行排序； 从不是空的桶子里把项目再放回原来的序列中。  图片演示\n元素分配到桶中 对桶中元素排序\n代码实现\n// TypeScript实现 export function bucketSort(arr: number[], bucketNums = 5) { let max = arr[0]; let min = arr[0]; // 找出最大值、最小值  for (const n of arr) { if (n \u0026gt; max) { max = n; } if (n \u0026lt; min) { min = n; } } const bucketSize = Math.floor((max - min) / bucketNums) + 1; const buckets: number[][] = []; for (let i = 0; i \u0026lt; arr.length; i++) { // 将元素放入桶中  const bIdx = Math.floor((arr[i] - min) / bucketSize); const bucketArr = buckets[bIdx] || (buckets[bIdx] = []); bucketArr.push(arr[i]); // 用冒泡排序保持桶内元素有序  for (let j = bucketArr.length - 1; j \u0026gt; 0; j--) { if (bucketArr[j - 1] \u0026gt; bucketArr[j]) { [bucketArr[j - 1], bucketArr[j]] = [bucketArr[j], bucketArr[j - 1]]; } } } let res: number[] = []; buckets.forEach((bucketArr) =\u0026gt; { res = res.concat(bucketArr); }); return res; } 算法分析\n桶排序实际上只需要遍历一遍所有的待排序元素，然后依次放入指定的位置。如果加上输出排序的时间，那么需要遍历所有的桶，时间复杂度就是 O(n+k)，其中，n 为待排序的元素的个数，k 为桶的个数。\n最好时间复杂度：O(n+k)\n最坏时间复杂度：O(n2)\n平均时间复杂度：O(n+k)\n空间复杂度：O(n+k)\n稳定性：稳定\n基数排序（Radix Sort） 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n算法描述\n将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。\n基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。\n动图演示\nLSD 基数排序\n代码实现\n// TypeScript实现 export function radixSortLSD(arr: number[]) { let max = arr[0]; // 找出最大值  for (const n of arr) { if (n \u0026gt; max) { max = n; } } // 确定最大位数  let maxDigit = 0; while (max) { maxDigit++; max = Math.floor(max / 10); } const buckets: number[][] = []; let mod = 10; // 根据最大位数进行 maxDigit 轮排序  // 由低位至高位排序  for (let k = 0; k \u0026lt; maxDigit; k++, mod *= 10) { // 根据当前位数字放入对应桶中  for (let i = 0; i \u0026lt; arr.length; i++) { const bucketIdx = Math.floor((arr[i] % mod) / (mod / 10)); const bucketArr = buckets[bucketIdx] || (buckets[bucketIdx] = []); bucketArr.push(arr[i]); } // 从桶中依次取出元素排序  let idx = 0; for (let j = 0; j \u0026lt; buckets.length; j++) { if (!buckets[j]) continue; while (buckets[j].length) { arr[idx] = buckets[j].shift(); idx++; } } } return arr; } 算法分析\n基数排序共需要进行 k 轮排序，其中 k 为最大位数。每轮排序的时间复杂度为 O(n)，所以综合时间复杂度为 O(n*k)。\n最好时间复杂度：O(n*k)\n最坏时间复杂度：O(n*k)\n平均时间复杂度：O(n*k)\n空间复杂度：O(n+k)\n稳定性：稳定\n参考资料  十大经典排序算法 维基百科 - 冒泡排序 维基百科 - 选择排序 维基百科 - 插入排序 维基百科 - 希尔排序 维基百科 - 归并排序 维基百科 - 快速排序 维基百科 - 堆排序 堆排序 (Heap Sort) 维基百科 - 计数排序 维基百科 - 桶排序 维基百科 - 基数排序  ","permalink":"https://ruihusky.github.io/ruihusky/posts/2021-02-21_sorting-algorithm/","summary":"概览与术语 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法，最常用到的排序方式之一就是数值顺序。\n排序算法依照稳定性可分为稳定算法和不稳定算法。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，则在排序过的列表中 R 也将会是在 S 之前。\n排序算法依照排序过程中占用空间的方式分为 In-place 算法 与 Out-place 算法。In-place 是原地算法，基本上不需要额外的辅助空间，可允许固定数量的辅助变量。非原地算法就是 Out-place，其开辟的辅助空间与问题规模相关。例如，冒泡排序只需要数据在原序列中交换位置，不需要额外的辅助空间，是 In-place 算法。\n不同的排序算法会有不同的时间复杂度（最差、平均、和最好性能），下表列出了十种经典排序算法的概览：\n冒泡排序（Bubble Sort） 一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为：越的元素会经由交换慢慢“浮”到数列的顶端。\n冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。\n算法描述\n 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到没有任何一对数字需要比较； 可选的优化步骤：某次步骤 1~3 执行过程中没有元素发生交换，则证明该序列已经有序，不需要再进行下一次序列遍历。  动图演示\n代码实现\n// TypeScript实现 export function bubbleSort(arr: number[]) { const len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { let sorted = true; for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { sorted = false; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } if (sorted) break; } return arr; } 算法分析","title":"十大经典排序算法"},{"content":"flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：\n页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。\n这个问题看起来不难。使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：\n\u0026lt;div class=\u0026#34;page-container\u0026#34;\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;div class=\u0026#34;image-wrap\u0026#34;\u0026gt; \u0026lt;!-- 为了实现多个动画效果，图片被一个div包裹 --\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- vue css scope --\u0026gt; \u0026lt;style\u0026gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } .image { /* 跟随父元素的高度变化 */ height: 100%; } \u0026lt;/style\u0026gt; 在 Chrome 中使用移动设备仿真，各种不同高度下的效果都 OK 了。结果用自己的 iPhone 再看却出了问题：图片没有按照预想的那样自动调整高度，而是保持着原始图片的大小。\n于是我开始搜索有关 flex 布局与 min/max 样式之间如何相互作用的资料。这里先给出最后的解决方案：给 .image-wrap 元素加上 flex-basis: 688px 样式。\nflex-basis 默认值：auto 为了彻底弄明白问题出在哪里，有必要进一步了解 flex-basis 属性。以前我只是简单的以为它大概就和 width 属性一样，设置不设置都没关系。研究过后才发现这个属性有着诸多细节。（这里为了简化说明，只探讨 flex-direction: row 的情形）\n在 flex 布局中，一个 flex 子项的最终尺寸是基础尺寸、弹性增长或收缩、最大最小尺寸限制共同作用的结果。其中：\n 基础尺寸由 flex-basis 与 box-sizing 盒模型共同决定； 弹性增长指的是 flex-grow 属性，弹性收缩指的是 flex-shrink 属性。这里不做过多阐述，详情可参考：flex-grow，flex-shrink； 最大最小尺寸限制指的是 min-width / max-width 等 CSS 属性。  其中优先级为：最大最小尺寸限制 \u0026gt; 弹性增长或收缩 \u0026gt; 基础尺寸。\n按照这个理论，在上文的例子中，我已经设置好了 max-height、min-height、flex-grow、flex-shrink，虽然没有设置 flex-basis，也不应该影响结果才对。\n我在查看了更多资料之后，发现 flex-basis 还有许多细节：\n 在 flex 布局中，flex-basis 就同非 flex 布局中 width 属性表现一样； 若同时设置了确定数值的 flex-basis 与 width，则 width 属性会被忽略； 当 flex-basis 值为 auto 时（默认值），子项的基本尺寸根据其自身的尺寸决定。更具体一点地说，由 box-sizing、width、min-width、max-width以及元素内容共同决定。  再来看上文的例子，我没有设置 flex-basis ，所以它是默认值 auto，flex 子项的 flex-basis 根据其自身的尺寸决定。对于 .image-wrap 元素，根据我所设置的 CSS 样式：\n.image-wrap { flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } 它的高度应该是由 box-sizing 盒模型、min-height、max-height 属性共同决定（注意这里我没有设置 height）。看来在这种情况下，Chrome 和 Safari 下对于最终效果的处理有些不一致。\n在使用弹性布局时，最好是明确给出 flex-basis 的值。\n参考资料 Oh My God，CSS flex-basis 原来有这么多细节\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2021-01-26_css-flex-basis/","summary":"flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：\n页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。\n这个问题看起来不难。使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：\n\u0026lt;div class=\u0026#34;page-container\u0026#34;\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;div class=\u0026#34;image-wrap\u0026#34;\u0026gt; \u0026lt;!-- 为了实现多个动画效果，图片被一个div包裹 --\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- vue css scope --\u0026gt; \u0026lt;style\u0026gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } .","title":"CSS flex-basis: auto 与弹性布局"},{"content":"字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。\nUnicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。\n经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：\n 辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF \u0026hellip; 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF  所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。\n到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。\nUTF-32 UTF-32 是一种 Unicode 的实现，它使用 32 位（4 字节）对每个 Unicode 码位进行编码。而 Unicode 中，即便是辅助平面 16 中的码位，也只需要 21 位就可以编码：\nU+0001 =\u0026gt; 00000000 00000000 00000000 00000001 U+10FFFF =\u0026gt; 00000000 00010000 11111111 11111111 UTF-32 每个编码需要使用四个字节，空间浪费较多。其主要优点是可以直接由 Unicode 码位来索引。\nUTF-16 UTF-16 是一种变长编码，它使用 16 位（2 字节）来表示所有的 Unicode 基本平面码位。这么一看，岂不是只能表示 U+0000 ~ U+FFFF 范围的编码？那剩余的 16 个辅助平面怎么办？\nUTF-16 为了能继续表示辅助平面中的码位，使用了一种代理机制：用两个基本平面的编码组成一对来表示一个辅助平面的码位，称其为“代理对”，因此表现一个辅助平面的码位需要用到 32 位（4 字节）。\n这么一来不是有问题？某个 UTF-16 编码想要表示的是基本平面的码位还是辅助平面的码位呢？为了避免冲突，在基本平面中，所有用作“代理”的编码都不定义字符，以表示将其用于“代理”。\n基本平面中这些用作“代理”的编码区域被称之为“代理区”，其范围为 0xD800 ~ 0xDFFF，共 2048 个。“代理对”的前后两个代理分别称为“引导代理”、“尾随代理”。它们也有各自的取值范围：\n# 引导代理(0xD800 ~ 0xDBFF) # 1101 10pp ppxx xxxx 1101 1000 0000 0000 ~ 1101 1011 1111 1111 D 8 0 0 D B F F # 尾随代理(0xDC00 ~ 0xDFFF) # 1101 11xx xxxx xxxx 1101 1100 0000 0000 ~ 1101 1111 1111 1111 D C 0 0 D F F F 现在简要说明一下代理规则：\n其中引导代理中的 110110 、尾随代理中的 110111 是定数，p 、x 是变数。去掉定数后组合起来就是 pppp xxxx xxxx xxxx xxxx，共 20 位（2^20=1048576），刚好能够表示目前 16 个辅助平面中的全部码位（U+10000 ~ U+10FFFF，共 1048576 个）。其中 pppp 共 4 位，表示 16 个辅助平面之一的编号；紧接着的 16 位 x 表示某个辅助平面内的某个码位。\n如何将某一个辅助平面的码位转换为 UTF-16 中的“代理对”编码形式呢？以 U+1F1F1 为例说明具体算法：\n 辅助平面中的码位值减去0x10000得到 20 位长的比特组。U+1F1F1 是辅助平面 1 的码位，代理对中的平面编号值比实际的平面编号要减去 1（平面编号索引从 0 开始）。 # U+1F1F1 0001 1111 00 01 1111 0001 -0001 0000 00 00 0000 0000 =0000 1111 00 01 1111 0001 # 0000 代表是辅助平面 1 的码位  将 20 位长比特组中的高 10 位比特加上 0xD800，得到引导代理： # 第 1 步的高 10 位 0000 0000 0011 1100 +1101 1000 0000 0000 # 0xD800 =1101 1000 0011 1100 # 0xD83C 引导代理  将 20 位长比特组中的低 10 位比特加上 0xDC00，得到尾随代理： # 第 1 步的低 10 位 0000 0001 1111 0001 +1101 1100 0000 0000 # 0xDC00 =1101 1101 1111 0001 # 0xDDF1 尾随代理  将引导代理、尾随代理按前后顺序组合，就得到了该辅助平面码位值的 UTF-16 编码表示： # U+1F1F1 的 UTF-16 表示：D83CDDF1 1101 1000 0011 1100 1101 1101 1111 0001   UTF-16 的编码规则较为复杂。实际上，UTF-16 在 Unicode 字符集的三大编码方式(UTF-8、UTF-16、UTF-32)中的表现也不理想。它的存在是历史原因造成的。不过由于其推出时间最早，已被应用于大量环境中。\nUTF-8 UTF-8 是一种变长编码，其长度一般为 1~4 字节，当然也可以更长。\n举个例子来说，所有的 ASCII 字符用一个字节就足以进行表示，那么用 UTF-32 来表示就很浪费存储空间，进行网络传输时也浪费网络资源。\n相比 UTF-16 来说，UTF-8 的编码规则要容易理解的多：\n 每个 UTF-8 编码从首字节就能判断其编码长度：  首字节以0开头，为单字节编码 首字节以110开头，为双字节编码 首字节以1110开头，为三字节编码 首字节以1111开头，为四字节编码 \u0026hellip;   每个多字节的 UTF-8 编码，除首字节外的其他字节均以10开头  上述规则中的0、10、110等称之为 UTF-8 编码中的前缀码，除开前缀码之外的位就可以用来表示实际的 Unicode 码位。计算机通过前缀码就能识别 UTF-8 的每个字节的作用。\n# 单字节 UTF-8，可表示 2^(8-1)=128 个字符 0xxxxxxx # 双字节 UTF-8，可表示 2^(16-5)=2048 个字符 110xxxxx 10xxxxxx # 三字节 UTF-8，可表示 2^(24-8)=65536 个字符 1110xxxx 10xxxxxx 10xxxxxx # 四字节 UTF-8，可表示 2^(32-11)=2097152 个字符 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 再简单概括 UTF-8 的编码算法：\n 确定 UTF-8 编码中各个字节的前缀码 将 UTF-8 编码中各个字节除了前缀码所占用之外的位，依次分配给 Unicode 码位二进制中各个位的值  是不是很简单明了？UTF-8 编码设计得非常精巧，存储空间利用率较高、规则容易理解。除此之外，还有自动纠错性能好、利于传输、扩展性强等优点。而劣势在于，因为其编码长度可变，所以不利于程序的处理，例如导致正则表达式检索的复杂度大为增加。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-12-16_unicode-utf/","summary":"字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。\nUnicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。\n经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：\n 辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF \u0026hellip; 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF  所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。\n到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。","title":"Unicode 编码与 UTF-32、UTF-16、UTF-8"},{"content":"使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。\nWSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。\n从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。\n从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：\n$ cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：\nexport hostip=$(cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39;) alias proxy=\u0026#39; export https_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; export http_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; export all_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; echo -e \u0026#34;Acquire::http::Proxy \\\u0026#34;socks5h://${hostip}:10808\\\u0026#34;;\u0026#34; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf \u0026gt; /dev/null; echo -e \u0026#34;Acquire::https::Proxy \\\u0026#34;socks5h://${hostip}:10808\\\u0026#34;;\u0026#34; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf \u0026gt; /dev/null; \u0026#39; alias unproxy=\u0026#39; unset https_proxy; unset http_proxy; unset all_proxy; sudo sed -i -e \u0026#34;/Acquire::http::Proxy/d\u0026#34; /etc/apt/apt.conf.d/proxy.conf; sudo sed -i -e \u0026#34;/Acquire::https::Proxy/d\u0026#34; /etc/apt/apt.conf.d/proxy.conf; \u0026#39; 在 bash 中运行 proxy 可设置 bash、apt 走代理，运行 unproxy 则关闭代理。\n从局域网访问 WSL 2 网络 要实现从局域网访问 WSL 2 网络，需要在 Windows 上配置 端口转发 和 防火墙允许入站规则。参考以下 PowerShell 命令（需以管理员权限执行）：\n# 查询 WSL 2 IP 地址 C:\\Users\\ruihusky\u0026gt; wsl -- hostname -I 172.20.147.252 # 配置端口转发：外网访问 windows 8080 端口转发到 172.20.147.252:8080 C:\\Users\\ruihusky\u0026gt; netsh interface portproxy add v4tov4 listenport=8080 connectaddress=172.20.147.252 connectport=8080 # 添加允许入站规则 C:\\Users\\ruihusky\u0026gt; New-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 8080\u0026#34; -Direction Inbound -Action Allow -Protocol TCP -LocalPort 8080 Name : {0ff9eeaa-3e82-46f0-8b2a-cb985d514ede} DisplayName : Allow Inbound TCP Port 8080 Description : DisplayGroup : Group : Enabled : True Profile : Any Platform : {} Direction : Inbound Action : Allow EdgeTraversalPolicy : Block LooseSourceMapping : False LocalOnlyMapping : False Owner : PrimaryStatus : OK Status : 已从存储区成功分析规则。 (65536) EnforcementStatus : NotApplicable PolicyStoreSource : PersistentStore PolicyStoreSourceType : Local 配置完后可在局域网用其他设备通过 Windows IP 访问 WSL 2 服务。\n对应的删除配置命令：\nC:\\Users\\ruihusky\u0026gt; netsh interface portproxy show v4tov4 侦听 ipv4: 连接到 ipv4: 地址 端口 地址 端口 --------------- ---------- --------------- ---------- * 8080 172.20.147.252 8080 # 删除端口转发规则 C:\\Users\\ruihusky\u0026gt; netsh interface portproxy delete v4tov4 listenport=8080 # 删除防火墙入站规则 C:\\Users\\ruihusky\u0026gt; Remove-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 8080\u0026#34; 将上诉命令封装成函数便于调用，向 PowerShell $PROFILE 配置文件写入函数：\n# 在 PowerShell 中查看 $PROFILE 文件位置 C:\\Users\\ruihusky\u0026gt; $PROFILE C:\\Users\\ruihusky\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 写入以下内容：\nfunction Add-WSLPortProxy ($Port = \u0026#39;8080\u0026#39;, $Protocol = \u0026#39;TCP\u0026#39;) { $wslIP = wsl -- hostname -I $wslIP = $wslIP.Trim() netsh interface portproxy add v4tov4 listenport=$Port connectaddress=$wslIP connectport=$Port New-NetFirewallRule -DisplayName \u0026#34;Allow ${Protocol} Inbound Port ${Port}\u0026#34; -Direction Inbound -Action Allow -Protocol $Protocol -LocalPort $Port } function Remove-WSLPortProxy ($Port = \u0026#39;8080\u0026#39;, $Protocol = \u0026#39;TCP\u0026#39;) { netsh interface portproxy delete v4tov4 listenport=$Port Remove-NetFirewallRule -DisplayName \u0026#34;Allow ${Protocol} Inbound Port ${Port}\u0026#34; } 对应的调用命令为：Add-WSLPortProxy [$Port] [$Protocol] 、Remove-WSLPortProxy [$Port] [$Protocol]，其中 [$Port] [$Protocol] 均为可选参数，默认为 8080 、TCP。\n参考资料 比较 WSL 2 和 WSL 1 | 访问网络应用程序\nWin 10 与 WSL 2 间的网络和文件互访\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-12-11_wsl2-net-config/","summary":"使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。\nWSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。\n从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。\n从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：\n$ cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：","title":"Windows 10 WSL 2 网络配置"},{"content":"前言 Promise 对象用于表示一个异步操作的最终完成（或失败），及其结果值。它最早由社区提出和实现，其中有多种 Promise 规范。ES6 按照 Promise/A+ 规范将其写进了语言标准。 关于该规范的详情可参考：Promise/A+规范 中文翻译。\n基础实现 我们先尝试实现最简单的 Promise 功能：通过 Promise 包装异步请求，并使用then方法注册回调函数，通过resolve方法通知 Promise 异步请求已解决，并执行回调函数。 模拟一个基础的异步 http 请求，并使用 Promise 封装：\n// 模拟http请求 const mockAjax = (url, s, callback) =\u0026gt; { console.log(\u0026#34;[mockAjax] start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;[mockAjax] callback\u0026#34;); callback(\u0026#34;异步结果：\u0026#34; + url + \u0026#34;异步请求耗时\u0026#34; + s + \u0026#34;秒\u0026#34;); }, 1000 * s); }; // Promise基础功能 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 实现思路  then用于注册回调函数，因此可以在 Promise 实例中维护一个回调函数队列。 then要求可以进行链式调用，考虑在then方法中return this。 Promise 的构造方法接受一个[resolve =\u0026gt; {}]形式的函数，其中resolve方法接受异步请求的返回值并传递给then注册的回调函数。因此可以通过resolve方法调用回调函数队列中的函数。 这里的思路类似于观察者模式。  依照上述两点，我们可以做最简单的实现：\nclass Promise { // 回调队列  callbacks = []; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 将onFulfilled函数添加到callbacks中  this.callbacks.push(onFulfilled); // 基础链式调用  return this; } // resolve被调用时执行注册过的onFulfilled函数  _resolve(value) { this.callbacks.forEach((fn) =\u0026gt; fn(value)); } } 状态保存 在上面的实现中，存在这样的问题： 在resolve执行之后再通过then注册的回调函数不会执行。例如同步执行resolve，或者resolve之后再次调用then:\n// Promise const p = new Promise((resolve) =\u0026gt; { // 同步执行的resolve，比then先执行  resolve(result); // 此处的回调不会执行 }).then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); // 此处的回调不会执行 p.then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 为了解决这个问题，我们需要在 Promise 中保存状态和值。规范中规定，Promise 的状态可以从pending转换为fulfilled或者rejected，分别代表“处理中”、“已解决”、“已失败”。状态转换的过程是不可逆的。修改上文的实现如下：\n// 带基础链式调用功能的简单实现 class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 在Promise未解决之前，onFulfilled函数添加到callbacks中  if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(onFulfilled); // 在Promise解决之后，直接执行onFulfilled函数  } else { onFulfilled(this.value); } // 基础链式调用  return this; } // resolve被调用时执行注册过的onFulfilled函数  _resolve(value) { // 改变状态  this.state = \u0026#34;fulfilled\u0026#34;; // 保存结果  this.value = value; this.callbacks.forEach((fn) =\u0026gt; fn(value)); } } 参考代码：Promise：基础实现。\n进阶：链式调用 考虑如下一种链式调用的情形：\n// 在链式调用中传递值 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); return \u0026#34;第一个then的返回值\u0026#34;; }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 注意到，第一个then方法最后返回了一个值，并且我们希望在第二个then方法中可以接收到。\n链式 Promise 首先，第二个then方法中接受的值与最初 Promise 的值是不同的；其次，Promise 的状态改变是不可逆的，因此我们不能在then方法中重新修改 Promise 的值，这不符合规范。那么只剩下一种可能来实现then的链式调用：then方法最终返回的是一个新的 Promise 实例，并且该实例的值就是第一个then方法中return语句的返回值，比如上例中的字符串\u0026quot;第一个 then 的返回值\u0026quot;。\n我们就依据上文的示例来理清一下思路：\n 第一个then方法注册的回调函数应该保存在第一个 Promise 实例之中（代称 p1），并且最终调用该回调函数的也应该是 p1 实例。 在 p1 实例调用回调函数时，需要获得回调函数的返回值，并且传递给下一个 Promise 实例(代称 p2)，也就是调用p2.resolve(/*回调函数的返回值*/)。 p2.then以及之后的链式调用思路是递归的。  理解以上几点之后，我们尝试实现：\n// 链式Promise class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // _resolve方法用于改变Promise的状态为已解决，并执行回调队列[形式为(value) =\u0026gt; {}]  _resolve(value) { // 改变状态，保存值  this.state = \u0026#34;fulfilled\u0026#34;; this.value = value; // 依次执行回调队列  this.callbacks.forEach((fn) =\u0026gt; fn()); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 返回了新的 Promise 实例，这样可实现真正的链式调用  const nextPromise = new Promise((resolve) =\u0026gt; { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(() =\u0026gt; { this._execCb(onFulfilled, resolve); }); return; } if (this.state === \u0026#34;fulfilled\u0026#34;) { this._execCb(onFulfilled, resolve); return; } }); return nextPromise; } _execCb(cb, resolve) { const x = cb(this.value); resolve(x); } } 核心思路就是通过递归实现链式调用，可能不那么容易看懂，这里列出几个要点以帮助理解：\n _execCb方法负责执行回调函数，并且将回调函数的返回值通过resolve(x)传递给下一个 Promise。 then方法中，先创建了新的 Promise，并且在其构造函数中，根据当前 Promise 的状态选择执行回调函数或者将该操作放入回调队列。 _resolve方法负责改变 Promise 的状态为已解决，并按顺序执行回调队列。  仔细理解以上三点，再总结一下核心思路：前一个 Promise 执行resolve时，回调队列将被执行，并且回调队列中所执行函数的返回值通过下一个 Promise 的resolve传入。这就是通过链式 Promise 实现链式调用的基础。\n当返回值为 Promise 考虑如下一个应用场景：\n// 在链式调用中传递Promise new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); return new Promise((resolve) =\u0026gt; { resolve(\u0026#34;第一个then返回了一个Promise\u0026#34;); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 当注册的回调函数返回了一个 Promise 时，我们希望之后注册的回调队列能等待该 Promise 改变状态再执行，这又如何实现呢？在理解上文的基础上，我们理清一下思路：\n 按照之前的逻辑，第一个then方法将生成一个 Promise(代称 p1)，并且回调函数将返回一个 Promise 实例(代称 p2)。 如果 p2 的状态依旧为pending，则需要等待其状态改变，再执行 p1 相应的状态改变方法。  其实这部分内容在 Promise/A+规范：Promise 解决过程 一节中有详细的处理逻辑，这里引用一部分内容：\n Promise 解决过程是一个抽象的操作，其需输入一个promise和一个值，我们表示为[[Resolve]](promise, x)，如果x有then方法且看上去像一个 Promise ，解决程序即尝试使promise接受x的状态；否则其用x的值来执行promise。\n 更多详细的说明大家可以点击链接查看。\n在这里我们先简化问题，只考虑回调函数返回值为 Promise 这一种特殊情况，且不处理 rejected 状态。\n首先明白一个概念：在获得回调函数的返回值后，根据该返回值处理下一个 Promise 的过程称之为 Promise 解决过程。在该过程中，判断回调函数返回值为 Promise 时，调用该 Promise 的 then 方法，将此次解决过程注册为回调函数延迟执行。这一段有点绕，我们参考代码理解：\n// Promise解决过程 function resolvePromise(promise, x, resolve) { if (x instanceof Promise) { const then = x.then; then.call(x, (y) =\u0026gt; { resolvePromise(promise, y, resolve); }); return; } resolve(x); } // 链式Promise class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // _resolve方法用于改变Promise的状态为已解决，并执行回调队列[形式为(value) =\u0026gt; {}]  _resolve(value) { // 改变状态，保存值  this.state = \u0026#34;fulfilled\u0026#34;; this.value = value; // 依次执行回调队列  this.callbacks.forEach((fn) =\u0026gt; fn()); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 返回了新的 Promise 实例，这样可实现真正的链式调用  const nextPromise = new Promise((resolve) =\u0026gt; { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(() =\u0026gt; { // 必须异步执行，否则无法获取nextPromise对象  setTimeout(() =\u0026gt; { this._execCb(onFulfilled, nextPromise, resolve); }); }); return; } if (this.state === \u0026#34;fulfilled\u0026#34;) { // 必须异步执行，否则无法获取nextPromise对象  setTimeout(() =\u0026gt; { this._execCb(onFulfilled, nextPromise, resolve); }); return; } }); return nextPromise; } _execCb(cb, nextPromise, resolve) { const x = cb(this.value); resolvePromise(nextPromise, x, resolve); } } 这部分内容可能不易理解，请大家多动手多思考。这一节的完整代码可参考：Promise：链式调用实现。\n完整实现 上文已经将 Promise 的核心逻辑实现。在理解了这部分的基础上，参照规范将其余部分进行实现应该不难了。 剩下的工作主要在于添加 rejected 状态处理，以及考虑一些边界条件(例如当resolve传递了Promise实例本身导致链式调用进入死循环)。 完整的实现代码可以参考：Promise/A+完整实现。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-11-27_promise-aplus/","summary":"前言 Promise 对象用于表示一个异步操作的最终完成（或失败），及其结果值。它最早由社区提出和实现，其中有多种 Promise 规范。ES6 按照 Promise/A+ 规范将其写进了语言标准。 关于该规范的详情可参考：Promise/A+规范 中文翻译。\n基础实现 我们先尝试实现最简单的 Promise 功能：通过 Promise 包装异步请求，并使用then方法注册回调函数，通过resolve方法通知 Promise 异步请求已解决，并执行回调函数。 模拟一个基础的异步 http 请求，并使用 Promise 封装：\n// 模拟http请求 const mockAjax = (url, s, callback) =\u0026gt; { console.log(\u0026#34;[mockAjax] start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;[mockAjax] callback\u0026#34;); callback(\u0026#34;异步结果：\u0026#34; + url + \u0026#34;异步请求耗时\u0026#34; + s + \u0026#34;秒\u0026#34;); }, 1000 * s); }; // Promise基础功能 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.","title":"Promise实现原理（Promise/A+规范）"},{"content":"构造函数模式与原型 在 ES5 中，我们可以自定义构造函数用于创建特定的类型对象，例如：\n// 定义构造函数 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function () { console.log(this.name); }; } // 以 new 操作符调用构造函数 let person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); let person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); person1.sayName(); // Nicholas person2.sayName(); // Greg 其实这里的“构造函数”说法只是一种概念上的区分，它与普通的 JavaScript 函数没什么区别。通常会约定构造函数以大写字母开头，非构造函数以小写字母开头。\n通过new操作符调用构造函数，会创建一个 Person 的实例。具体的创建过程如下：\n 在内存中创建一个新对象。 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 执行构造函数内的代码，并以刚才新建的对象作为this值。 若构造函数返回非空对象，则返回该对象，否则返回刚才创建的对象。  每个函数都会有prototype属性，它是一个对象，默认有一个属性constructor指向函数本身。而通过new操作符创建的新对象，内部的[[Prototype]]属性指向该原型对象。下面的例子展示了这些特性：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { console.log(this.name); }; console.log(Person.prototype.constructor === Person); // true  const person1 = new Person(); person1.sayName(); // \u0026#34;Nicholas\u0026#34;  const person2 = new Person(); person2.sayName(); // \u0026#34;Nicholas\u0026#34;  console.log(person1.sayName == person2.sayName); // true console.log(Object.getPrototypeOf(person1) === Person.prototype); // true 访问对象的属性时，会先从对象的自身拥有的属性找起。找不到再去对象的[[Prototype]]所指向的对象中寻找。上面的例子也说明了这一点。\n继承 ECMAScript 中描述了 原型链 的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。回想一下上文的概念：每个构造函数都有一个原型对象，而实例有一个内部指针指向原型。如果原型是另一个构造函数的实例呢？那意味着这个实例也会有一个内部指针指向另一个原型。这样就在实例和原型之间构造了一条原型链。\n实现原型链的一种基本模式是让 原型对象等于另一个类型的实例：\nfunction SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function () { return this.property; }; function SubType() { this.subProperty = false; } // 继承 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subProperty; }; const instance = new SubType(); console.log(instance.getSuperValue()); // true 以上代码定义了 SuperType、SubType 两个类型，他们分别有自己的属性和方法。通过重写 Subtype 的原型对象（让其等于 SuperType 的实例），可以让存在于 SuperType 实例中的所有属性和方法在 SubType.prototype 访问到。\n结合上文的原型搜索机制来理解：访问一个实例属性时，首先在实例中搜索该属性。如果没有找到则会继续搜索该实例的原型。通过原型链实现继承后，搜索过程就会沿着原型链继续向上。拿上面的例子来说，调用 instance.getSuperValue() 的过程如下：\n搜索 SubType 实例 \u0026ndash;\u0026gt; 搜索SubType.prototype \u0026ndash;\u0026gt; 搜索SuperType.prototype \u0026ndash;\u0026gt; 找到 getSuperValue 方法\n另外，任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向 Object.prototype。因此可以这么概括：SubType 继承自 SuperType ，SuperType 继承自 Object。完整的原型链如下：\n原型链的问题 原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。举例来说：\nfunction SuperType() { this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } function SubType() {} // 继承了SuperType SubType.prototype = new SuperType(); const instance1 = new SubType(); instance1.colors.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // \u0026#34;red,blue,green,black\u0026#34;  const instance2 = new SubType(); console.log(instance2.colors); // \u0026#34;red,blue,green,black\u0026#34; 原型中包含引用值时，该引用值就会在所有实例中共享。可以看到，对 instance1.colors 所做的修改，会在 instance2 反映出来。\n原型链的第二个问题是：创建子类实例时，无法向超类的构造函数传递参数。\n为了解决这些问题，通常会使用下面这些技术来实现继承。\n组合继承 通过将原型链和借用构造函数技术相结合达到目的。使用原型链实现对原型属性、方法的继承，通过借用构造函数实现对实例属性的继承。\nfunction SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function () { console.log(this.name); }; function SubType(name, age) { // 继承属性，通过call()函数在子类实例内部创建超类的属性  SuperType.call(this, name); this.age = age; } // 子类原型指向超类实例：这样可以通过原型链访问到超类原型 SubType.prototype = new SuperType(); // 默认情况下，所有原型对象会自动获得一个constructor（构造函数）属性，指向原型对象所在函数。 // 覆写的prototype对象没有constructor属性，需要重新指定。 SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function () { console.log(this.age); }; const instance1 = new SubType(\u0026#34;Nicholas\u0026#34;, 29); instance1.colors.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // \u0026#34;red,blue,green,black\u0026#34; instance1.sayName(); // \u0026#34;Nicholas\u0026#34;; instance1.sayAge(); // 29  const instance2 = new SubType(\u0026#34;Greg\u0026#34;, 27); console.log(instance2.colors); // \u0026#34;red,blue,green\u0026#34; instance2.sayName(); // \u0026#34;Greg\u0026#34;; instance2.sayAge(); // 27 在这个例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 超类实例直接赋值给子类原型，Subtype.prototype 也有 name、colors 属性。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  这种继承方式是 JavaScript 中最为常见的继承模式。并且 instanceof 和 isPrototypeOf() 也能够用于识别子类实例。\n寄生式组合继承 组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，为了达到子类继承超类的目的，需要做到以下两点：\n 子类拥有超类实例的所有属性。 子类继承超类的原型。  对于第 1 点，使用借用构造函数的方法就可以实现了：\nfunction SubType(name, age) { // 继承属性，通过call()函数在子类实例内部创建超类的属性  SuperType.call(this, name); this.age = age; } 对于第 2 点，我们通过下述模式实现：\n// 这里是原型式继承。通过该函数，将实例的原型指定为对象o，从而拥有o的属性。 function object(o) { function F() {} F.prototype = o; return new F(); } // 寄生式组合继承的核心逻辑 // 接受两个参数：子类构造函数、超类构造函数 function inheritPrototype(subType, superType) { // 创建prototype对象，目的是准备把它当成子类的原型。同时该prototype对象的原型是超类原型。  const prototype = object(superType.prototype); //创建对象  // 覆写的prototype对象没有constructor属性，需要重新指定。  prototype.constructor = subType; // 将prototype对象赋值给子类原型  subType.prototype = prototype; } 简单的一句话概括：创建一个空对象作为子类的原型，同时将该对象的原型指向超类原型。这样一来子类只继承了超类的原型，而与超类实例无关。 下面是一个更加具体的例子：\nfunction SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function () { console.log(this.name); }; function SubType(name, age) { // 借用构造函数继承实例属性  SuperType.call(this, name); this.age = age; } // 继承超类原型 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function () { console.log(this.age); }; 在上面的例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  与上述组合继承方式相比，这种继承方式避免了在 SubType.prototype 上创建多余的属性，同时保持了原型链不变。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-11-12_js-prototype/","summary":"构造函数模式与原型 在 ES5 中，我们可以自定义构造函数用于创建特定的类型对象，例如：\n// 定义构造函数 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function () { console.log(this.name); }; } // 以 new 操作符调用构造函数 let person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); let person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); person1.sayName(); // Nicholas person2.sayName(); // Greg 其实这里的“构造函数”说法只是一种概念上的区分，它与普通的 JavaScript 函数没什么区别。通常会约定构造函数以大写字母开头，非构造函数以小写字母开头。\n通过new操作符调用构造函数，会创建一个 Person 的实例。具体的创建过程如下：\n 在内存中创建一个新对象。 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 执行构造函数内的代码，并以刚才新建的对象作为this值。 若构造函数返回非空对象，则返回该对象，否则返回刚才创建的对象。  每个函数都会有prototype属性，它是一个对象，默认有一个属性constructor指向函数本身。而通过new操作符创建的新对象，内部的[[Prototype]]属性指向该原型对象。下面的例子展示了这些特性：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.","title":"JavaScript原型与继承"}]