[{"content":"flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：\n页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。\n我一想，使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：\n\u0026lt;div class=\u0026#34;page-container\u0026#34;\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;div class=\u0026#34;image-wrap\u0026#34;\u0026gt; \u0026lt;!-- 为了实现多个动画效果，图片被一个div包裹 --\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- vue css scope --\u0026gt; \u0026lt;style\u0026gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } .image { /* 跟随父元素的高度变化 */ height: 100%; } \u0026lt;/style\u0026gt; 在 Chrome 中使用移动设备仿真，各种不同高度下的效果都 OK 了。结果用自己的 iPhone 再看却出了问题：图片没有按照预想的那样自动调整高度，而是保持原始图片的大小不变。\n于是我上网搜索了有关 flex 布局与 min/max 尺寸限制相关的资料，最后的解决方案是：给 .image-wrap 元素加上 flex-basis: 688px 这一行样式。\n关于 flex-basis: auto 为了彻底弄明白问题出在哪里，有必要进一步了解 flex-basis 属性。以前我只是简单的以为它大概就和 width 属性一样，设置不设置都没关系。研究过后才发现这个属性有着诸多细节。（这里为了简化说明，只探讨 flex-direction: row 的情形）\n在 flex 布局中，一个 flex 子项的最终尺寸是基础尺寸、弹性增长或收缩、最大最小尺寸限制共同作用的结果。其中：\n 基础尺寸由 flex-basis、width 等属性以及 box-sizing 盒模型共同决定； 弹性增长指的是 flex-grow 属性，弹性收缩指的是 flex-shrink 属性； 最大最小尺寸限制指的是 min-width / max-width 等 CSS 属性，以及 min-content 最小内容尺寸。  其中优先级为：最大最小尺寸限制 \u0026gt; 弹性增长或收缩 \u0026gt; 基础尺寸。\n按照这个理论，在上文的例子中，我已经设置好了 max-height、min-height、flex-grow、flex-shrink，虽然没有设置 flex-basis，也不应该影响结果才对。\n当我没有设置 flex-basis 时，它就是默认值 auto。此时 flex 子项的 flex-basis 根据其自身的尺寸决定，由 box-sizing 盒模型、 width / min-width / max-width 等属性以及 content 内容（min-content 最小宽度）共同决定。看来在 Chrome 和 Safari 下对于flex-basis: auto 的处理有些不一致。\n看来以后在使用弹性布局时，最好是明确给出 flex-basis 的值。\n","permalink":"https://ruihusky.github.io/posts/2021-01-26_css-flex-basis/","summary":"flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：\n页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。\n我一想，使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：\n\u0026lt;div class=\u0026#34;page-container\u0026#34;\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;div class=\u0026#34;image-wrap\u0026#34;\u0026gt; \u0026lt;!-- 为了实现多个动画效果，图片被一个div包裹 --\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- vue css scope --\u0026gt; \u0026lt;style\u0026gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } .","title":"CSS flex-basis: auto 与弹性布局"},{"content":"字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。\nUnicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。\n经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：\n 辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF \u0026hellip; 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF  所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。\n到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。\nUTF-32 UTF-32 是一种 Unicode 的实现，它使用 32 位（4 字节）对每个 Unicode 码位进行编码。而 Unicode 中，即便是辅助平面 16 中的码位，也只需要 21 位就可以编码：\nU+0001 =\u0026gt; 00000000 00000000 00000000 00000001 U+10FFFF =\u0026gt; 00000000 00010000 11111111 11111111 UTF-32 每个编码需要使用四个字节，空间浪费较多。其主要优点是可以直接由 Unicode 码位来索引。\nUTF-16 UTF-16 是一种变长编码，它使用 16 位（2 字节）来表示所有的 Unicode 基本平面码位。这么一看，岂不是只能表示 U+0000 ~ U+FFFF 范围的编码？那剩余的 16 个辅助平面怎么办？\nUTF-16 为了能继续表示辅助平面中的码位，使用了一种代理机制：用两个基本平面的编码组成一对来表示一个辅助平面的码位，称其为“代理对”，因此表现一个辅助平面的码位需要用到 32 位（4 字节）。\n这么一来不是有问题？某个 UTF-16 编码想要表示的是基本平面的码位还是辅助平面的码位呢？为了避免冲突，在基本平面中，所有用作“代理”的编码都不定义字符，以表示将其用于“代理”。\n基本平面中这些用作“代理”的编码区域被称之为“代理区”，其范围为 0xD800 ~ 0xDFFF，共 2048 个。“代理对”的前后两个代理分别称为“引导代理”、“尾随代理”。它们也有各自的取值范围：\n# 引导代理(0xD800 ~ 0xDBFF) # 1101 10pp ppxx xxxx 1101 1000 0000 0000 ~ 1101 1011 1111 1111 D 8 0 0 D B F F # 尾随代理(0xDC00 ~ 0xDFFF) # 1101 11xx xxxx xxxx 1101 1100 0000 0000 ~ 1101 1111 1111 1111 D C 0 0 D F F F 现在简要说明一下代理规则：\n其中引导代理中的 110110 、尾随代理中的 110111 是定数，p 、x 是变数。去掉定数后组合起来就是 pppp xxxx xxxx xxxx xxxx，共 20 位（2^20=1048576），刚好能够表示目前 16 个辅助平面中的全部码位（U+10000 ~ U+10FFFF，共 1048576 个）。其中 pppp 共 4 位，表示 16 个辅助平面之一的编号；紧接着的 16 位 x 表示某个辅助平面内的某个码位。\n如何将某一个辅助平面的码位转换为 UTF-16 中的“代理对”编码形式呢？以 U+1F1F1 为例说明具体算法：\n 辅助平面中的码位值减去0x10000得到 20 位长的比特组： # U+1F1F1 0001 1111 00 01 1111 0001 -0001 0000 00 00 0000 0000 =0000 1111 00 01 1111 0001  将 20 位长比特组中的高 10 位比特加上 0xD800，得到引导代理： # 第1步的高10位 0000 0000 0011 1100 +1101 1000 0000 0000 # 0xD800 =1101 1000 0011 1100 # 0xD83C 引导代理  将 20 位长比特组中的低 10 位比特加上 0xDC00，得到尾随代理： # 第1步的低10位 0000 0001 1111 0001 +1101 1100 0000 0000 # 0xDC00 =1101 1101 1111 0001 # 0xDDF1 尾随代理  将引导代理、尾随代理按前后顺序组合，就得到了该辅助平面码位值的 UTF-16 编码表示： # U+1F1F1的UTF-16表示：D83CDDF1 1101 1000 0011 1100 1101 1101 1111 0001   可以感觉到，UTF-16 的编码规则较为复杂。实际上，UTF-16 在 Unicode 字符集的三大编码方式(UTF-8、UTF-16、UTF-32)中的表现也不理想。它的存在是历史原因造成的。不过由于其推出时间最早，已被应用于大量环境中。\nUTF-8 UTF-8 是一种变长编码，其长度一般为 1~4 字节，当然也可以更长。\n举个例子来说，所有的 ASCII 字符用一个字节就足以进行表示，那么用 UTF-32 来表示就很浪费存储空间，进行网络传输时也浪费网络资源。\n相比 UTF-16 来说，UTF-8 的编码规则要容易理解的多：\n 每个 UTF-8 编码从首字节就能判断其编码长度：  首字节以0开头，为单字节编码 首字节以110开头，为双字节编码 首字节以1110开头，为三字节编码 首字节以1111开头，为四字节编码 \u0026hellip;   每个多字节的 UTF-8 编码，除首字节外的其他字节均以10开头  上述规则中的0、10、110等称之为 UTF-8 编码中的前缀码，除开前缀码之外的位就可以用来表示实际的 Unicode 码位。计算机通过前缀码就能识别 UTF-8 的每个字节的作用。\n# 单字节 UTF-8，可表示 2^(8-1)=128 个字符 0xxxxxxx # 双字节 UTF-8，可表示 2^(16-5)=2048 个字符 110xxxxx 10xxxxxx # 三字节 UTF-8，可表示 2^(24-8)=65536 个字符 1110xxxx 10xxxxxx 10xxxxxx # 四字节 UTF-8，可表示 2^(32-11)=2097152 个字符 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 再简单概括 UTF-8 的编码算法：\n 确定 UTF-8 编码中各个字节的前缀码 将 UTF-8 编码中各个字节除了前缀码所占用之外的位，依次分配给 Unicode 码位二进制中各个位的值  是不是很简单明了？UTF-8 编码设计得非常精巧，存储空间利用率较高、规则容易理解。除此之外，还有自动纠错性能好、利于传输、扩展性强等优点。而劣势在于，因为其编码长度可变，所以不利于程序的处理，例如导致正则表达式检索的复杂度大为增加。\n","permalink":"https://ruihusky.github.io/posts/2020-12-16_unicode-utf/","summary":"字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。\nUnicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。\n经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：\n 辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF \u0026hellip; 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF  所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。\n到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。","title":"Unicode 编码与 UTF-32、UTF-16、UTF-8"},{"content":"使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。\nWSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。\n从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。\n从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：\n$ cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：\nexport hostip=$(cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39;) alias proxy=\u0026#39; export https_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; export http_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; export all_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; echo -e \u0026#34;Acquire::http::Proxy \\\u0026#34;socks5h://${hostip}:10808\\\u0026#34;;\u0026#34; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf \u0026gt; /dev/null; echo -e \u0026#34;Acquire::https::Proxy \\\u0026#34;socks5h://${hostip}:10808\\\u0026#34;;\u0026#34; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf \u0026gt; /dev/null; \u0026#39; alias unproxy=\u0026#39; unset https_proxy; unset http_proxy; unset all_proxy; sudo sed -i -e \u0026#34;/Acquire::http::Proxy/d\u0026#34; /etc/apt/apt.conf.d/proxy.conf; sudo sed -i -e \u0026#34;/Acquire::https::Proxy/d\u0026#34; /etc/apt/apt.conf.d/proxy.conf; \u0026#39; 在 bash 中运行 proxy 可设置 bash、apt 走代理，运行 unproxy 则关闭代理。\n从局域网访问 WSL 2 网络 要实现从局域网访问 WSL 2 网络，需要在 Windows 上配置 端口转发 和 防火墙允许入站规则。参考以下 PowerShell 命令（需以管理员权限执行）：\n# 查询 WSL 2 IP 地址 C:\\Users\\ruihusky\u0026gt; wsl -- hostname -I 172.20.147.252 # 配置端口转发：外网访问 windows 8080 端口转发到 172.20.147.252:8080 C:\\Users\\ruihusky\u0026gt; netsh interface portproxy add v4tov4 listenport=8080 connectaddress=172.20.147.252 connectport=8080 # 添加允许入站规则 C:\\Users\\ruihusky\u0026gt; New-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 8080\u0026#34; -Direction Inbound -Action Allow -Protocol TCP -LocalPort 8080 Name : {0ff9eeaa-3e82-46f0-8b2a-cb985d514ede} DisplayName : Allow Inbound TCP Port 8080 Description : DisplayGroup : Group : Enabled : True Profile : Any Platform : {} Direction : Inbound Action : Allow EdgeTraversalPolicy : Block LooseSourceMapping : False LocalOnlyMapping : False Owner : PrimaryStatus : OK Status : 已从存储区成功分析规则。 (65536) EnforcementStatus : NotApplicable PolicyStoreSource : PersistentStore PolicyStoreSourceType : Local 配置完后可在局域网用其他设备通过 Windows IP 访问 WSL 2 服务。\n对应的删除配置命令：\nC:\\Users\\ruihusky\u0026gt; netsh interface portproxy show v4tov4 侦听 ipv4: 连接到 ipv4: 地址 端口 地址 端口 --------------- ---------- --------------- ---------- * 8080 172.20.147.252 8080 # 删除端口转发规则 C:\\Users\\ruihusky\u0026gt; netsh interface portproxy delete v4tov4 listenport=8080 # 删除防火墙入站规则 C:\\Users\\ruihusky\u0026gt; Remove-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 8080\u0026#34; 将上诉命令封装成函数便于调用，向 PowerShell $PROFILE 配置文件写入函数：\n# 在 PowerShell 中查看 $PROFILE 文件位置 C:\\Users\\ruihusky\u0026gt; $PROFILE C:\\Users\\ruihusky\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 写入以下内容：\nfunction Add-WSLPortProxy ($Port = \u0026#39;8080\u0026#39;, $Protocol = \u0026#39;TCP\u0026#39;) { $wslIP = wsl -- hostname -I $wslIP = $wslIP.Trim() netsh interface portproxy add v4tov4 listenport=$Port connectaddress=$wslIP connectport=$Port New-NetFirewallRule -DisplayName \u0026#34;Allow ${Protocol} Inbound Port ${Port}\u0026#34; -Direction Inbound -Action Allow -Protocol $Protocol -LocalPort $Port } function Remove-WSLPortProxy ($Port = \u0026#39;8080\u0026#39;, $Protocol = \u0026#39;TCP\u0026#39;) { netsh interface portproxy delete v4tov4 listenport=$Port Remove-NetFirewallRule -DisplayName \u0026#34;Allow ${Protocol} Inbound Port ${Port}\u0026#34; } 对应的调用命令为：Add-WSLPortProxy [$Port] [$Protocol] 、Remove-WSLPortProxy [$Port] [$Protocol]，其中 [$Port] [$Protocol] 均为可选参数，默认为 8080 、TCP。\n参考 比较 WSL 2 和 WSL 1 | 访问网络应用程序\nWin 10 与 WSL 2 间的网络和文件互访\n","permalink":"https://ruihusky.github.io/posts/2020-12-11_wsl2-net-config/","summary":"使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。\nWSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。\n从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。\n从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：\n$ cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：","title":"Windows 10 WSL 2 网络配置"},{"content":"前言 Promise 对象用于表示一个异步操作的最终完成（或失败），及其结果值。它最早由社区提出和实现，其中有多种 Promise 规范。ES6 按照 Promise/A+ 规范将其写进了语言标准。 关于该规范的详情可参考：Promise/A+规范 中文翻译。\n基础实现 我们先尝试实现最简单的 Promise 功能：通过 Promise 包装异步请求，并使用then方法注册回调函数，通过resolve方法通知 Promise 异步请求已解决，并执行回调函数。 模拟一个基础的异步 http 请求，并使用 Promise 封装：\n// 模拟http请求 const mockAjax = (url, s, callback) =\u0026gt; { console.log(\u0026#34;[mockAjax] start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;[mockAjax] callback\u0026#34;); callback(\u0026#34;异步结果：\u0026#34; + url + \u0026#34;异步请求耗时\u0026#34; + s + \u0026#34;秒\u0026#34;); }, 1000 * s); }; // Promise基础功能 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 实现思路  then用于注册回调函数，因此可以在 Promise 实例中维护一个回调函数队列。 then要求可以进行链式调用，考虑在then方法中return this。 Promise 的构造方法接受一个[resolve =\u0026gt; {}]形式的函数，其中resolve方法接受异步请求的返回值并传递给then注册的回调函数。因此可以通过resolve方法调用回调函数队列中的函数。 这里的思路类似于观察者模式。  依照上述两点，我们可以做最简单的实现：\nclass Promise { // 回调队列  callbacks = []; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 将onFulfilled函数添加到callbacks中  this.callbacks.push(onFulfilled); // 基础链式调用  return this; } // resolve被调用时执行注册过的onFulfilled函数  _resolve(value) { this.callbacks.forEach((fn) =\u0026gt; fn(value)); } } 状态保存 在上面的实现中，存在这样的问题： 在resolve执行之后再通过then注册的回调函数不会执行。例如同步执行resolve，或者resolve之后再次调用then:\n// Promise const p = new Promise((resolve) =\u0026gt; { // 同步执行的resolve，比then先执行  resolve(result); // 此处的回调不会执行 }).then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); // 此处的回调不会执行 p.then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 为了解决这个问题，我们需要在 Promise 中保存状态和值。规范中规定，Promise 的状态可以从pending转换为fulfilled或者rejected，分别代表“处理中”、“已解决”、“已失败”。状态转换的过程是不可逆的。修改上文的实现如下：\n// 带基础链式调用功能的简单实现 class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 在Promise未解决之前，onFulfilled函数添加到callbacks中  if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(onFulfilled); // 在Promise解决之后，直接执行onFulfilled函数  } else { onFulfilled(this.value); } // 基础链式调用  return this; } // resolve被调用时执行注册过的onFulfilled函数  _resolve(value) { // 改变状态  this.state = \u0026#34;fulfilled\u0026#34;; // 保存结果  this.value = value; this.callbacks.forEach((fn) =\u0026gt; fn(value)); } } 参考代码：Promise：基础实现。\n进阶：链式调用 考虑如下一种链式调用的情形：\n// 在链式调用中传递值 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); return \u0026#34;第一个then的返回值\u0026#34;; }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 注意到，第一个then方法最后返回了一个值，并且我们希望在第二个then方法中可以接收到。\n链式 Promise 首先，第二个then方法中接受的值与最初 Promise 的值是不同的；其次，Promise 的状态改变是不可逆的，因此我们不能在then方法中重新修改 Promise 的值，这不符合规范。那么只剩下一种可能来实现then的链式调用：then方法最终返回的是一个新的 Promise 实例，并且该实例的值就是第一个then方法中return语句的返回值，比如上例中的字符串\u0026quot;第一个 then 的返回值\u0026quot;。\n我们就依据上文的示例来理清一下思路：\n 第一个then方法注册的回调函数应该保存在第一个 Promise 实例之中（代称 p1），并且最终调用该回调函数的也应该是 p1 实例。 在 p1 实例调用回调函数时，需要获得回调函数的返回值，并且传递给下一个 Promise 实例(代称 p2)，也就是调用p2.resolve(/*回调函数的返回值*/)。 p2.then以及之后的链式调用思路是递归的。  理解以上几点之后，我们尝试实现：\n// 链式Promise class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // _resolve方法用于改变Promise的状态为已解决，并执行回调队列[形式为(value) =\u0026gt; {}]  _resolve(value) { // 改变状态，保存值  this.state = \u0026#34;fulfilled\u0026#34;; this.value = value; // 依次执行回调队列  this.callbacks.forEach((fn) =\u0026gt; fn()); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 返回了新的 Promise 实例，这样可实现真正的链式调用  const nextPromise = new Promise((resolve) =\u0026gt; { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(() =\u0026gt; { this._execCb(onFulfilled, resolve); }); return; } if (this.state === \u0026#34;fulfilled\u0026#34;) { this._execCb(onFulfilled, resolve); return; } }); return nextPromise; } _execCb(cb, resolve) { const x = cb(this.value); resolve(x); } } 核心思路就是通过递归实现链式调用，可能不那么容易看懂，这里列出几个要点以帮助理解：\n _execCb方法负责执行回调函数，并且将回调函数的返回值通过resolve(x)传递给下一个 Promise。 then方法中，先创建了新的 Promise，并且在其构造函数中，根据当前 Promise 的状态选择执行回调函数或者将该操作放入回调队列。 _resolve方法负责改变 Promise 的状态为已解决，并按顺序执行回调队列。  仔细理解以上三点，再总结一下核心思路：前一个 Promise 执行resolve时，回调队列将被执行，并且回调队列中所执行函数的返回值通过下一个 Promise 的resolve传入。这就是通过链式 Promise 实现链式调用的基础。\n当返回值为 Promise 考虑如下一个应用场景：\n// 在链式调用中传递Promise new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); return new Promise((resolve) =\u0026gt; { resolve(\u0026#34;第一个then返回了一个Promise\u0026#34;); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 当注册的回调函数返回了一个 Promise 时，我们希望之后注册的回调队列能等待该 Promise 改变状态再执行，这又如何实现呢？在理解上文的基础上，我们理清一下思路：\n 按照之前的逻辑，第一个then方法将生成一个 Promise(代称 p1)，并且回调函数将返回一个 Promise 实例(代称 p2)。 如果 p2 的状态依旧为pending，则需要等待其状态改变，再执行 p1 相应的状态改变方法。  其实这部分内容在 Promise/A+规范：Promise 解决过程 一节中有详细的处理逻辑，这里引用一部分内容：\n Promise 解决过程是一个抽象的操作，其需输入一个promise和一个值，我们表示为[[Resolve]](promise, x)，如果x有then方法且看上去像一个 Promise ，解决程序即尝试使promise接受x的状态；否则其用x的值来执行promise。\n 更多详细的说明大家可以点击链接查看。\n在这里我们先简化问题，只考虑回调函数返回值为 Promise 这一种特殊情况，且不处理 rejected 状态。\n首先明白一个概念：在获得回调函数的返回值后，根据该返回值处理下一个 Promise 的过程称之为 Promise 解决过程。在该过程中，判断回调函数返回值为 Promise 时，调用该 Promise 的 then 方法，将此次解决过程注册为回调函数延迟执行。这一段有点绕，我们参考代码理解：\n// Promise解决过程 function resolvePromise(promise, x, resolve) { if (x instanceof Promise) { const then = x.then; then.call(x, (y) =\u0026gt; { resolvePromise(promise, y, resolve); }); return; } resolve(x); } // 链式Promise class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // _resolve方法用于改变Promise的状态为已解决，并执行回调队列[形式为(value) =\u0026gt; {}]  _resolve(value) { // 改变状态，保存值  this.state = \u0026#34;fulfilled\u0026#34;; this.value = value; // 依次执行回调队列  this.callbacks.forEach((fn) =\u0026gt; fn()); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 返回了新的 Promise 实例，这样可实现真正的链式调用  const nextPromise = new Promise((resolve) =\u0026gt; { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(() =\u0026gt; { // 必须异步执行，否则无法获取nextPromise对象  setTimeout(() =\u0026gt; { this._execCb(onFulfilled, nextPromise, resolve); }); }); return; } if (this.state === \u0026#34;fulfilled\u0026#34;) { // 必须异步执行，否则无法获取nextPromise对象  setTimeout(() =\u0026gt; { this._execCb(onFulfilled, nextPromise, resolve); }); return; } }); return nextPromise; } _execCb(cb, nextPromise, resolve) { const x = cb(this.value); resolvePromise(nextPromise, x, resolve); } } 这部分内容可能不易理解，请大家多动手多思考。这一节的完整代码可参考：Promise：链式调用实现。\n完整实现 上文已经将 Promise 的核心逻辑实现。在理解了这部分的基础上，参照规范将其余部分进行实现应该不难了。 剩下的工作主要在于添加 rejected 状态处理，以及考虑一些边界条件(例如当resolve传递了Promise实例本身导致链式调用进入死循环)。 完整的实现代码可以参考：Promise/A+完整实现。\n","permalink":"https://ruihusky.github.io/posts/2020-11-27_promise-aplus/","summary":"前言 Promise 对象用于表示一个异步操作的最终完成（或失败），及其结果值。它最早由社区提出和实现，其中有多种 Promise 规范。ES6 按照 Promise/A+ 规范将其写进了语言标准。 关于该规范的详情可参考：Promise/A+规范 中文翻译。\n基础实现 我们先尝试实现最简单的 Promise 功能：通过 Promise 包装异步请求，并使用then方法注册回调函数，通过resolve方法通知 Promise 异步请求已解决，并执行回调函数。 模拟一个基础的异步 http 请求，并使用 Promise 封装：\n// 模拟http请求 const mockAjax = (url, s, callback) =\u0026gt; { console.log(\u0026#34;[mockAjax] start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;[mockAjax] callback\u0026#34;); callback(\u0026#34;异步结果：\u0026#34; + url + \u0026#34;异步请求耗时\u0026#34; + s + \u0026#34;秒\u0026#34;); }, 1000 * s); }; // Promise基础功能 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.","title":"Promise实现原理（Promise/A+规范）"},{"content":"Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。\n运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：\nsetTimeout(function () { console.log(\u0026#34;Hello World\u0026#34;); }, 1); function foo() { // 提示: 最好不要尝试这样的迭代  for (var i = 0; i \u0026lt;= 1e10; i++) { console.log(i); } } foo(); // 0..1E10 // \u0026#34;Hello World\u0026#34; 在这个例子中，foo() 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 foo() 函数运行过程中，上面的 setTimeout() 函数不会被运行，直到 foo() 函数运行结束。\n运行-停止-运行 Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行。\n这里引申到 协程（coroutine） 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。\n在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 yield 关键字从内部将函数的运行打断。除了 Generator 函数内部的 yield 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。\n一旦 Generator 函数被中断，它不可能自行恢复运行，除非通过外部的控制来重新该函数。稍后会介绍如何做到这一点。\n更重要的一点是，Generator 函数的执行，允许信息的双向传递。普通函数在开始的时候获取参数，在结束的时候返回一个值，而 Generator 函数可以在每次 yield 的时候返回值，并且在下一次重新启动的时候再传入值。这样就能完美实现各线程之间的通信。\nGenerator 函数基本语法 看一个简单例子：\nfunction* helloWorldGenerator() { yield \u0026#34;hello\u0026#34;; yield \u0026#34;world\u0026#34;; return \u0026#34;ending\u0026#34;; } var hw = helloWorldGenerator(); 与普通函数相比，例子中多了一个 * 来进行标示，表示这是一个 Generator 函数。另外，函数体内有关键字 yield ，称作 yield 表达式。\n那么，yield 表达式的作用是什么？有两点：\n 每次函数中断时将 yield 表达式的结果输出。 重新启动函数时，传入的值会作为 yield 表达式计算的结果。  举例说明：\nfunction* foo() { var x = 1 + (yield \u0026#34;foo\u0026#34;); console.log(x); } 在 foo() 函数暂停时，yield \u0026quot;foo\u0026quot; 表达式会返回字符串\u0026quot;foo\u0026quot;，下一次 foo() 函数重新启动时，传入的值会代替 yield \u0026quot;foo\u0026quot; ，结果就是将 1 + 传入值 的结果赋值给 x。\nGenerator 函数运行控制 Generator 遍历器对象 执行 Generator 函数会返回一个遍历器对象，该遍历器对象可以依次遍历 Generator 函数内部的每一个状态。这听起来好像有点复杂，考虑下面这个简单的例子：\nfunction* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } // 返回了遍历器对象 var it = foo(); // 第一次通过next()调用，返回第一个yield的值 var message = it.next(); console.log(message); // { value:1, done:false } // 事实上每次调用next()方法都会返回一个object对象，其中的value属性就是yield表达式返回的值。 // 属性done是一个boolean类型，用来表示对Generator函数的遍历是否已经结束。 console.log(it.next()); // { value:2, done:false } console.log(it.next()); // { value:3, done:false } console.log(it.next()); // { value:4, done:false } console.log(it.next()); // { value:5, done:false } // 这里注意到，执行到yield 5时，done属性依然是false。 // 这是因为从技术上来说，Generator函数还没有执行完。 // 我们必须再调用一次next()方法，然后Generator函数才算执行完毕。 // 注意到最后一次的value是return语句的返回值。 console.log(it.next()); // { value:6, done:true } 仔细看完上面的例子，相信已经可以理解 Generator 函数运行控制的基本概念了。这里还没有涉及到值的传入，给一个稍微复杂的例子：\nfunction* foo(x) { var y = 2 * (yield x + 1); var z = yield y / 3; return x + y + z; } var it = foo(5); // 注意这里在调用next()方法时没有传入任何值 console.log(it.next()); // { value:6, done:false } console.log(it.next(12)); // { value:8, done:false } console.log(it.next(13)); // { value:42, done:true } 这里解释一下上面的例子中发生了什么：\n 构造 Generator 函数遍历器的时候，通过语句 foo(5)，我们将参数 x 的值设置为 5。 第一次调用 next()方法时，没有传入任何值。因为此时没有 yield 表达式来接收我们传入的值。如果在第一次调用 next()方法时传入一个值，也不会有任何影响，该值会被抛弃掉。按照 ES6 标准的规定，此时 Generator 函数会直接忽略掉该值。 表达式 yield(x + 1) 的返回值是 6，然后第二个 next(12) 将 12 作为参数传入，用来代替表达式 yield(x + 1) ，因此变量 y 的值就是 12 * 2 = 24。随后的 yield(y / 3)（即 yield(24 / 3) ）返回值 8。然后第三个 next(13) 将 13 作为参数传入，用来代替表达式 yield(y / 3) ，所以变量 z 的值是 13。 最后，语句 return (x + y + z) 即 return (5 + 24 + 13) ，所以最终的返回值是 42。  for\u0026hellip;of 循环 ES6 从语法层面上对遍历器提供了直接的支持，即 for\u0026hellip;of 循环。因此 Generator 函数遍历器也可以使用下面的方式进行循环控制：\nfunction* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (var v of foo()) { console.log(v); } // 1 2 3 4 5  console.log(v); // 仍然是5，而不是6 注意到，for\u0026hellip;of 循环忽略并抛弃了返回值 6，这是因为此处没有对应的 next() 方法被调用，另外，for\u0026hellip;of 循环不支持将值传递到 Generator 函数内。\nGenerator 函数错误处理 ES6 Generators 函数内部的代码是同步的，即使在 Generator 函数外部控制是异步进行的。也就是说，你可以使用任何你所熟悉的错误处理机制来简单地在 Generator 函数中处理错误，例如使用 try/catch 机制。 来看一个例子：\nfunction* foo() { try { var x = yield 3; console.log(\u0026#34;x: \u0026#34; + x); } catch (err) { console.log(\u0026#34;Error: \u0026#34; + err); } } var it = foo(); var res = it.next(); // { value:3, done:false }  // 这里我们不调用next()方法，而直接抛出一个异常： it.throw(\u0026#34;Oops!\u0026#34;); // Error: Oops! 这里我们使用了另一个方法 throw()，它会在 Generator 函数暂停的位置抛出一个错误，然后函数内部的 try/catch 语句捕获了这个错误。\n如果函数内部没有 try/catch 语句，会发生什么？错误因为没有被任何代码捕获，会被当作一个未处理的异常向上抛出。\nfunction* foo() {} var it = foo(); try { it.throw(\u0026#34;Oops!\u0026#34;); } catch (err) { console.log(\u0026#34;Error: \u0026#34; + err); // Error: Oops! } 很显然，如果在 Generator 函数内部发生的错误没有被捕获，也会被向上抛出。\nfunction* foo() { var x = yield 3; var y = x.toUpperCase(); // 可能会引发类型错误！  yield y; } var it = foo(); it.next(); // { value:3, done:false }  try { it.next(42); // 42没有toUpperCase()方法 } catch (err) { console.log(err); // toUpperCase()引发TypeError错误 } Generator 函数委托 在一个 Generator 函数体内，可以调用另一个 Generator 函数，实际上是将当前 Generator 函数的迭代控制 委托 给另一个 Generator 函数。我们通过关键字 yield * 来实现。看下面的代码：\nfunction* foo() { yield 3; yield 4; } function* bar() { yield 1; yield 2; yield* foo(); // `yield *` 将当前函数的迭代控制委托给另一个Generator函数foo()  yield 5; } for (var v of bar()) { console.log(v); } // 1 2 3 4 5 在关键字 yield * 的位置，程序将迭代控制委托给另一个 Generator 函数 foo()，随后 for...of 循环将通过 next() 方法遍历 foo()。当对 foo() 的遍历结束后，委托控制又重新回到之前的 Generator 函数。\n不使用 for...of 循环，通过 next() 方法控制并传入相应的值来进行遍历，这些传入的值也会通过 yield * 关键字传递给对应的 yield 表达式中。另外，yield * 表达式可以接收被委托的 Generator 函数的返回值。\nfunction* foo() { var z = yield 3; var w = yield 4; console.log(\u0026#34;z: \u0026#34; + z + \u0026#34;, w: \u0026#34; + w); return \u0026#34;foo\u0026#34;; } function* bar() { var x = yield 1; var y = yield 2; var f = yield* foo(); // `yield*` 将控制权委托给 `foo()`，并且接受了字符串`foo`  console.log(\u0026#34;f: \u0026#34; + f); var v = yield 5; console.log(\u0026#34;x: \u0026#34; + x + \u0026#34;, y: \u0026#34; + y + \u0026#34;, v: \u0026#34; + v); } var it = bar(); it.next(); // { value:1, done:false } it.next(\u0026#34;X\u0026#34;); // { value:2, done:false } it.next(\u0026#34;Y\u0026#34;); // { value:3, done:false } it.next(\u0026#34;Z\u0026#34;); // { value:4, done:false } it.next(\u0026#34;W\u0026#34;); // { value:5, done:false },f=\u0026#34;foo\u0026#34; // z: Z, w: W // f: foo it.next(\u0026#34;V\u0026#34;); // { value:undefined, done:true } // x: X, y: Y, v: V 对于yield * 表达式中的错误传递，道理也很简单：在被委托函数内的错误如果未被捕获，就会抛出到委托函数中。若在委托函数中仍未被处理，就会继续向上抛出。\nfunction* foo() { try { yield 2; } catch (err) { console.log(\u0026#34;foo caught: \u0026#34; + err); } yield; // 暂停  // 抛出一个错误  throw \u0026#34;Oops!\u0026#34;; } function* bar() { yield 1; try { yield* foo(); } catch (err) { console.log(\u0026#34;bar caught: \u0026#34; + err); } } var it = bar(); it.next(); // { value:1, done:false } it.next(); // { value:2, done:false }  it.throw(\u0026#34;Uh oh!\u0026#34;); // 将会被foo()中的try..catch捕获 // foo caught: Uh oh!  it.next(); // { value:undefined, done:true } --\u0026gt; 注意这里不会出现错误！ // bar caught: Oops! Generator 函数的异步应用 前文所述所有对 Generator 函数的控制都是同步执行的，现在来看看如何利用 Generator 函数开发异步应用。\nGenerator 与 Promise 的结合 从这里开始理解起来会稍有困难，我的建议是自己动手去运行一下这些实例，有助于加快理解。最新的 Node.js 环境已经支持所有示例。\n设想一下：yield 表达式返回了一个 Promise 对象。之后我们可以做些什么动作？我们可以通过 Promise 对象的状态（resolved/rejected）来对 Generator 函数的流程进行控制。\n先从一个简单一点的例子说起：\nfunction request(num) { // 注意：返回的是一个Promise对象  return new Promise(function (resolve, reject) { setTimeout(function () { num += 1; // 返回新num值  console.log(\u0026#34;Promise resolved.\u0026#34;); resolve(num); }, 1000); }); } function* main() { var ret1 = yield request(0); var ret2 = yield request(ret1); console.log(\u0026#34;Number: \u0026#34; + ret2); } var it = main(); var step1 = it.next(); console.log(step1); step1.value.then(function (num) { step2 = it.next(num); console.log(step2); step2.value.then(function (num2) { it.next(num2); }); }); // 结果： // { value: Promise { \u0026lt;pending\u0026gt; }, done: false } // Promise resolved. // { value: Promise { \u0026lt;pending\u0026gt; }, done: false } // Promise resolved. // Number: 2 这个例子还比较好理解：每次调用 it.next() 都会 立即 返回一个 Promise 对象，但是该对象内部的状态为 pending ，因此之后调用该 Promise 对象的 then() 方法等待对象状态改变。这里有一点很关键，在 Promise 对象中， resolve() 方法传出的值，会被 then() 方法参数中的函数接受，随后再传入到 it.next() 中。\n但是仔细看看，控制 Generator 函数的流程依旧是层层嵌套的，有没有办法解决这个问题？上例中，嵌套控制的部分每一层的结构基本是一致的，因此我们可以用递归函数实现它：\n// Generator函数自动执行器 function runGenerator(generator) { // 取得Generator遍历器  var it = generator(); var retVal; // 异步迭代该遍历器  (function iterate(val) { retVal = it.next(val); console.log(retVal); // 当迭代未完成，就继续执行  if (!retVal.done) { if (\u0026#34;then\u0026#34; in retVal.value) { // 等待Promise对象状态改变，随后递归调用自身，重新迭代。同时Promise传出的值传入到函数iterate中  retVal.value.then(iterate); } else { // 非Promise对象，立即执行下一步迭代  // 避免同步递归调用  setTimeout(function () { iterate(retVal.value); }, 0); } } })(); } runGenerator(main); // 结果： // { value: Promise { \u0026lt;pending\u0026gt; }, done: false } // Promise resolved. // { value: Promise { \u0026lt;pending\u0026gt; }, done: false } // Promise resolved. // Number: 2 // { value: undefined, done: true } runGenerator() 函数传入一个 Generator 函数作为参数并取得它的遍历器，随后在 iterate() 函数中进行迭代。如果 yield 表达式返回了一个 Promise 对象，就等待其执行完毕再递归迭代，否则立即执行下一步迭代。注意到在 else 语句中使用了一个 setTimeout() 语句，在这里我们不能立即执行 it.next() 函数，否则会报错。因为当前线程仍在 Generator 函数中（yield 表达式没有计算完毕），Generator 函数不在暂停状态。而 setTimeout() 语句会在该线程执行完毕后立即执行。\n当然，在 yield 表达式中，完全可以不用返回 Promise 对象，而是自行编写异步代码，但是使用 Promise 来管理 Generator 函数中异步调用部分的代码，有许许多多的优势：\n Promise 拥有内置的错误处理机制。在上面的例子中没有展现出来，这并不难做到：Promise 监听到错误后状态变为 rejected，随后可以在 runGenerator() 函数中使用 try/catch 处理，或者使用 it.throw() 将错误抛出。 我们通过 Promise 强大的 API 来控制所有的流程。 可以利用 Promise 处理各种复杂的“并行”任务。例如，使用 yield Promise.all([...]) 或者 yield Promise.race([...]) 接收一个“并行”任务的 Promise，随后就可以根据该 Promise 进行流程控制。  我们把上面的例子稍作改动，看看 yield Promise.all([...]) 如何使用：\nfunction request(num) { // 注意：返回的是一个Promise对象  return new Promise(function (resolve, reject) { setTimeout(function () { num += 1; // 返回新num值  console.log(\u0026#34;Promise resolved, num = \u0026#34; + num); resolve(num); }, 1000 + num); }); } function* main() { var ret1 = yield Promise.all([request(100), request(300), request(200)]); var ret2 = yield request(ret1[0] + ret1[1] + ret1[2]); console.log(\u0026#34;Number: \u0026#34; + ret2); } // Generator函数自动执行器 function runGenerator(generator) { // ...code  // 与上文一致 } runGenerator(main); // 结果： // { value: Promise { \u0026lt;pending\u0026gt; }, done: false } // Promise resolved, num = 101 // Promise resolved, num = 201 // Promise resolved, num = 301 // { value: Promise { \u0026lt;pending\u0026gt; }, done: false } // Promise resolved, num = 604 // Number: 604 // { value: undefined, done: true } 注意以下两点：\n 第一个 yield 表达式传入了 Promise.all(...]) ，立即返回一个新的 Promise 对象，该对象的状态根据传入的三个 Promise 对象决定，不懂的话可以参考我的上一篇博客。 我把 request() 方法中的 setTimeout() 时间参数改为 1000 + num ，这样可以从结果清晰的看出三个 Promise 对象中的异步任务是并发执行的。  async 函数 使用 Generator 函数进行异步开发时，需要有一个 Generator 函数自动执行器来实现上面介绍的 Generator+Promise 模式。目前网上有许多开源库提供了这样的工具，例如 co 模块 。\nES2017 标准引入了 async 函数，其中最重要的一点是 async 函数内置 Generator 函数自动执行器。也就是说，它可以自动地执行 Promise（或者异步函数）并在它们执行完后恢复运行。\nasync 函数基本用法 我们将上文的例子改成使用 async 函数来实现：\nfunction request(num) { // 注意：返回的是一个Promise对象  return new Promise(function (resolve, reject) { setTimeout(function () { num += 1; // 返回新num值  console.log(\u0026#34;Promise resolved, num = \u0026#34; + num); resolve(num); }, 1000 + num); }); } async function main() { var ret1 = await Promise.all([request(100), request(300), request(200)]); var ret2 = await request(ret1[0] + ret1[1] + ret1[2]); console.log(\u0026#34;Number: \u0026#34; + ret2); } main(); // 结果： // Promise resolved, num = 101 // Promise resolved, num = 201 // Promise resolved, num = 301 // Promise resolved, num = 604 // Number: 604 从语法上看，async 函数与 Generator 函数的区别只有两点：\n * 标识符换成了 async 关键字，表示这是一个 async 函数。 yield 关键字换成了 await 关键字，它会告诉 async 函数需要在这里等待 Promise 完成之后继续运行。  其实，async 函数完全可以看作多个异步操作所包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。\n总结 Generator 函数与 Promise 对象结合起来的模式功能已经足够强大，可以利用它们自如的控制同步、异步流程。并且现在许多开源库提供了 Generator 函数自动执行器，其中还包含了错误处理机制，我们可以很方便的进行运用。\nasync 函数已经在 ES2017 标准中加入，未来将会成为（也许现在已经是）JavaScript 异步控制的主流方案。\n","permalink":"https://ruihusky.github.io/posts/2020-11-18_js-async-function/","summary":"Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。\n运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：\nsetTimeout(function () { console.log(\u0026#34;Hello World\u0026#34;); }, 1); function foo() { // 提示: 最好不要尝试这样的迭代  for (var i = 0; i \u0026lt;= 1e10; i++) { console.log(i); } } foo(); // 0..1E10 // \u0026#34;Hello World\u0026#34; 在这个例子中，foo() 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 foo() 函数运行过程中，上面的 setTimeout() 函数不会被运行，直到 foo() 函数运行结束。\n运行-停止-运行 Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行。\n这里引申到 协程（coroutine） 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。\n在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 yield 关键字从内部将函数的运行打断。除了 Generator 函数内部的 yield 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。","title":"JavaScript异步编程：Generator函数与Async函数"},{"content":"JavaScript 异步编程背景 JavaScript 是一门单线程语言。所谓单线程，就是同一时刻只能进行一个任务，所有任务排着队按照先后顺序进行。若某个任务耗时很长，进程就会出现卡死的状态。例如使用同步方式加载某个页面，有一个资源需要加载很长时间，那这段时间用户无法对页面做任何操作。因此对于 JavaScript 来说，异步编程异常重要。\nJavascript 异步编程方法 按照时间先后顺序，Javascript 的异步编程方案有这些：\nES6 以前：回调函数、Promise 对象 ES6：Generator 函数 ES7：async 函数\n回调函数 举一个通俗易懂的例子来说明什么是回调函数：\n某个顾客到书店买书，但是书店缺货，于是他向店员留下了电话号码。过了几天后，书店进了货，店员打了这个电话通知顾客货到了。于是顾客来到书店取了货。\n在这个例子中，“顾客买书”可以看作一个任务。但是这个任务不能在最开始执行，必须在“书店有货”这个条件成立时才能执行。于是顾客在书店留下电话号码，也就是向店员登记回调函数。对于书店来说，他在“书店到货”这个事件发生时，就可以通过电话号码“调用”“顾客买书”的任务，这里是调用回调函数。顾客去书店买了书，这里是“响应回调事件”。\n那么，回调函数和异步有什么关系呢？在上面的例子中，顾客告知店员电话号码之后，就可以离开书店做其他事情，不必一直在书店等到书到货。这里就是异步思想的体现。\n在 JS 中，最简单的例子就是定时任务 - setTimeout()\nfunction test() { setTimeout(function () { console.log(\u0026#34;from setTimeout\u0026#34;); }, 500); console.log(\u0026#34;from test\u0026#34;); } test(); // 结果： // from test // from setTimeout 可以看到，在 test() 中，setTimeout() 之后的代码立刻执行了，没有等待 500ms 之后再执行。\n现在假设这样一个业务场景：需要有序读取多个文件并输出。这是嵌套回调的常见模式，看下面的例子：\n// 嵌套回调，读一个文件后输出，再读另一个文件。读取第二个文件的代码需要写在第一个回调函数之中 var fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#34;./text1.txt\u0026#34;, \u0026#34;utf8\u0026#34;, function (err, data) { console.log(\u0026#34;text1 file content: \u0026#34; + data); fs.readFile(\u0026#34;./text2.txt\u0026#34;, \u0026#34;utf8\u0026#34;, function (err, data) { console.log(\u0026#34;text2 file content: \u0026#34; + data); }); }); 这里是一个两层嵌套回调，看起来没有什么问题。但是假如嵌套数量多起来，代码就不怎么美观了：\n// 回调地狱(callback hell) doSomethingAsync1(function () { doSomethingAsync2(function () { doSomethingAsync3(function () { doSomethingAsync4(function () { doSomethingAsync5(function () { // code...  }); }); }); }); }); 这样的代码从逻辑上说没有什么问题，但是随着业务逻辑的增加和趋于复杂，后期维护、更改的时候简直是地狱一般，这就是“回调地狱(callback hell)”。\n回调函数的另外一个问题是回调函数之外无法捕获到回调函数中的异常，先看一个例子：\nvar fs = require(\u0026#34;fs\u0026#34;); try { // 尝试读取一个不存在的文件  fs.readFile(\u0026#34;not_exist_file\u0026#34;, \u0026#34;utf8\u0026#34;, function (err, data) { console.log(data); // 输出undefined  }); } catch (e) { console.log(\u0026#34;error caught: \u0026#34; + e); // 未捕获错误，无输出 } 原因在于，try/catch 语句只能捕获当次事件循环的异常，而异步调用一般以传入 callback 的方式来指定异步操作完成后要执行的动作。而异步调用本体和 callback 属于不同的事件循环。\nPromise 对象 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。\n所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\nPromise 基本用法 // ES6原生Promise示例 - 生成Promise对象 var promise = new Promise(function(resolve, reject) { // ... some code  if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\nresolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\nPromise 实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Rejected 状态的回调函数。\n// ES6原生Promise示例 - 指定Promise回调函数 promise.then( function (value) { // success  }, function (error) { // failure  } ); then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。\nthen 方法是定义在原型对象 Promise.prototype 上的，它返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。\n// 原生Primose顺序嵌套回调示例 var fs = require(\u0026#34;fs\u0026#34;); var read = function (filename) { var promise = new Promise(function (resolve, reject) { fs.readFile(filename, \u0026#34;utf8\u0026#34;, function (err, data) { if (err) { reject(err); } resolve(data); }); }); return promise; }; read(\u0026#34;./text1.txt\u0026#34;) .then(function (data) { console.log(data); return read(\u0026#34;./text2.txt\u0026#34;); }) .then(function (data) { console.log(data); }); 上面的代码中，第一个 then 方法输出 text1.txt 的内容后返回 read('./text2.txt') ，注意这里很关键，这里实际上返回了一个新的 Promise 实例，第二个 then 方法的回调函数需要等待 read('./text2.txt') 所返回的 Promise 对象状态改变才会被调用。\nPromise 异常处理 Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。\nvar fs = require(\u0026#34;fs\u0026#34;); var read = function (filename) { var promise = new Promise(function (resolve, reject) { fs.readFile(filename, \u0026#34;utf8\u0026#34;, function (err, data) { if (err) { reject(err); } resolve(data); }); }); return promise; }; read(\u0026#34;./text1.txt\u0026#34;) .then(function (data) { console.log(data); return read(\u0026#34;not_exist_file\u0026#34;); }) .then(function (data) { console.log(data); }) // 捕获read(\u0026#39;not_exist_file\u0026#39;)中发生的异常  .catch(function (err) { console.log(\u0026#34;error caught: \u0026#34; + err); //假如在catch中抛出异常，不会被捕获，也不会传递到外层  x + 1; }) // 捕获上一个catch中抛出的异常  .catch(function (err) { console.log(\u0026#34;error caught: \u0026#34; + err); }) .then(function (data) { console.log(\u0026#34;completed\u0026#34;); }); 使用 Promise 对象的 catch 方法可以捕获异步调用链中 callback 的异常，该方法返回的也是一个 Promise 对象，因此，在 catch 方法后还可以继续写异步调用方法。这是一个非常强大的能力。\nPromise 异步并发 如果几个异步调用有关联，但它们不是顺序式的，是可以同时进行的，我们很直观地会希望它们能够并发执行。\nPromise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。其中的每个 Promise 对象的操作可以同时进行。\nvar p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况。\n（1）只有p1、p2、p3的状态都变成 fulfilled，p的状态才会变成 fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n（2）只要p1、p2、p3之中有一个被 rejected，p的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。\nvar fs = require(\u0026#34;fs\u0026#34;); var read = function (filename) { var promise = new Promise(function (resolve, reject) { fs.readFile(filename, \u0026#34;utf8\u0026#34;, function (err, data) { if (err) { reject(err); } resolve(data); }); }); return promise; }; var promises = [1, 2].map(function (fileno) { return read(\u0026#34;./text\u0026#34; + fileno + \u0026#34;.txt\u0026#34;); }); Promise.all(promises) .then(function (contents) { console.log(contents); // 结果：  // [ text1Content, text2Content ]  }) .catch(function (err) { console.log(\u0026#34;error caught: \u0026#34; + err); }); 上述代码会并发执行读取 text1.txt 和 text2.txt 的操作，当两个文件都读取完毕时，输出它们的内容，contents 是一个数组，对应 promises 数组中各实例的返回结果，在这里就是 text1.txt 和 text2.txt 的内容。\nPromise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\nvar p = Promise.race([p1, p2, p3]); 对于p，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。这里就不写例子了，可以参考上文自行思索。\n总结 Promise 在形式上避免了回调的嵌套写法，代码可读性更好，异常处理也比较方便，但是本质上依然是把异步串接起来。\n相对来说，ES6 出现的 Generator 函数是一种“类协程”的实现，功能相比 Promise 更加强大，理解起来也困难一点。具体的介绍在后续文章中给出。\n","permalink":"https://ruihusky.github.io/posts/2020-11-16_js-promise/","summary":"JavaScript 异步编程背景 JavaScript 是一门单线程语言。所谓单线程，就是同一时刻只能进行一个任务，所有任务排着队按照先后顺序进行。若某个任务耗时很长，进程就会出现卡死的状态。例如使用同步方式加载某个页面，有一个资源需要加载很长时间，那这段时间用户无法对页面做任何操作。因此对于 JavaScript 来说，异步编程异常重要。\nJavascript 异步编程方法 按照时间先后顺序，Javascript 的异步编程方案有这些：\nES6 以前：回调函数、Promise 对象 ES6：Generator 函数 ES7：async 函数\n回调函数 举一个通俗易懂的例子来说明什么是回调函数：\n某个顾客到书店买书，但是书店缺货，于是他向店员留下了电话号码。过了几天后，书店进了货，店员打了这个电话通知顾客货到了。于是顾客来到书店取了货。\n在这个例子中，“顾客买书”可以看作一个任务。但是这个任务不能在最开始执行，必须在“书店有货”这个条件成立时才能执行。于是顾客在书店留下电话号码，也就是向店员登记回调函数。对于书店来说，他在“书店到货”这个事件发生时，就可以通过电话号码“调用”“顾客买书”的任务，这里是调用回调函数。顾客去书店买了书，这里是“响应回调事件”。\n那么，回调函数和异步有什么关系呢？在上面的例子中，顾客告知店员电话号码之后，就可以离开书店做其他事情，不必一直在书店等到书到货。这里就是异步思想的体现。\n在 JS 中，最简单的例子就是定时任务 - setTimeout()\nfunction test() { setTimeout(function () { console.log(\u0026#34;from setTimeout\u0026#34;); }, 500); console.log(\u0026#34;from test\u0026#34;); } test(); // 结果： // from test // from setTimeout 可以看到，在 test() 中，setTimeout() 之后的代码立刻执行了，没有等待 500ms 之后再执行。\n现在假设这样一个业务场景：需要有序读取多个文件并输出。这是嵌套回调的常见模式，看下面的例子：\n// 嵌套回调，读一个文件后输出，再读另一个文件。读取第二个文件的代码需要写在第一个回调函数之中 var fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#34;./text1.txt\u0026#34;, \u0026#34;utf8\u0026#34;, function (err, data) { console.log(\u0026#34;text1 file content: \u0026#34; + data); fs.","title":"JavaScript异步编程：回调函数与Promise"},{"content":"理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); person1.sayName(); // \u0026#34;Nicholas\u0026#34; var person2 = new Person(); person2.sayName(); // \u0026#34;Nicholas\u0026#34; alert(person1.sayName == person2.sayName); // true 原型搜索机制 访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 delete 删除实例对象属性即可。下面是例子：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.name = \u0026#34;Greg\u0026#34;; alert(person1.name); // \u0026#34;Greg\u0026#34;--来自实例 alert(person2.name); // \u0026#34;Nicholas\u0026#34;--来自原型  delete person1.name; alert(person1.name); // \u0026#34;Nicholas\u0026#34;--来自原型 继承 ECMAScript 中描述了 原型链 的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。实现原型链的一种基本模式是让 原型对象等于另一个类型的实例。这么说比较抽象，先看一段代码：\nfunction SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function () { return this.property; }; function SubType() { this.subProperty = false; } // 继承了SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subProperty; }; var instance = new SubType(); alert(instance.getSuperValue()); // true 以上代码定义了 SuperType、SubType 两个类型，他们分别有自己的属性和方法。通过重写 Subtype 的原型对象（让其等于 SuperType 的实例），可以让存在于 SuperType 实例中的所有属性和方法在 SubType.prototype 访问到。\n结合上文的原型搜索机制来理解：访问一个实例属性时，首先在实例中搜索该属性。如果没有找到则会继续搜索该实例的原型。通过原型链实现继承后，搜索过程就会沿着原型链继续向上。拿上面的例子来说，调用 instance.getSuperValue() 的过程如下：\n搜索实例 \u0026ndash;\u0026gt; 搜索SubType.prototype\u0026ndash;\u0026gt; 搜索SuperType.prototype\n另外，所有的默认原型都是 Object 的实例。因此可以这么概括：SubType 继承自 SuperType ，SuperType 继承自 Object。\n原型链的问题 使用原型链实现继承，最主要的问题是包含引用类型值的原型。举例来说：\nfunction SuperType() { this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } function SubType() {} // 继承了SuperType SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.colors.push(\u0026#34;black\u0026#34;); alert(instance1.colors); // \u0026#34;red,blue,green,black\u0026#34;  var instance2 = new SubType(); alert(instance2.colors); // \u0026#34;red,blue,green,black\u0026#34; 可以看到，对 instance1.colors 所做的修改，会在 instance2 反映出来。\n原型链的第二个问题是：创建子类实例时，无法向超类的构造函数传递参数。\n为了解决这些问题，通常会使用下面这些技术来实现继承。\n组合继承 通过将原型链和借用构造函数技术相结合达到目的。使用原型链实现对原型属性、方法的继承，通过借用构造函数实现对实例属性的继承。\nfunction SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function () { alert(this.name); }; function SubType(name, age) { // 继承属性，通过call()函数在实例内部创建属性  SuperType.call(this, name); this.age = age; } // 继承方法，来自子类原型对象的原型对象-也就是超类原型对象 SubType.prototype = new SuperType(); // 默认情况下，所有原型对象会自动获得一个constructor（构造函数）属性，指向原型对象所在函数。 // 覆写的prototype对象没有constructor属性，需要重新指定。 SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function () { alert(this.age); }; var instance1 = new SubType(\u0026#34;Nicholas\u0026#34;, 29); instance1.colors.push(\u0026#34;black\u0026#34;); alert(instance1.colors); // \u0026#34;red,blue,green,black\u0026#34; instance1.sayName(); // \u0026#34;Nicholas\u0026#34;; instance1.sayAge(); // 29  var instance2 = new SubType(\u0026#34;Greg\u0026#34;, 27); alert(instance2.colors); // \u0026#34;red,blue,green\u0026#34; instance2.sayName(); // \u0026#34;Greg\u0026#34;; instance2.sayAge(); // 27 在这个例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 超类实例直接赋值给子类原型，Subtype.prototype 也有 name、colors 属性。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  这种继承方式是 JavaScript 中最为常见的继承模式。并且 instanceof 和 isPrototypeOf() 也能够用于识别子类实例。但是可以看到，子类的原型有多余的属性。接下来的继承方式则解决了这个问题。\n寄生组合式继承 这里可能稍微有些复杂，先看其基本模式：\n// 这里是原型式继承-通过该函数，将实例的原型指定为对象o，从而拥有o的属性。 function object(o) { function F() {} F.prototype = o; return new F(); } // 寄生组合式继承基本模式 // 接受两个参数：子类构造函数、超类构造函数 function inheritPrototype(subType, superType) { // 创建prototype对象，目的是准备把它当成子类的原型。同时该prototype对象的原型是超类原型。  var prototype = object(superType.prototype); //创建对象  // 覆写的prototype对象没有constructor属性，需要重新指定。  prototype.constructor = subType; // 将prototype对象赋值给子类原型  subType.prototype = prototype; } 基本想法就是自行创建子类的原型对象，同时将该原型对象的原型指向超类原型。这样一来子类只继承了超类的原型，而与超类实例无关。 下面看一个更加具体的例子加深理解：\nfunction SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function () { alert(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function () { alert(this.age); }; 在上面的例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  与上述组合继承方式相比，这种继承方式避免了在 SubType.prototype 上创建多余的属性，同时保持了原型链不变。\n","permalink":"https://ruihusky.github.io/posts/2020-11-12_js-prototype/","summary":"理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); person1.sayName(); // \u0026#34;Nicholas\u0026#34; var person2 = new Person(); person2.sayName(); // \u0026#34;Nicholas\u0026#34; alert(person1.sayName == person2.sayName); // true 原型搜索机制 访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 delete 删除实例对象属性即可。下面是例子：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.","title":"JavaScript原型与继承"},{"content":"","permalink":"https://ruihusky.github.io/archives/","summary":"","title":"Archives"},{"content":"","permalink":"https://ruihusky.github.io/search/","summary":"","title":"Search"}]