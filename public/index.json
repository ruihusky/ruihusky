[{"content":"概览与术语 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法，最常用到的排序方式之一就是数值顺序。\n排序算法依照稳定性可分为稳定算法和不稳定算法。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，则在排序过的列表中 R 也将会是在 S 之前。\n排序算法依照排序过程中占用空间的方式分为 In-place 算法 与 Out-place 算法。In-place 是原地算法，基本上不需要额外的辅助空间，可允许固定数量的辅助变量。非原地算法就是 Out-place，其开辟的辅助空间与问题规模相关。例如，冒泡排序只需要数据在原序列中交换位置，不需要额外的辅助空间，是 In-place 算法。\n不同的排序算法会有不同的时间复杂度（最差、平均、和最好性能），下表列出了十种经典排序算法的概览：\n冒泡排序（Bubble Sort） 一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为：越的元素会经由交换慢慢“浮”到数列的顶端。\n冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。\n算法描述\n 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到没有任何一对数字需要比较； 可选的优化步骤：某次步骤 1~3 执行过程中没有元素发生交换，则证明该序列已经有序，不需要再进行下一次序列遍历。  动图演示\n代码实现\n// TypeScript实现 export function bubbleSort(arr: number[]) { const len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { let sorted = true; for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { sorted = false; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } if (sorted) break; } return arr; } 算法分析\n冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。\n最好时间复杂度：O(n)，当数据已经有序时\n最坏时间复杂度：O(n2)，当数据完全反序时\n平均时间复杂度：O(n2)\n空间复杂度：O(1)\n稳定性：稳定\n选择排序（Selection Sort） 选择排序是一种简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。\n算法描述\n 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置； 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾； 重复步骤 2，直到所有元素排序完毕。  动图演示\n代码实现\n// TypeScript实现 export function selectionSort(arr: number[]) { const len = arr.length; let minIndex: number; for (let i = 0; i \u0026lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j \u0026lt; len; j++) { if (arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } if (minIndex !== i) { [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } } return arr; } 算法分析\n选择排序的比较次数与关键字的初始状态无关，总的比较次数 N=(n-1)+(n-2)+\u0026hellip;+1=n*(n-1)/2。交换次数 O(n)，最好情况是，已经有序，交换 0 次；最坏情况是，逆序，交换 n-1 次。交换次数比冒泡排序较少，由于交换所需 CPU 时间比比较所需的 CPU 时间多，n 值较小时，选择排序比冒泡排序快。\n原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。\n最好时间复杂度：O(n2)\n最坏时间复杂度：O(n2)\n平均时间复杂度：O(n2)\n空间复杂度：O(1)\n稳定性：不稳定。最小（大）元素与已排序序列末尾之后一位元素进行交换时，末尾之后一位的元素与其他非最小（大）元素的相对位置发生了变化。\n插入排序（Insertion Sort） 插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用原地排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n算法描述\n 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5，直到所有元素排序完毕。  动图演示\n代码实现\n// TypeScript实现 export function insertionSort(arr: number[]) { const len = arr.length; let j: number; let temp: number; for (let i = 1; i \u0026lt; len; i++) { temp = arr[i]; j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = temp; } return arr; } 算法分析\n如果目标是把 n 个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 n-1 次即可。最坏情况是，序列是降序排列，那么此时需要进行的比较共有 1 + 2 + \u0026hellip; + (n - 1) = n*(n-1)/2 次。平均来说插入排序算法复杂度为 O(n2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。\n最好时间复杂度：O(n)\n最坏时间复杂度：O(n2)\n平均时间复杂度：O(n2)\n空间复杂度：O(1)\n稳定性：稳定\n希尔排序（Shell Sort） 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。该算法时按其设计者希尔（Donald Shell）的名字命名的，由 1959 年公布。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位  希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。\n为了更好的理解希尔排序是什么，用一个实际的例子来进行说明：\n现在我们要对数组 [13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10] 进行希尔排序，第一次我们将步长定为 5，那么我们将数组排列成一个表，每行的数量是 5：\n13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 每一轮希尔排序的过程就是对上表中的每列进行插入排序，排序后结果为：\n10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 请注意，将数组排列成表只是为了让我们更好的理解希尔排序（逻辑分组），真正的排序过程并不会这样做。我们将这四行拼起来就是第一轮希尔排序完成后数组的状态：[10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45]。第二次，我们将步长减小，定为 3：\n10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 再对每列进行一轮插入排序，结果为：\n10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94 此时，数组已经大致有序了，此时对其进行插入排序效率较高。于是我们以步长 1 再进行希尔排序（其实就是插入排序），完成整个排序过程。\n希尔排序的步长序列\n步长的选择是希尔排序的重要部分，对希尔排序的效率有很大的影响。只要最终步长为 1 任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为普通插入排序，这就保证了数据一定会被排序。\nDonald Shell 最初建议步长选择为 n/2 并且每次对步长取半直到步长达到 1。虽然这样取可以比 O(n2)类的算法（插入排序）更好，但还是有优化平均时间复杂度和最差时间复杂度的余地。下表列出了三种步长序列及其相应的最坏情况时间复杂度：\n   步长序列 最坏情况时间复杂度     n/2i O(n2)   2k-1 O(n3/2)   2i3j O(nlog2n)    已知的最好步长序列是由 Sedgewick 提出的(1, 5, 19, 41, 109,\u0026hellip;)，该序列的项来自 9 * 4i - 9 * 2i + 1 和 2i+2 * (2i+2 - 3) + 1 这两个算式。用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。\n算法描述\n 确定好步长序列 t1, t2, \u0026hellip;, tk，最终步长 tk 应为 1； 对于某一步长 t，进行如下排序过程：将所有元素按照步长划分为 m 组。例如：[ a[0] , a[0 + t], a[0 + 2t], ... ]为一组，[ a[1], a[1 + t], a[1 + 2t], ... ]为一组。然后对每组单独进行插入排序； 根据步长序列，重复步骤 2，直到完成整个排序过程。  动图演示\n代码实现\n// TypeScript实现 export function shellSort(arr: number[]) { const len = arr.length; // 步长序列 n / 2^i  for (let gap = len \u0026gt;\u0026gt; 1; gap \u0026gt; 0; gap \u0026gt;\u0026gt;= 1) { // 执行插入排序  // i = 0 默认已排序，所以从 0 + gap 的位置开始执行插入  for (let i = gap; i \u0026lt; len; i++) { const temp = arr[i]; let j = i - gap; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp) { arr[j + gap] = arr[j]; j -= gap; } arr[j + gap] = temp; } } return arr; } 算法分析\n希尔排序是插入排序的改进版，其复杂度受所选步长序列影响。相关分析可见上文。\n空间复杂度：O(1)\n稳定性：不稳定。对单独的分组进行插入排序时，该组元素与其他分组元素的相对位置发生了变化。\n归并排序（Merge Sort） 归并排序，是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，有两种实现方式：\n 自上而下的递归； 自下而上的迭代；  这里需要指出，在《数据结构与算法 JavaScript 描述》中，作者认为递归法在 JavaScript 中不可行，因为该算法的递归栈太深了:\n However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.\n 是因为在 JavaScript 引擎中，有对调用栈深度的限制，不同浏览器/解析引擎的值可能不一样。你可以执行如下代码来了解确切的限制值：\nvar i = 0; function inc() { i++; inc(); } try { inc(); } catch (e) { console.log(\u0026#34;Maximum stack size is\u0026#34;, i, \u0026#34;in your current browser\u0026#34;); } // 在 Node.js 环境执行得到的输出： // Maximum stack size is 15678 in your current browser 假定最大调用栈深度限制为x，那么当数据量大于 2x 时，JavaScript 环境中执行递归方式的归并算法就会出错。\n算法描述\n这里给出迭代法的描述：\n 对于长度为 n 的序列，将其视为每组大小为 1 的 n 组（视为每个元素为一组）； 执行归并操作：将每相邻的 2 组合并成一个有序的新组。例如：组 1 与组 2 合并，成为新的组 1，组 3 与组 4 合并成为新的组 2； 重复步骤 2，直到组的总数为 1，此时序列排序完毕。  动图演示\n下图演示的归并顺序是递归实现的，归并操作进行的顺序与迭代法不同，但是不影响理解其核心思想。\n代码实现\n// TypeScript实现 export function mergeSort(arr: number[]) { const len = arr.length; if (len \u0026lt; 2) return arr; const _helperArr = new Array(len); /** * 对于相邻的两组序列，可以知道： * 左边界为左侧序列的起始下标 * 中间点为左右序列的分界点，是左侧序列最后元素下标+1，也是右侧序列的起始下标 * 右边界为右侧序列的右边界，也是右侧序列的最后元素下标+1 * @param leftIdx 左侧边界 * @param midIdx 中间点 * @param rightIdx 右侧边界 * @param originArr 原始数组 * @param helperArr 辅助数组 */ function merge( leftIdx: number, midIdx: number, rightIdx: number, originArr: number[], helperArr: number[] ) { let i = leftIdx; let j = midIdx; let helperArrIndex = leftIdx; // 先将归并后的数组填充到辅助数组中  while (i \u0026lt; midIdx \u0026amp;\u0026amp; j \u0026lt; rightIdx) { if (originArr[i] \u0026lt; originArr[j]) { helperArr[helperArrIndex] = originArr[i]; i++; } else { helperArr[helperArrIndex] = originArr[j]; j++; } helperArrIndex++; } while (i \u0026lt; midIdx) { helperArr[helperArrIndex] = originArr[i]; i++; helperArrIndex++; } while (j \u0026lt; rightIdx) { helperArr[helperArrIndex] = originArr[j]; j++; helperArrIndex++; } // 将序列从辅助数组中复制到原数组  for ( helperArrIndex = leftIdx; helperArrIndex \u0026lt; rightIdx; helperArrIndex++ ) { originArr[helperArrIndex] = helperArr[helperArrIndex]; } } let groupSize = 1; while (Math.ceil(len / groupSize) \u0026gt; 1) { for (let i = 0; i \u0026lt; len; i += groupSize * 2) { // 合并每相邻两组，得到新的有序组  let midIdx: number, rightIdx: number; midIdx = (midIdx = i + groupSize) \u0026gt; len ? len : midIdx; rightIdx = (rightIdx = i + groupSize * 2) \u0026gt; len ? len : rightIdx; merge(i, midIdx, rightIdx, arr, _helperArr); } // 分组大小翻倍  groupSize \u0026lt;\u0026lt;= 1; } return arr; } 算法分析\n时间复杂度：不难得出归并操作总共会进行 O(logn)层，对于每一层来说，执行归并过程中每个元素都会被操作一次，也就是每层的时间复杂度为 O(n)，所以综合的时间复杂度为 O(nlogn)。\n空间复杂度：进行归并操作时，需要一个辅助数组保存归并后的序列，其空间复杂度为 O(n)。\n稳定性：稳定\n快速排序（Quick Sort） 快速排序，又称分区交换排序（partition-exchange sort），简称快排，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn)次比较。在最坏状况下则需要 O(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。\n算法描述\n快速排序使用分治策略来把一个序列分为较小和较大的 2 个子序列，然后递归地排序两个子序列。\n 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）； 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成； 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序，直到子序列长度为 1。  动图演示\n代码实现\n// TypeScript实现 export function quickSort( arr: number[], left: number = 0, right: number = arr.length - 1 ) { if (left \u0026gt;= right) return arr; const partitionIdx = partition(arr, left, right); quickSort(arr, left, partitionIdx - 1); quickSort(arr, partitionIdx + 1, right); return arr; } // 对于序列的左、中、右三个值，取中值作为基准值 function getPivotIndex(arr: number[], left: number, right: number) { const mid = left + ((right - left) \u0026gt;\u0026gt; 1); const midValue = arr[mid]; const leftValue = arr[left]; const rightValue = arr[right]; if (leftValue \u0026lt;= rightValue) { if (midValue \u0026lt; leftValue) { return left; } else if (midValue \u0026gt; rightValue) { return right; } else { return mid; } } else { if (midValue \u0026lt; rightValue) { return right; } else if (midValue \u0026gt; leftValue) { return left; } else { return mid; } } } /** * 对于给定的子序列，取一个基准值，并根据基准值分成左右区间 * 返回最后基准值所在的下标 */ function partition(arr: number[], left: number, right: number) { const pivotIdx = getPivotIndex(arr, left, right); // 先将基准值放在最左侧  [arr[pivotIdx], arr[left]] = [arr[left], arr[pivotIdx]]; let i = left + 1; let leftPartIdx = left; // 前后指针法分区  // leftPartIdx 代表了左侧序列最后一个元素的下标  // 搜索指针会一直向前移动  while (i \u0026lt;= right) { // 如果搜索指针找到的元素小于等于基准值  // 则表示该元素应该纳入左侧序列  if (arr[i] \u0026lt; arr[left]) { // 存在距离，说明 leftPartIdx 右侧元素是大于 pivot 的  // 则交换两个元素，将较小元素放置到左侧序列的右侧  if (i - leftPartIdx \u0026gt; 1) { [arr[leftPartIdx + 1], arr[i]] = [arr[i], arr[leftPartIdx + 1]]; } // 左侧序列的长度+1  leftPartIdx++; } i++; } // 将基准值与左侧序列最后一位元素交换  [arr[leftPartIdx], arr[left]] = [arr[left], arr[leftPartIdx]]; return leftPartIdx; } 算法分析\n时间复杂度分析：在最好的情况，每次我们运行一次分割，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作 logn 次嵌套的调用。在同一层次结构的多个程序调用中，分区操作会访问每个元素一遍，总共全部仅需要 O(n)的时间。综合起来其时间复杂度是 O(nlogn)。\n空间复杂度分析：快速排序算法所使用的空间，依照使用的版本而定。这里分析使用原地（in-place）分割的快速排序版本。对于 O(logn)层深度的嵌套调用，算法需要在每一层存储一个固定数量的信息。最好的情况最多需要 O(logn)次的嵌套递归调用，所以它需要 O(logn)的空间。最坏情况下需要 O(n)次嵌套递归调用，因此需要 O(n)的空间。\n最好时间复杂度：O(nlogn)\n最坏时间复杂度：O(n2)。假定每次分割某一侧都没有子片段，则调用树的深度是 O(n)，结合上文看每层处理需要 O(n)时间，综合起来就是 O(n2)。\n平均时间复杂度：O(nlogn)\n空间复杂度：对于 in-place 版本，平均 O(logn)，最坏 O(n)。\n稳定性：不稳定\n堆排序（Heap Sort） 堆排序是利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。要理解堆排序，首先要了解一下二叉树与堆。\n二叉树与堆\n二叉树：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。\n一棵有 9 个节点且深度为 3 的二叉树\n完全二叉树：在一颗二叉树中，若满足以下两个条件，则称其为完全二叉树：\n 除最后一层外的其余层都是满的 最后一层要么是满的，要么在右边缺少连续若干节点  深度为 3 的完全二叉树 0 / \\ 1 2 / \\ / \\ 3 4 5 6 对于完全二叉树，还可以用数组来储存。如果某个节点的索引为 i，（假设根节点的索引为 0）则在它左子节点的索引会是 2i+1，右子节点会是 2i+2；而它的父节点（如果有）索引则为 (i-1)/2。\n以上文为例：\n一个存储在数组中的完全二叉树\n堆：在完全二叉树的基础上，若二叉树满足以下条件，则称其为二叉堆：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。\n当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。\n此外，由于完全二叉树的特性，它可以用数组来进行表示。下例是一个最小堆和一个最大堆以及它们相应的数组表示：\n 最小堆 最大堆 1 11 / \\ / \\ 2 3 9 10 / \\ / \\ / \\ / \\ 4 5 6 7 5 6 7 8 / \\ / \\ / \\ / \\ 8 9 10 11 1 2 3 4 位置: 0 1 2 3 4 5 6 7 8 9 10 左堆: 1 2 3 4 5 6 7 8 9 10 11 右堆: 11 9 10 5 6 7 8 1 2 3 4 了解以上内容后，接下来我们讨论堆排序的原理。\n算法描述\n 初始化最大堆：将序列调整成一个最大堆，此时堆顶元素为最大值； 堆排序过程：取出堆顶元素，将剩下的堆继续调整为最大堆； 重复过程 2，直到所有元素被取出。  初始化最大堆\n对于一颗完全二叉树，执行如下算法就可以将其调整为最大二叉堆：\n 从树的倒数第二层，调整每个节点（最大堆调整），使其成为最大二叉堆节点； 往上一层，重复步骤 1，直到根节点。  最大堆调整算法(MAX-HEAPIFY)：\n 对比节点和其左右子节点，若子节点大于该节点，将最大的子节点和该节点交换位置； 若步骤一执行了交换操作，则对于被交换的子节点，再次执行步骤 1。  借助下图进行说明：\n上图中，依次对节点 5、4、3、2、1 进行了最大堆调整，最终整个二叉树成为一个最大堆。分析其原理：\n 先对第 3 层（节点 5、4）进行最大堆调整后，每一个节点都是最大堆（执行完 MAX-HEAPIFY(A,4)）； 对第 2 层（节点 3、2）进行最大堆调整，若第二层的某个节点与其某一侧子节点进行了交换，则只需要继续往下调整该侧子树，因为另一侧子树已经满足最大堆属性； 继续调整第 1 层，完成整个最大堆的调整。  堆排序过程\n 将堆顶元素取出； 将最后一个元素放到堆顶，并对堆顶执行最大堆调整算法； 重复步骤 1、2，直到所有元素都被取出。  参考下图便于理解：\n动图演示\n代码实现\n// TypeScript实现 export function heapSort(arr: number[]) { let len = arr.length; // build max heap  for (let i = Math.floor((len - 1) / 2); i \u0026gt;= 0; i--) { maxHeapify(arr, i, len); } // sort loop  while (len) { [arr[0], arr[len - 1]] = [arr[len - 1], arr[0]]; len--; maxHeapify(arr, 0, len); } return arr; } function maxHeapify(arr: number[], index: number, heapSize: number) { let maxIdx: number; let leftIdx: number; let rightIdx: number; while (true) { maxIdx = index; leftIdx = 2 * maxIdx + 1; rightIdx = 2 * maxIdx + 2; if (leftIdx \u0026lt; heapSize \u0026amp;\u0026amp; arr[leftIdx] \u0026gt; arr[maxIdx]) { maxIdx = leftIdx; } if (rightIdx \u0026lt; heapSize \u0026amp;\u0026amp; arr[rightIdx] \u0026gt; arr[maxIdx]) { maxIdx = rightIdx; } if (maxIdx !== index) { [arr[maxIdx], arr[index]] = [arr[index], arr[maxIdx]]; index = maxIdx; } else { break; } } } 算法分析\n最好时间复杂度：O(nlogn)\n最坏时间复杂度：O(nlogn)\n平均时间复杂度：O(nlogn)\n空间复杂度：O(1)\n稳定性：不稳定\n计数排序（Counting Sort） 计数排序是一种稳定的线性时间排序算法。该算法于 1954 年由 Harold H. Seward 提出。计数排序使用一个额外的数组 C ，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。\n算法描述\n通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1。算法的步骤如下：\n 找出待排序的数组中最大和最小的元素 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素 i 放在新数组的第 C[i]项，每放一个元素就将 C[i]减去 1  动图演示\n代码实现\n// TypeScript实现 export function countingSort(arr: number[]) { let max = arr[0]; let min = arr[0]; // 找出最大值、最小值  for (const n of arr) { if (n \u0026gt; max) { max = n; } if (n \u0026lt; min) { min = n; } } // 根据最大值、最小值初始化计数数组  const count_arr: number[] = new Array(max - min + 1); // 计数  for (const n of arr) { count_arr[n - min] = count_arr[n - min] ? count_arr[n - min] + 1 : 1; } // 累加  for (let i = 1; i \u0026lt; count_arr.length; i++) { if (!count_arr[i]) count_arr[i] = 0; count_arr[i] += count_arr[i - 1]; } const res = new Array(arr.length); // 根据位置信息重新排列数组  // 将 arr[i] 元素放置到 res 数组中正确的排序位置  // 为了保持稳定性，需要采用倒序  for (let i = arr.length - 1; i \u0026gt;= 0; i--) { res[--count_arr[arr[i] - min]] = arr[i]; } return res; } 算法分析\n计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。\n最好时间复杂度：O(n+k)\n最坏时间复杂度：O(n+k)\n平均时间复杂度：O(n+k)\n空间复杂度：O(k)\n稳定性：稳定\n桶排序（Bucket Sort） 桶排序工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（可以根据情况使用最佳的排序算法）。\n算法描述\n 设置一个定量的数组当作空桶子； 寻访序列，并且把项目一个一个放到对应的桶子去； 对每个不是空的桶子进行排序； 从不是空的桶子里把项目再放回原来的序列中。  图片演示\n元素分配到桶中 对桶中元素排序\n代码实现\n// TypeScript实现 export function bucketSort(arr: number[], bucketNums = 5) { let max = arr[0]; let min = arr[0]; // 找出最大值、最小值  for (const n of arr) { if (n \u0026gt; max) { max = n; } if (n \u0026lt; min) { min = n; } } const bucketSize = Math.floor((max - min) / bucketNums) + 1; const buckets: number[][] = []; for (let i = 0; i \u0026lt; arr.length; i++) { // 将元素放入桶中  const bIdx = Math.floor((arr[i] - min) / bucketSize); const bucketArr = buckets[bIdx] || (buckets[bIdx] = []); bucketArr.push(arr[i]); // 用冒泡排序保持桶内元素有序  for (let j = bucketArr.length - 1; j \u0026gt; 0; j--) { if (bucketArr[j - 1] \u0026gt; bucketArr[j]) { [bucketArr[j - 1], bucketArr[j]] = [bucketArr[j], bucketArr[j - 1]]; } } } let res: number[] = []; buckets.forEach((bucketArr) =\u0026gt; { res = res.concat(bucketArr); }); return res; } 算法分析\n桶排序实际上只需要遍历一遍所有的待排序元素，然后依次放入指定的位置。如果加上输出排序的时间，那么需要遍历所有的桶，时间复杂度就是 O(n+k)，其中，n 为待排序的元素的个数，k 为桶的个数。\n最好时间复杂度：O(n+k)\n最坏时间复杂度：O(n2)\n平均时间复杂度：O(n+k)\n空间复杂度：O(n+k)\n稳定性：稳定\n基数排序（Radix Sort） 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n算法描述\n将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。\n基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。\n动图演示\nLSD 基数排序\n代码实现\n// TypeScript实现 export function radixSortLSD(arr: number[]) { let max = arr[0]; // 找出最大值  for (const n of arr) { if (n \u0026gt; max) { max = n; } } // 确定最大位数  let maxDigit = 0; while (max) { maxDigit++; max = Math.floor(max / 10); } const buckets: number[][] = []; let mod = 10; // 根据最大位数进行 maxDigit 轮排序  // 由低位至高位排序  for (let k = 0; k \u0026lt; maxDigit; k++, mod *= 10) { // 根据当前位数字放入对应桶中  for (let i = 0; i \u0026lt; arr.length; i++) { const bucketIdx = Math.floor((arr[i] % mod) / (mod / 10)); const bucketArr = buckets[bucketIdx] || (buckets[bucketIdx] = []); bucketArr.push(arr[i]); } // 从桶中依次取出元素排序  let idx = 0; for (let j = 0; j \u0026lt; buckets.length; j++) { if (!buckets[j]) continue; while (buckets[j].length) { arr[idx] = buckets[j].shift(); idx++; } } } return arr; } 算法分析\n基数排序共需要进行 k 轮排序，其中 k 为最大位数。每轮排序的时间复杂度为 O(n)，所以综合时间复杂度为 O(n*k)。\n最好时间复杂度：O(n*k)\n最坏时间复杂度：O(n*k)\n平均时间复杂度：O(n*k)\n空间复杂度：O(n+k)\n稳定性：稳定\n参考资料  十大经典排序算法 维基百科 - 冒泡排序 维基百科 - 选择排序 维基百科 - 插入排序 维基百科 - 希尔排序 维基百科 - 归并排序 维基百科 - 快速排序 维基百科 - 堆排序 堆排序 (Heap Sort) 维基百科 - 计数排序 维基百科 - 桶排序 维基百科 - 基数排序  ","permalink":"https://ruihusky.github.io/ruihusky/posts/2021-02-21_sorting-algorithm/","summary":"概览与术语 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法，最常用到的排序方式之一就是数值顺序。\n排序算法依照稳定性可分为稳定算法和不稳定算法。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，则在排序过的列表中 R 也将会是在 S 之前。\n排序算法依照排序过程中占用空间的方式分为 In-place 算法 与 Out-place 算法。In-place 是原地算法，基本上不需要额外的辅助空间，可允许固定数量的辅助变量。非原地算法就是 Out-place，其开辟的辅助空间与问题规模相关。例如，冒泡排序只需要数据在原序列中交换位置，不需要额外的辅助空间，是 In-place 算法。\n不同的排序算法会有不同的时间复杂度（最差、平均、和最好性能），下表列出了十种经典排序算法的概览：\n冒泡排序（Bubble Sort） 一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为：越的元素会经由交换慢慢“浮”到数列的顶端。\n冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。\n算法描述\n 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到没有任何一对数字需要比较； 可选的优化步骤：某次步骤 1~3 执行过程中没有元素发生交换，则证明该序列已经有序，不需要再进行下一次序列遍历。  动图演示\n代码实现\n// TypeScript实现 export function bubbleSort(arr: number[]) { const len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { let sorted = true; for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { sorted = false; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } if (sorted) break; } return arr; } 算法分析","title":"十大经典排序算法"},{"content":"flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：\n页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。\n这个问题看起来不难。使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：\n\u0026lt;div class=\u0026#34;page-container\u0026#34;\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;div class=\u0026#34;image-wrap\u0026#34;\u0026gt; \u0026lt;!-- 为了实现多个动画效果，图片被一个div包裹 --\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- vue css scope --\u0026gt; \u0026lt;style\u0026gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } .image { /* 跟随父元素的高度变化 */ height: 100%; } \u0026lt;/style\u0026gt; 在 Chrome 中使用移动设备仿真，各种不同高度下的效果都 OK 了。结果用自己的 iPhone 再看却出了问题：图片没有按照预想的那样自动调整高度，而是保持着原始图片的大小。\n于是我开始搜索有关 flex 布局与 min/max 样式之间如何相互作用的资料。这里先给出最后的解决方案：给 .image-wrap 元素加上 flex-basis: 688px 样式。\nflex-basis 默认值：auto 为了彻底弄明白问题出在哪里，有必要进一步了解 flex-basis 属性。以前我只是简单的以为它大概就和 width 属性一样，设置不设置都没关系。研究过后才发现这个属性有着诸多细节。（这里为了简化说明，只探讨 flex-direction: row 的情形）\n在 flex 布局中，一个 flex 子项的最终尺寸是基础尺寸、弹性增长或收缩、最大最小尺寸限制共同作用的结果。其中：\n 基础尺寸由 flex-basis 与 box-sizing 盒模型共同决定； 弹性增长指的是 flex-grow 属性，弹性收缩指的是 flex-shrink 属性。这里不做过多阐述，详情可参考：flex-grow，flex-shrink； 最大最小尺寸限制指的是 min-width / max-width 等 CSS 属性。  其中优先级为：最大最小尺寸限制 \u0026gt; 弹性增长或收缩 \u0026gt; 基础尺寸。\n按照这个理论，在上文的例子中，我已经设置好了 max-height、min-height、flex-grow、flex-shrink，虽然没有设置 flex-basis，也不应该影响结果才对。\n我在查看了更多资料之后，发现 flex-basis 还有许多细节：\n 在 flex 布局中，flex-basis 就同非 flex 布局中 width 属性表现一样； 若同时设置了确定数值的 flex-basis 与 width，则 width 属性会被忽略； 当 flex-basis 值为 auto 时（默认值），子项的基本尺寸根据其自身的尺寸决定。更具体一点地说，由 box-sizing、width、min-width、max-width以及元素内容共同决定。  再来看上文的例子，我没有设置 flex-basis ，所以它是默认值 auto，flex 子项的 flex-basis 根据其自身的尺寸决定。对于 .image-wrap 元素，根据我所设置的 CSS 样式：\n.image-wrap { flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } 它的高度应该是由 box-sizing 盒模型、min-height、max-height 属性共同决定（注意这里我没有设置 height）。看来在这种情况下，Chrome 和 Safari 下对于最终效果的处理有些不一致。\n在使用弹性布局时，最好是明确给出 flex-basis 的值。\n参考资料 Oh My God，CSS flex-basis 原来有这么多细节\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2021-01-26_css-flex-basis/","summary":"flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：\n页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。\n这个问题看起来不难。使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：\n\u0026lt;div class=\u0026#34;page-container\u0026#34;\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;div class=\u0026#34;image-wrap\u0026#34;\u0026gt; \u0026lt;!-- 为了实现多个动画效果，图片被一个div包裹 --\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- ...其他flex子项 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- vue css scope --\u0026gt; \u0026lt;style\u0026gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } .","title":"CSS flex-basis: auto 与弹性布局"},{"content":"字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。\nUnicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。\n经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：\n 辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF \u0026hellip; 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF  所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。\n到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。\nUTF-32 UTF-32 是一种 Unicode 的实现，它使用 32 位（4 字节）对每个 Unicode 码位进行编码。而 Unicode 中，即便是辅助平面 16 中的码位，也只需要 21 位就可以编码：\nU+0001 =\u0026gt; 00000000 00000000 00000000 00000001 U+10FFFF =\u0026gt; 00000000 00010000 11111111 11111111 UTF-32 每个编码需要使用四个字节，空间浪费较多。其主要优点是可以直接由 Unicode 码位来索引。\nUTF-16 UTF-16 是一种变长编码，它使用 16 位（2 字节）来表示所有的 Unicode 基本平面码位。这么一看，岂不是只能表示 U+0000 ~ U+FFFF 范围的编码？那剩余的 16 个辅助平面怎么办？\nUTF-16 为了能继续表示辅助平面中的码位，使用了一种代理机制：用两个基本平面的编码组成一对来表示一个辅助平面的码位，称其为“代理对”，因此表现一个辅助平面的码位需要用到 32 位（4 字节）。\n这么一来不是有问题？某个 UTF-16 编码想要表示的是基本平面的码位还是辅助平面的码位呢？为了避免冲突，在基本平面中，所有用作“代理”的编码都不定义字符，以表示将其用于“代理”。\n基本平面中这些用作“代理”的编码区域被称之为“代理区”，其范围为 0xD800 ~ 0xDFFF，共 2048 个。“代理对”的前后两个代理分别称为“引导代理”、“尾随代理”。它们也有各自的取值范围：\n# 引导代理(0xD800 ~ 0xDBFF) # 1101 10pp ppxx xxxx 1101 1000 0000 0000 ~ 1101 1011 1111 1111 D 8 0 0 D B F F # 尾随代理(0xDC00 ~ 0xDFFF) # 1101 11xx xxxx xxxx 1101 1100 0000 0000 ~ 1101 1111 1111 1111 D C 0 0 D F F F 现在简要说明一下代理规则：\n其中引导代理中的 110110 、尾随代理中的 110111 是定数，p 、x 是变数。去掉定数后组合起来就是 pppp xxxx xxxx xxxx xxxx，共 20 位（2^20=1048576），刚好能够表示目前 16 个辅助平面中的全部码位（U+10000 ~ U+10FFFF，共 1048576 个）。其中 pppp 共 4 位，表示 16 个辅助平面之一的编号；紧接着的 16 位 x 表示某个辅助平面内的某个码位。\n如何将某一个辅助平面的码位转换为 UTF-16 中的“代理对”编码形式呢？以 U+1F1F1 为例说明具体算法：\n 辅助平面中的码位值减去0x10000得到 20 位长的比特组。U+1F1F1 是辅助平面 1 的码位，代理对中的平面编号值比实际的平面编号要减去 1（平面编号索引从 0 开始）。 # U+1F1F1 0001 1111 00 01 1111 0001 -0001 0000 00 00 0000 0000 =0000 1111 00 01 1111 0001 # 0000 代表是辅助平面 1 的码位  将 20 位长比特组中的高 10 位比特加上 0xD800，得到引导代理： # 第 1 步的高 10 位 0000 0000 0011 1100 +1101 1000 0000 0000 # 0xD800 =1101 1000 0011 1100 # 0xD83C 引导代理  将 20 位长比特组中的低 10 位比特加上 0xDC00，得到尾随代理： # 第 1 步的低 10 位 0000 0001 1111 0001 +1101 1100 0000 0000 # 0xDC00 =1101 1101 1111 0001 # 0xDDF1 尾随代理  将引导代理、尾随代理按前后顺序组合，就得到了该辅助平面码位值的 UTF-16 编码表示： # U+1F1F1 的 UTF-16 表示：D83CDDF1 1101 1000 0011 1100 1101 1101 1111 0001   UTF-16 的编码规则较为复杂。实际上，UTF-16 在 Unicode 字符集的三大编码方式(UTF-8、UTF-16、UTF-32)中的表现也不理想。它的存在是历史原因造成的。不过由于其推出时间最早，已被应用于大量环境中。\nUTF-8 UTF-8 是一种变长编码，其长度一般为 1~4 字节，当然也可以更长。\n举个例子来说，所有的 ASCII 字符用一个字节就足以进行表示，那么用 UTF-32 来表示就很浪费存储空间，进行网络传输时也浪费网络资源。\n相比 UTF-16 来说，UTF-8 的编码规则要容易理解的多：\n 每个 UTF-8 编码从首字节就能判断其编码长度：  首字节以0开头，为单字节编码 首字节以110开头，为双字节编码 首字节以1110开头，为三字节编码 首字节以1111开头，为四字节编码 \u0026hellip;   每个多字节的 UTF-8 编码，除首字节外的其他字节均以10开头  上述规则中的0、10、110等称之为 UTF-8 编码中的前缀码，除开前缀码之外的位就可以用来表示实际的 Unicode 码位。计算机通过前缀码就能识别 UTF-8 的每个字节的作用。\n# 单字节 UTF-8，可表示 2^(8-1)=128 个字符 0xxxxxxx # 双字节 UTF-8，可表示 2^(16-5)=2048 个字符 110xxxxx 10xxxxxx # 三字节 UTF-8，可表示 2^(24-8)=65536 个字符 1110xxxx 10xxxxxx 10xxxxxx # 四字节 UTF-8，可表示 2^(32-11)=2097152 个字符 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 再简单概括 UTF-8 的编码算法：\n 确定 UTF-8 编码中各个字节的前缀码 将 UTF-8 编码中各个字节除了前缀码所占用之外的位，依次分配给 Unicode 码位二进制中各个位的值  是不是很简单明了？UTF-8 编码设计得非常精巧，存储空间利用率较高、规则容易理解。除此之外，还有自动纠错性能好、利于传输、扩展性强等优点。而劣势在于，因为其编码长度可变，所以不利于程序的处理，例如导致正则表达式检索的复杂度大为增加。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-12-16_unicode-utf/","summary":"字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。\nUnicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。\n经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：\n 辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF \u0026hellip; 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF  所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。\n到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。","title":"Unicode 编码与 UTF-32、UTF-16、UTF-8"},{"content":"使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。\nWSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。\n从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。\n从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：\n$ cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：\nexport hostip=$(cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39;) alias proxy=\u0026#39; export https_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; export http_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; export all_proxy=\u0026#34;socks5://${hostip}:10808\u0026#34;; echo -e \u0026#34;Acquire::http::Proxy \\\u0026#34;socks5h://${hostip}:10808\\\u0026#34;;\u0026#34; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf \u0026gt; /dev/null; echo -e \u0026#34;Acquire::https::Proxy \\\u0026#34;socks5h://${hostip}:10808\\\u0026#34;;\u0026#34; | sudo tee -a /etc/apt/apt.conf.d/proxy.conf \u0026gt; /dev/null; \u0026#39; alias unproxy=\u0026#39; unset https_proxy; unset http_proxy; unset all_proxy; sudo sed -i -e \u0026#34;/Acquire::http::Proxy/d\u0026#34; /etc/apt/apt.conf.d/proxy.conf; sudo sed -i -e \u0026#34;/Acquire::https::Proxy/d\u0026#34; /etc/apt/apt.conf.d/proxy.conf; \u0026#39; 在 bash 中运行 proxy 可设置 bash、apt 走代理，运行 unproxy 则关闭代理。\n从局域网访问 WSL 2 网络 要实现从局域网访问 WSL 2 网络，需要在 Windows 上配置 端口转发 和 防火墙允许入站规则。参考以下 PowerShell 命令（需以管理员权限执行）：\n# 查询 WSL 2 IP 地址 C:\\Users\\ruihusky\u0026gt; wsl -- hostname -I 172.20.147.252 # 配置端口转发：外网访问 windows 8080 端口转发到 172.20.147.252:8080 C:\\Users\\ruihusky\u0026gt; netsh interface portproxy add v4tov4 listenport=8080 connectaddress=172.20.147.252 connectport=8080 # 添加允许入站规则 C:\\Users\\ruihusky\u0026gt; New-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 8080\u0026#34; -Direction Inbound -Action Allow -Protocol TCP -LocalPort 8080 Name : {0ff9eeaa-3e82-46f0-8b2a-cb985d514ede} DisplayName : Allow Inbound TCP Port 8080 Description : DisplayGroup : Group : Enabled : True Profile : Any Platform : {} Direction : Inbound Action : Allow EdgeTraversalPolicy : Block LooseSourceMapping : False LocalOnlyMapping : False Owner : PrimaryStatus : OK Status : 已从存储区成功分析规则。 (65536) EnforcementStatus : NotApplicable PolicyStoreSource : PersistentStore PolicyStoreSourceType : Local 配置完后可在局域网用其他设备通过 Windows IP 访问 WSL 2 服务。\n对应的删除配置命令：\nC:\\Users\\ruihusky\u0026gt; netsh interface portproxy show v4tov4 侦听 ipv4: 连接到 ipv4: 地址 端口 地址 端口 --------------- ---------- --------------- ---------- * 8080 172.20.147.252 8080 # 删除端口转发规则 C:\\Users\\ruihusky\u0026gt; netsh interface portproxy delete v4tov4 listenport=8080 # 删除防火墙入站规则 C:\\Users\\ruihusky\u0026gt; Remove-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 8080\u0026#34; 将上诉命令封装成函数便于调用，向 PowerShell $PROFILE 配置文件写入函数：\n# 在 PowerShell 中查看 $PROFILE 文件位置 C:\\Users\\ruihusky\u0026gt; $PROFILE C:\\Users\\ruihusky\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 写入以下内容：\nfunction Add-WSLPortProxy ($Port = \u0026#39;8080\u0026#39;, $Protocol = \u0026#39;TCP\u0026#39;) { $wslIP = wsl -- hostname -I $wslIP = $wslIP.Trim() netsh interface portproxy add v4tov4 listenport=$Port connectaddress=$wslIP connectport=$Port New-NetFirewallRule -DisplayName \u0026#34;Allow ${Protocol} Inbound Port ${Port}\u0026#34; -Direction Inbound -Action Allow -Protocol $Protocol -LocalPort $Port } function Remove-WSLPortProxy ($Port = \u0026#39;8080\u0026#39;, $Protocol = \u0026#39;TCP\u0026#39;) { netsh interface portproxy delete v4tov4 listenport=$Port Remove-NetFirewallRule -DisplayName \u0026#34;Allow ${Protocol} Inbound Port ${Port}\u0026#34; } 对应的调用命令为：Add-WSLPortProxy [$Port] [$Protocol] 、Remove-WSLPortProxy [$Port] [$Protocol]，其中 [$Port] [$Protocol] 均为可选参数，默认为 8080 、TCP。\n参考资料 比较 WSL 2 和 WSL 1 | 访问网络应用程序\nWin 10 与 WSL 2 间的网络和文件互访\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-12-11_wsl2-net-config/","summary":"使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。\nWSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。\n从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。\n从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：\n$ cat /etc/resolv.conf | grep -oP \u0026#39;(?\u0026lt;=nameserver\\ ).*\u0026#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：","title":"Windows 10 WSL 2 网络配置"},{"content":"前言 Promise 对象用于表示一个异步操作的最终完成（或失败），及其结果值。它最早由社区提出和实现，其中有多种 Promise 规范。ES6 按照 Promise/A+ 规范将其写进了语言标准。 关于该规范的详情可参考：Promise/A+规范 中文翻译。\n基础实现 我们先尝试实现最简单的 Promise 功能：通过 Promise 包装异步请求，并使用then方法注册回调函数，通过resolve方法通知 Promise 异步请求已解决，并执行回调函数。 模拟一个基础的异步 http 请求，并使用 Promise 封装：\n// 模拟http请求 const mockAjax = (url, s, callback) =\u0026gt; { console.log(\u0026#34;[mockAjax] start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;[mockAjax] callback\u0026#34;); callback(\u0026#34;异步结果：\u0026#34; + url + \u0026#34;异步请求耗时\u0026#34; + s + \u0026#34;秒\u0026#34;); }, 1000 * s); }; // Promise基础功能 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 实现思路  then用于注册回调函数，因此可以在 Promise 实例中维护一个回调函数队列。 then要求可以进行链式调用，考虑在then方法中return this。 Promise 的构造方法接受一个[resolve =\u0026gt; {}]形式的函数，其中resolve方法接受异步请求的返回值并传递给then注册的回调函数。因此可以通过resolve方法调用回调函数队列中的函数。 这里的思路类似于观察者模式。  依照上述两点，我们可以做最简单的实现：\nclass Promise { // 回调队列  callbacks = []; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 将onFulfilled函数添加到callbacks中  this.callbacks.push(onFulfilled); // 基础链式调用  return this; } // resolve被调用时执行注册过的onFulfilled函数  _resolve(value) { this.callbacks.forEach((fn) =\u0026gt; fn(value)); } } 状态保存 在上面的实现中，存在这样的问题： 在resolve执行之后再通过then注册的回调函数不会执行。例如同步执行resolve，或者resolve之后再次调用then:\n// Promise const p = new Promise((resolve) =\u0026gt; { // 同步执行的resolve，比then先执行  resolve(result); // 此处的回调不会执行 }).then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); // 此处的回调不会执行 p.then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 为了解决这个问题，我们需要在 Promise 中保存状态和值。规范中规定，Promise 的状态可以从pending转换为fulfilled或者rejected，分别代表“处理中”、“已解决”、“已失败”。状态转换的过程是不可逆的。修改上文的实现如下：\n// 带基础链式调用功能的简单实现 class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 在Promise未解决之前，onFulfilled函数添加到callbacks中  if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(onFulfilled); // 在Promise解决之后，直接执行onFulfilled函数  } else { onFulfilled(this.value); } // 基础链式调用  return this; } // resolve被调用时执行注册过的onFulfilled函数  _resolve(value) { // 改变状态  this.state = \u0026#34;fulfilled\u0026#34;; // 保存结果  this.value = value; this.callbacks.forEach((fn) =\u0026gt; fn(value)); } } 参考代码：Promise：基础实现。\n进阶：链式调用 考虑如下一种链式调用的情形：\n// 在链式调用中传递值 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); return \u0026#34;第一个then的返回值\u0026#34;; }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 注意到，第一个then方法最后返回了一个值，并且我们希望在第二个then方法中可以接收到。\n链式 Promise 首先，第二个then方法中接受的值与最初 Promise 的值是不同的；其次，Promise 的状态改变是不可逆的，因此我们不能在then方法中重新修改 Promise 的值，这不符合规范。那么只剩下一种可能来实现then的链式调用：then方法最终返回的是一个新的 Promise 实例，并且该实例的值就是第一个then方法中return语句的返回值，比如上例中的字符串\u0026quot;第一个 then 的返回值\u0026quot;。\n我们就依据上文的示例来理清一下思路：\n 第一个then方法注册的回调函数应该保存在第一个 Promise 实例之中（代称 p1），并且最终调用该回调函数的也应该是 p1 实例。 在 p1 实例调用回调函数时，需要获得回调函数的返回值，并且传递给下一个 Promise 实例(代称 p2)，也就是调用p2.resolve(/*回调函数的返回值*/)。 p2.then以及之后的链式调用思路是递归的。  理解以上几点之后，我们尝试实现：\n// 链式Promise class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // _resolve方法用于改变Promise的状态为已解决，并执行回调队列[形式为(value) =\u0026gt; {}]  _resolve(value) { // 改变状态，保存值  this.state = \u0026#34;fulfilled\u0026#34;; this.value = value; // 依次执行回调队列  this.callbacks.forEach((fn) =\u0026gt; fn()); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 返回了新的 Promise 实例，这样可实现真正的链式调用  const nextPromise = new Promise((resolve) =\u0026gt; { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(() =\u0026gt; { this._execCb(onFulfilled, resolve); }); return; } if (this.state === \u0026#34;fulfilled\u0026#34;) { this._execCb(onFulfilled, resolve); return; } }); return nextPromise; } _execCb(cb, resolve) { const x = cb(this.value); resolve(x); } } 核心思路就是通过递归实现链式调用，可能不那么容易看懂，这里列出几个要点以帮助理解：\n _execCb方法负责执行回调函数，并且将回调函数的返回值通过resolve(x)传递给下一个 Promise。 then方法中，先创建了新的 Promise，并且在其构造函数中，根据当前 Promise 的状态选择执行回调函数或者将该操作放入回调队列。 _resolve方法负责改变 Promise 的状态为已解决，并按顺序执行回调队列。  仔细理解以上三点，再总结一下核心思路：前一个 Promise 执行resolve时，回调队列将被执行，并且回调队列中所执行函数的返回值通过下一个 Promise 的resolve传入。这就是通过链式 Promise 实现链式调用的基础。\n当返回值为 Promise 考虑如下一个应用场景：\n// 在链式调用中传递Promise new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); return new Promise((resolve) =\u0026gt; { resolve(\u0026#34;第一个then返回了一个Promise\u0026#34;); }); }) .then((result) =\u0026gt; { console.log(\u0026#34;[then] onFulfilled:\u0026#34;, result); }); 当注册的回调函数返回了一个 Promise 时，我们希望之后注册的回调队列能等待该 Promise 改变状态再执行，这又如何实现呢？在理解上文的基础上，我们理清一下思路：\n 按照之前的逻辑，第一个then方法将生成一个 Promise(代称 p1)，并且回调函数将返回一个 Promise 实例(代称 p2)。 如果 p2 的状态依旧为pending，则需要等待其状态改变，再执行 p1 相应的状态改变方法。  其实这部分内容在 Promise/A+规范：Promise 解决过程 一节中有详细的处理逻辑，这里引用一部分内容：\n Promise 解决过程是一个抽象的操作，其需输入一个promise和一个值，我们表示为[[Resolve]](promise, x)，如果x有then方法且看上去像一个 Promise ，解决程序即尝试使promise接受x的状态；否则其用x的值来执行promise。\n 更多详细的说明大家可以点击链接查看。\n在这里我们先简化问题，只考虑回调函数返回值为 Promise 这一种特殊情况，且不处理 rejected 状态。\n首先明白一个概念：在获得回调函数的返回值后，根据该返回值处理下一个 Promise 的过程称之为 Promise 解决过程。在该过程中，判断回调函数返回值为 Promise 时，调用该 Promise 的 then 方法，将此次解决过程注册为回调函数延迟执行。这一段有点绕，我们参考代码理解：\n// Promise解决过程 function resolvePromise(promise, x, resolve) { if (x instanceof Promise) { const then = x.then; then.call(x, (y) =\u0026gt; { resolvePromise(promise, y, resolve); }); return; } resolve(x); } // 链式Promise class Promise { // 回调队列  callbacks = []; // Promise实例状态  state = \u0026#34;pending\u0026#34;; // Promise的值  value = null; // 构造函数传入需要执行的函数[形式为(resolve) =\u0026gt; {}]  constructor(fn) { fn(this._resolve.bind(this)); } // _resolve方法用于改变Promise的状态为已解决，并执行回调队列[形式为(value) =\u0026gt; {}]  _resolve(value) { // 改变状态，保存值  this.state = \u0026#34;fulfilled\u0026#34;; this.value = value; // 依次执行回调队列  this.callbacks.forEach((fn) =\u0026gt; fn()); } // then方法用于注册onFulfilled函数[形式为(value) =\u0026gt; {}]  then(onFulfilled) { // 返回了新的 Promise 实例，这样可实现真正的链式调用  const nextPromise = new Promise((resolve) =\u0026gt; { if (this.state === \u0026#34;pending\u0026#34;) { this.callbacks.push(() =\u0026gt; { // 必须异步执行，否则无法获取nextPromise对象  setTimeout(() =\u0026gt; { this._execCb(onFulfilled, nextPromise, resolve); }); }); return; } if (this.state === \u0026#34;fulfilled\u0026#34;) { // 必须异步执行，否则无法获取nextPromise对象  setTimeout(() =\u0026gt; { this._execCb(onFulfilled, nextPromise, resolve); }); return; } }); return nextPromise; } _execCb(cb, nextPromise, resolve) { const x = cb(this.value); resolvePromise(nextPromise, x, resolve); } } 这部分内容可能不易理解，请大家多动手多思考。这一节的完整代码可参考：Promise：链式调用实现。\n完整实现 上文已经将 Promise 的核心逻辑实现。在理解了这部分的基础上，参照规范将其余部分进行实现应该不难了。 剩下的工作主要在于添加 rejected 状态处理，以及考虑一些边界条件(例如当resolve传递了Promise实例本身导致链式调用进入死循环)。 完整的实现代码可以参考：Promise/A+完整实现。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-11-27_promise-aplus/","summary":"前言 Promise 对象用于表示一个异步操作的最终完成（或失败），及其结果值。它最早由社区提出和实现，其中有多种 Promise 规范。ES6 按照 Promise/A+ 规范将其写进了语言标准。 关于该规范的详情可参考：Promise/A+规范 中文翻译。\n基础实现 我们先尝试实现最简单的 Promise 功能：通过 Promise 包装异步请求，并使用then方法注册回调函数，通过resolve方法通知 Promise 异步请求已解决，并执行回调函数。 模拟一个基础的异步 http 请求，并使用 Promise 封装：\n// 模拟http请求 const mockAjax = (url, s, callback) =\u0026gt; { console.log(\u0026#34;[mockAjax] start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;[mockAjax] callback\u0026#34;); callback(\u0026#34;异步结果：\u0026#34; + url + \u0026#34;异步请求耗时\u0026#34; + s + \u0026#34;秒\u0026#34;); }, 1000 * s); }; // Promise基础功能 new Promise((resolve) =\u0026gt; { mockAjax(\u0026#34;getUserId\u0026#34;, 1, function (result) { resolve(result); }); }) .then((result) =\u0026gt; { console.","title":"Promise实现原理（Promise/A+规范）"},{"content":"构造函数模式与原型 在 ES5 中，我们可以自定义构造函数用于创建特定的类型对象，例如：\n// 定义构造函数 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function () { console.log(this.name); }; } // 以 new 操作符调用构造函数 let person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); let person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); person1.sayName(); // Nicholas person2.sayName(); // Greg 其实这里的“构造函数”说法只是一种概念上的区分，它与普通的 JavaScript 函数没什么区别。通常会约定构造函数以大写字母开头，非构造函数以小写字母开头。\n通过new操作符调用构造函数，会创建一个 Person 的实例。具体的创建过程如下：\n 在内存中创建一个新对象。 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 执行构造函数内的代码，并以刚才新建的对象作为this值。 若构造函数返回非空对象，则返回该对象，否则返回刚才创建的对象。  每个函数都会有prototype属性，它是一个对象，默认有一个属性constructor指向函数本身。而通过new操作符创建的新对象，内部的[[Prototype]]属性指向该原型对象。下面的例子展示了这些特性：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function () { console.log(this.name); }; console.log(Person.prototype.constructor === Person); // true  const person1 = new Person(); person1.sayName(); // \u0026#34;Nicholas\u0026#34;  const person2 = new Person(); person2.sayName(); // \u0026#34;Nicholas\u0026#34;  console.log(person1.sayName == person2.sayName); // true console.log(Object.getPrototypeOf(person1) === Person.prototype); // true 访问对象的属性时，会先从对象的自身拥有的属性找起。找不到再去对象的[[Prototype]]所指向的对象中寻找。上面的例子也说明了这一点。\n继承 ECMAScript 中描述了 原型链 的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。回想一下上文的概念：每个构造函数都有一个原型对象，而实例有一个内部指针指向原型。如果原型是另一个构造函数的实例呢？那意味着这个实例也会有一个内部指针指向另一个原型。这样就在实例和原型之间构造了一条原型链。\n实现原型链的一种基本模式是让 原型对象等于另一个类型的实例：\nfunction SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function () { return this.property; }; function SubType() { this.subProperty = false; } // 继承 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subProperty; }; const instance = new SubType(); console.log(instance.getSuperValue()); // true 以上代码定义了 SuperType、SubType 两个类型，他们分别有自己的属性和方法。通过重写 Subtype 的原型对象（让其等于 SuperType 的实例），可以让存在于 SuperType 实例中的所有属性和方法在 SubType.prototype 访问到。\n结合上文的原型搜索机制来理解：访问一个实例属性时，首先在实例中搜索该属性。如果没有找到则会继续搜索该实例的原型。通过原型链实现继承后，搜索过程就会沿着原型链继续向上。拿上面的例子来说，调用 instance.getSuperValue() 的过程如下：\n搜索 SubType 实例 \u0026ndash;\u0026gt; 搜索SubType.prototype \u0026ndash;\u0026gt; 搜索SuperType.prototype \u0026ndash;\u0026gt; 找到 getSuperValue 方法\n另外，任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向 Object.prototype。因此可以这么概括：SubType 继承自 SuperType ，SuperType 继承自 Object。完整的原型链如下：\n原型链的问题 原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。举例来说：\nfunction SuperType() { this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } function SubType() {} // 继承了SuperType SubType.prototype = new SuperType(); const instance1 = new SubType(); instance1.colors.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // \u0026#34;red,blue,green,black\u0026#34;  const instance2 = new SubType(); console.log(instance2.colors); // \u0026#34;red,blue,green,black\u0026#34; 原型中包含引用值时，该引用值就会在所有实例中共享。可以看到，对 instance1.colors 所做的修改，会在 instance2 反映出来。\n原型链的第二个问题是：创建子类实例时，无法向超类的构造函数传递参数。\n为了解决这些问题，通常会使用下面这些技术来实现继承。\n组合继承 通过将原型链和借用构造函数技术相结合达到目的。使用原型链实现对原型属性、方法的继承，通过借用构造函数实现对实例属性的继承。\nfunction SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function () { console.log(this.name); }; function SubType(name, age) { // 继承属性，通过call()函数在子类实例内部创建超类的属性  SuperType.call(this, name); this.age = age; } // 子类原型指向超类实例：这样可以通过原型链访问到超类原型 SubType.prototype = new SuperType(); // 默认情况下，所有原型对象会自动获得一个constructor（构造函数）属性，指向原型对象所在函数。 // 覆写的prototype对象没有constructor属性，需要重新指定。 SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function () { console.log(this.age); }; const instance1 = new SubType(\u0026#34;Nicholas\u0026#34;, 29); instance1.colors.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // \u0026#34;red,blue,green,black\u0026#34; instance1.sayName(); // \u0026#34;Nicholas\u0026#34;; instance1.sayAge(); // 29  const instance2 = new SubType(\u0026#34;Greg\u0026#34;, 27); console.log(instance2.colors); // \u0026#34;red,blue,green\u0026#34; instance2.sayName(); // \u0026#34;Greg\u0026#34;; instance2.sayAge(); // 27 在这个例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 超类实例直接赋值给子类原型，Subtype.prototype 也有 name、colors 属性。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  这种继承方式是 JavaScript 中最为常见的继承模式。并且 instanceof 和 isPrototypeOf() 也能够用于识别子类实例。\n寄生式组合继承 组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，为了达到子类继承超类的目的，需要做到以下两点：\n 子类拥有超类实例的所有属性。 子类继承超类的原型。  对于第 1 点，使用借用构造函数的方法就可以实现了：\nfunction SubType(name, age) { // 继承属性，通过call()函数在子类实例内部创建超类的属性  SuperType.call(this, name); this.age = age; } 对于第 2 点，我们通过下述模式实现：\n// 这里是原型式继承。通过该函数，将实例的原型指定为对象o，从而拥有o的属性。 function object(o) { function F() {} F.prototype = o; return new F(); } // 寄生式组合继承的核心逻辑 // 接受两个参数：子类构造函数、超类构造函数 function inheritPrototype(subType, superType) { // 创建prototype对象，目的是准备把它当成子类的原型。同时该prototype对象的原型是超类原型。  const prototype = object(superType.prototype); //创建对象  // 覆写的prototype对象没有constructor属性，需要重新指定。  prototype.constructor = subType; // 将prototype对象赋值给子类原型  subType.prototype = prototype; } 简单的一句话概括：创建一个空对象作为子类的原型，同时将该对象的原型指向超类原型。这样一来子类只继承了超类的原型，而与超类实例无关。 下面是一个更加具体的例子：\nfunction SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function () { console.log(this.name); }; function SubType(name, age) { // 借用构造函数继承实例属性  SuperType.call(this, name); this.age = age; } // 继承超类原型 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function () { console.log(this.age); }; 在上面的例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  与上述组合继承方式相比，这种继承方式避免了在 SubType.prototype 上创建多余的属性，同时保持了原型链不变。\n","permalink":"https://ruihusky.github.io/ruihusky/posts/2020-11-12_js-prototype/","summary":"构造函数模式与原型 在 ES5 中，我们可以自定义构造函数用于创建特定的类型对象，例如：\n// 定义构造函数 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function () { console.log(this.name); }; } // 以 new 操作符调用构造函数 let person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); let person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); person1.sayName(); // Nicholas person2.sayName(); // Greg 其实这里的“构造函数”说法只是一种概念上的区分，它与普通的 JavaScript 函数没什么区别。通常会约定构造函数以大写字母开头，非构造函数以小写字母开头。\n通过new操作符调用构造函数，会创建一个 Person 的实例。具体的创建过程如下：\n 在内存中创建一个新对象。 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。 执行构造函数内的代码，并以刚才新建的对象作为this值。 若构造函数返回非空对象，则返回该对象，否则返回刚才创建的对象。  每个函数都会有prototype属性，它是一个对象，默认有一个属性constructor指向函数本身。而通过new操作符创建的新对象，内部的[[Prototype]]属性指向该原型对象。下面的例子展示了这些特性：\nfunction Person() {} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.","title":"JavaScript原型与继承"}]