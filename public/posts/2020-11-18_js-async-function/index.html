<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JavaScript异步编程：Generator函数与Async函数 | ruihusky&#39;s Blog</title>

<meta name="keywords" content="JavaScript" />
<meta name="description" content="Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。
运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：
setTimeout(function () { console.log(&#34;Hello World&#34;); }, 1); function foo() { // 提示: 最好不要尝试这样的迭代  for (var i = 0; i &lt;= 1e10; i&#43;&#43;) { console.log(i); } } foo(); // 0..1E10 // &#34;Hello World&#34; 在这个例子中，foo() 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 foo() 函数运行过程中，上面的 setTimeout() 函数不会被运行，直到 foo() 函数运行结束。
运行-停止-运行 Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行。
这里引申到 协程（coroutine） 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。
在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 yield 关键字从内部将函数的运行打断。除了 Generator 函数内部的 yield 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。">
<meta name="author" content="ruihusky">
<link rel="canonical" href="https://ruihusky.github.io/ruihusky/posts/2020-11-18_js-async-function/" />
<link href="/ruihusky/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://ruihusky.github.io/ruihusky/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ruihusky.github.io/ruihusky/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ruihusky.github.io/ruihusky/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ruihusky.github.io/ruihusky/apple-touch-icon.png">
<link rel="mask-icon" href="https://ruihusky.github.io/ruihusky/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="JavaScript异步编程：Generator函数与Async函数" />
<meta property="og:description" content="Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。
运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：
setTimeout(function () { console.log(&#34;Hello World&#34;); }, 1); function foo() { // 提示: 最好不要尝试这样的迭代  for (var i = 0; i &lt;= 1e10; i&#43;&#43;) { console.log(i); } } foo(); // 0..1E10 // &#34;Hello World&#34; 在这个例子中，foo() 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 foo() 函数运行过程中，上面的 setTimeout() 函数不会被运行，直到 foo() 函数运行结束。
运行-停止-运行 Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行。
这里引申到 协程（coroutine） 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。
在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 yield 关键字从内部将函数的运行打断。除了 Generator 函数内部的 yield 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ruihusky.github.io/ruihusky/posts/2020-11-18_js-async-function/" />
<meta property="article:published_time" content="2020-11-18T20:00:00+08:00" />
<meta property="article:modified_time" content="2020-11-18T20:00:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JavaScript异步编程：Generator函数与Async函数"/>
<meta name="twitter:description" content="Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。
运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：
setTimeout(function () { console.log(&#34;Hello World&#34;); }, 1); function foo() { // 提示: 最好不要尝试这样的迭代  for (var i = 0; i &lt;= 1e10; i&#43;&#43;) { console.log(i); } } foo(); // 0..1E10 // &#34;Hello World&#34; 在这个例子中，foo() 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 foo() 函数运行过程中，上面的 setTimeout() 函数不会被运行，直到 foo() 函数运行结束。
运行-停止-运行 Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行。
这里引申到 协程（coroutine） 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。
在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 yield 关键字从内部将函数的运行打断。除了 Generator 函数内部的 yield 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript异步编程：Generator函数与Async函数",
  "name": "JavaScript异步编程：Generator函数与Async函数",
  "description": "Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。\n运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：\nsetTimeout(function () { console.log(\u0026amp;#34;Hello …",
  "keywords": [
    "JavaScript"
  ],
  "articleBody": "Generator 函数基本概念 关于协程 首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。\n运行-完成 对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：\nsetTimeout(function () { console.log(\"Hello World\"); }, 1); function foo() { // 提示: 最好不要尝试这样的迭代  for (var i = 0; i  1e10; i++) { console.log(i); } } foo(); // 0..1E10 // \"Hello World\" 在这个例子中，foo() 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 foo() 函数运行过程中，上面的 setTimeout() 函数不会被运行，直到 foo() 函数运行结束。\n运行-停止-运行 Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行。\n这里引申到 协程（coroutine） 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。\n在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 yield 关键字从内部将函数的运行打断。除了 Generator 函数内部的 yield 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。\n一旦 Generator 函数被中断，它不可能自行恢复运行，除非通过外部的控制来重新该函数。稍后会介绍如何做到这一点。\n更重要的一点是，Generator 函数的执行，允许信息的双向传递。普通函数在开始的时候获取参数，在结束的时候返回一个值，而 Generator 函数可以在每次 yield 的时候返回值，并且在下一次重新启动的时候再传入值。这样就能完美实现各线程之间的通信。\nGenerator 函数基本语法 看一个简单例子：\nfunction* helloWorldGenerator() { yield \"hello\"; yield \"world\"; return \"ending\"; } var hw = helloWorldGenerator(); 与普通函数相比，例子中多了一个 * 来进行标示，表示这是一个 Generator 函数。另外，函数体内有关键字 yield ，称作 yield 表达式。\n那么，yield 表达式的作用是什么？有两点：\n 每次函数中断时将 yield 表达式的结果输出。 重新启动函数时，传入的值会作为 yield 表达式计算的结果。  举例说明：\nfunction* foo() { var x = 1 + (yield \"foo\"); console.log(x); } 在 foo() 函数暂停时，yield \"foo\" 表达式会返回字符串\"foo\"，下一次 foo() 函数重新启动时，传入的值会代替 yield \"foo\" ，结果就是将 1 + 传入值 的结果赋值给 x。\nGenerator 函数运行控制 Generator 遍历器对象 执行 Generator 函数会返回一个遍历器对象，该遍历器对象可以依次遍历 Generator 函数内部的每一个状态。这听起来好像有点复杂，考虑下面这个简单的例子：\nfunction* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } // 返回了遍历器对象 var it = foo(); // 第一次通过next()调用，返回第一个yield的值 var message = it.next(); console.log(message); // { value:1, done:false } // 事实上每次调用next()方法都会返回一个object对象，其中的value属性就是yield表达式返回的值。 // 属性done是一个boolean类型，用来表示对Generator函数的遍历是否已经结束。 console.log(it.next()); // { value:2, done:false } console.log(it.next()); // { value:3, done:false } console.log(it.next()); // { value:4, done:false } console.log(it.next()); // { value:5, done:false } // 这里注意到，执行到yield 5时，done属性依然是false。 // 这是因为从技术上来说，Generator函数还没有执行完。 // 我们必须再调用一次next()方法，然后Generator函数才算执行完毕。 // 注意到最后一次的value是return语句的返回值。 console.log(it.next()); // { value:6, done:true } 仔细看完上面的例子，相信已经可以理解 Generator 函数运行控制的基本概念了。这里还没有涉及到值的传入，给一个稍微复杂的例子：\nfunction* foo(x) { var y = 2 * (yield x + 1); var z = yield y / 3; return x + y + z; } var it = foo(5); // 注意这里在调用next()方法时没有传入任何值 console.log(it.next()); // { value:6, done:false } console.log(it.next(12)); // { value:8, done:false } console.log(it.next(13)); // { value:42, done:true } 这里解释一下上面的例子中发生了什么：\n 构造 Generator 函数遍历器的时候，通过语句 foo(5)，我们将参数 x 的值设置为 5。 第一次调用 next()方法时，没有传入任何值。因为此时没有 yield 表达式来接收我们传入的值。如果在第一次调用 next()方法时传入一个值，也不会有任何影响，该值会被抛弃掉。按照 ES6 标准的规定，此时 Generator 函数会直接忽略掉该值。 表达式 yield(x + 1) 的返回值是 6，然后第二个 next(12) 将 12 作为参数传入，用来代替表达式 yield(x + 1) ，因此变量 y 的值就是 12 * 2 = 24。随后的 yield(y / 3)（即 yield(24 / 3) ）返回值 8。然后第三个 next(13) 将 13 作为参数传入，用来代替表达式 yield(y / 3) ，所以变量 z 的值是 13。 最后，语句 return (x + y + z) 即 return (5 + 24 + 13) ，所以最终的返回值是 42。  for…of 循环 ES6 从语法层面上对遍历器提供了直接的支持，即 for…of 循环。因此 Generator 函数遍历器也可以使用下面的方式进行循环控制：\nfunction* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (var v of foo()) { console.log(v); } // 1 2 3 4 5  console.log(v); // 仍然是5，而不是6 注意到，for…of 循环忽略并抛弃了返回值 6，这是因为此处没有对应的 next() 方法被调用，另外，for…of 循环不支持将值传递到 Generator 函数内。\nGenerator 函数错误处理 ES6 Generators 函数内部的代码是同步的，即使在 Generator 函数外部控制是异步进行的。也就是说，你可以使用任何你所熟悉的错误处理机制来简单地在 Generator 函数中处理错误，例如使用 try/catch 机制。 来看一个例子：\nfunction* foo() { try { var x = yield 3; console.log(\"x: \" + x); } catch (err) { console.log(\"Error: \" + err); } } var it = foo(); var res = it.next(); // { value:3, done:false }  // 这里我们不调用next()方法，而直接抛出一个异常： it.throw(\"Oops!\"); // Error: Oops! 这里我们使用了另一个方法 throw()，它会在 Generator 函数暂停的位置抛出一个错误，然后函数内部的 try/catch 语句捕获了这个错误。\n如果函数内部没有 try/catch 语句，会发生什么？错误因为没有被任何代码捕获，会被当作一个未处理的异常向上抛出。\nfunction* foo() {} var it = foo(); try { it.throw(\"Oops!\"); } catch (err) { console.log(\"Error: \" + err); // Error: Oops! } 很显然，如果在 Generator 函数内部发生的错误没有被捕获，也会被向上抛出。\nfunction* foo() { var x = yield 3; var y = x.toUpperCase(); // 可能会引发类型错误！  yield y; } var it = foo(); it.next(); // { value:3, done:false }  try { it.next(42); // 42没有toUpperCase()方法 } catch (err) { console.log(err); // toUpperCase()引发TypeError错误 } Generator 函数委托 在一个 Generator 函数体内，可以调用另一个 Generator 函数，实际上是将当前 Generator 函数的迭代控制 委托 给另一个 Generator 函数。我们通过关键字 yield * 来实现。看下面的代码：\nfunction* foo() { yield 3; yield 4; } function* bar() { yield 1; yield 2; yield* foo(); // `yield *` 将当前函数的迭代控制委托给另一个Generator函数foo()  yield 5; } for (var v of bar()) { console.log(v); } // 1 2 3 4 5 在关键字 yield * 的位置，程序将迭代控制委托给另一个 Generator 函数 foo()，随后 for...of 循环将通过 next() 方法遍历 foo()。当对 foo() 的遍历结束后，委托控制又重新回到之前的 Generator 函数。\n不使用 for...of 循环，通过 next() 方法控制并传入相应的值来进行遍历，这些传入的值也会通过 yield * 关键字传递给对应的 yield 表达式中。另外，yield * 表达式可以接收被委托的 Generator 函数的返回值。\nfunction* foo() { var z = yield 3; var w = yield 4; console.log(\"z: \" + z + \", w: \" + w); return \"foo\"; } function* bar() { var x = yield 1; var y = yield 2; var f = yield* foo(); // `yield*` 将控制权委托给 `foo()`，并且接受了字符串`foo`  console.log(\"f: \" + f); var v = yield 5; console.log(\"x: \" + x + \", y: \" + y + \", v: \" + v); } var it = bar(); it.next(); // { value:1, done:false } it.next(\"X\"); // { value:2, done:false } it.next(\"Y\"); // { value:3, done:false } it.next(\"Z\"); // { value:4, done:false } it.next(\"W\"); // { value:5, done:false },f=\"foo\" // z: Z, w: W // f: foo it.next(\"V\"); // { value:undefined, done:true } // x: X, y: Y, v: V 对于yield * 表达式中的错误传递，道理也很简单：在被委托函数内的错误如果未被捕获，就会抛出到委托函数中。若在委托函数中仍未被处理，就会继续向上抛出。\nfunction* foo() { try { yield 2; } catch (err) { console.log(\"foo caught: \" + err); } yield; // 暂停  // 抛出一个错误  throw \"Oops!\"; } function* bar() { yield 1; try { yield* foo(); } catch (err) { console.log(\"bar caught: \" + err); } } var it = bar(); it.next(); // { value:1, done:false } it.next(); // { value:2, done:false }  it.throw(\"Uh oh!\"); // 将会被foo()中的try..catch捕获 // foo caught: Uh oh!  it.next(); // { value:undefined, done:true } -- 注意这里不会出现错误！ // bar caught: Oops! Generator 函数的异步应用 前文所述所有对 Generator 函数的控制都是同步执行的，现在来看看如何利用 Generator 函数开发异步应用。\nGenerator 与 Promise 的结合 从这里开始理解起来会稍有困难，我的建议是自己动手去运行一下这些实例，有助于加快理解。最新的 Node.js 环境已经支持所有示例。\n设想一下：yield 表达式返回了一个 Promise 对象。之后我们可以做些什么动作？我们可以通过 Promise 对象的状态（resolved/rejected）来对 Generator 函数的流程进行控制。\n先从一个简单一点的例子说起：\nfunction request(num) { // 注意：返回的是一个Promise对象  return new Promise(function (resolve, reject) { setTimeout(function () { num += 1; // 返回新num值  console.log(\"Promise resolved.\"); resolve(num); }, 1000); }); } function* main() { var ret1 = yield request(0); var ret2 = yield request(ret1); console.log(\"Number: \" + ret2); } var it = main(); var step1 = it.next(); console.log(step1); step1.value.then(function (num) { step2 = it.next(num); console.log(step2); step2.value.then(function (num2) { it.next(num2); }); }); // 结果： // { value: Promise {  }, done: false } // Promise resolved. // { value: Promise {  }, done: false } // Promise resolved. // Number: 2 这个例子还比较好理解：每次调用 it.next() 都会 立即 返回一个 Promise 对象，但是该对象内部的状态为 pending ，因此之后调用该 Promise 对象的 then() 方法等待对象状态改变。这里有一点很关键，在 Promise 对象中， resolve() 方法传出的值，会被 then() 方法参数中的函数接受，随后再传入到 it.next() 中。\n但是仔细看看，控制 Generator 函数的流程依旧是层层嵌套的，有没有办法解决这个问题？上例中，嵌套控制的部分每一层的结构基本是一致的，因此我们可以用递归函数实现它：\n// Generator函数自动执行器 function runGenerator(generator) { // 取得Generator遍历器  var it = generator(); var retVal; // 异步迭代该遍历器  (function iterate(val) { retVal = it.next(val); console.log(retVal); // 当迭代未完成，就继续执行  if (!retVal.done) { if (\"then\" in retVal.value) { // 等待Promise对象状态改变，随后递归调用自身，重新迭代。同时Promise传出的值传入到函数iterate中  retVal.value.then(iterate); } else { // 非Promise对象，立即执行下一步迭代  // 避免同步递归调用  setTimeout(function () { iterate(retVal.value); }, 0); } } })(); } runGenerator(main); // 结果： // { value: Promise {  }, done: false } // Promise resolved. // { value: Promise {  }, done: false } // Promise resolved. // Number: 2 // { value: undefined, done: true } runGenerator() 函数传入一个 Generator 函数作为参数并取得它的遍历器，随后在 iterate() 函数中进行迭代。如果 yield 表达式返回了一个 Promise 对象，就等待其执行完毕再递归迭代，否则立即执行下一步迭代。注意到在 else 语句中使用了一个 setTimeout() 语句，在这里我们不能立即执行 it.next() 函数，否则会报错。因为当前线程仍在 Generator 函数中（yield 表达式没有计算完毕），Generator 函数不在暂停状态。而 setTimeout() 语句会在该线程执行完毕后立即执行。\n当然，在 yield 表达式中，完全可以不用返回 Promise 对象，而是自行编写异步代码，但是使用 Promise 来管理 Generator 函数中异步调用部分的代码，有许许多多的优势：\n Promise 拥有内置的错误处理机制。在上面的例子中没有展现出来，这并不难做到：Promise 监听到错误后状态变为 rejected，随后可以在 runGenerator() 函数中使用 try/catch 处理，或者使用 it.throw() 将错误抛出。 我们通过 Promise 强大的 API 来控制所有的流程。 可以利用 Promise 处理各种复杂的“并行”任务。例如，使用 yield Promise.all([...]) 或者 yield Promise.race([...]) 接收一个“并行”任务的 Promise，随后就可以根据该 Promise 进行流程控制。  我们把上面的例子稍作改动，看看 yield Promise.all([...]) 如何使用：\nfunction request(num) { // 注意：返回的是一个Promise对象  return new Promise(function (resolve, reject) { setTimeout(function () { num += 1; // 返回新num值  console.log(\"Promise resolved, num = \" + num); resolve(num); }, 1000 + num); }); } function* main() { var ret1 = yield Promise.all([request(100), request(300), request(200)]); var ret2 = yield request(ret1[0] + ret1[1] + ret1[2]); console.log(\"Number: \" + ret2); } // Generator函数自动执行器 function runGenerator(generator) { // ...code  // 与上文一致 } runGenerator(main); // 结果： // { value: Promise {  }, done: false } // Promise resolved, num = 101 // Promise resolved, num = 201 // Promise resolved, num = 301 // { value: Promise {  }, done: false } // Promise resolved, num = 604 // Number: 604 // { value: undefined, done: true } 注意以下两点：\n 第一个 yield 表达式传入了 Promise.all(...]) ，立即返回一个新的 Promise 对象，该对象的状态根据传入的三个 Promise 对象决定，不懂的话可以参考我的上一篇博客。 我把 request() 方法中的 setTimeout() 时间参数改为 1000 + num ，这样可以从结果清晰的看出三个 Promise 对象中的异步任务是并发执行的。  async 函数 使用 Generator 函数进行异步开发时，需要有一个 Generator 函数自动执行器来实现上面介绍的 Generator+Promise 模式。目前网上有许多开源库提供了这样的工具，例如 co 模块 。\nES2017 标准引入了 async 函数，其中最重要的一点是 async 函数内置 Generator 函数自动执行器。也就是说，它可以自动地执行 Promise（或者异步函数）并在它们执行完后恢复运行。\nasync 函数基本用法 我们将上文的例子改成使用 async 函数来实现：\nfunction request(num) { // 注意：返回的是一个Promise对象  return new Promise(function (resolve, reject) { setTimeout(function () { num += 1; // 返回新num值  console.log(\"Promise resolved, num = \" + num); resolve(num); }, 1000 + num); }); } async function main() { var ret1 = await Promise.all([request(100), request(300), request(200)]); var ret2 = await request(ret1[0] + ret1[1] + ret1[2]); console.log(\"Number: \" + ret2); } main(); // 结果： // Promise resolved, num = 101 // Promise resolved, num = 201 // Promise resolved, num = 301 // Promise resolved, num = 604 // Number: 604 从语法上看，async 函数与 Generator 函数的区别只有两点：\n * 标识符换成了 async 关键字，表示这是一个 async 函数。 yield 关键字换成了 await 关键字，它会告诉 async 函数需要在这里等待 Promise 完成之后继续运行。  其实，async 函数完全可以看作多个异步操作所包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。\n总结 Generator 函数与 Promise 对象结合起来的模式功能已经足够强大，可以利用它们自如的控制同步、异步流程。并且现在许多开源库提供了 Generator 函数自动执行器，其中还包含了错误处理机制，我们可以很方便的进行运用。\nasync 函数已经在 ES2017 标准中加入，未来将会成为（也许现在已经是）JavaScript 异步控制的主流方案。\n",
  "wordCount" : "1426",
  "inLanguage": "zh",
  "datePublished": "2020-11-18T20:00:00+08:00",
  "dateModified": "2020-11-18T20:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "ruihusky"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ruihusky.github.io/ruihusky/posts/2020-11-18_js-async-function/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ruihusky's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ruihusky.github.io/ruihusky/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ruihusky.github.io/ruihusky/" accesskey="h" title="ruihusky&#39;s Blog (Alt + H)">ruihusky&#39;s Blog</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://ruihusky.github.io/ruihusky/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      JavaScript异步编程：Generator函数与Async函数
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">

November 18, 2020&nbsp;·&nbsp;ruihusky

    </div>
  </header> 

  <div class="toc">
    <details >
      <summary accesskey="c" title="(Alt + C)">
        <div class="details">目录</div>
      </summary>
      <blockquote><ul><li>
        <a href="#generator-%e5%87%bd%e6%95%b0%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="Generator 函数基本概念">Generator 函数基本概念</a><ul>
            <li>
        <a href="#%e5%85%b3%e4%ba%8e%e5%8d%8f%e7%a8%8b" aria-label="关于协程">关于协程</a></li><li>
        <a href="#%e8%bf%90%e8%a1%8c-%e5%ae%8c%e6%88%90" aria-label="运行-完成">运行-完成</a></li><li>
        <a href="#%e8%bf%90%e8%a1%8c-%e5%81%9c%e6%ad%a2-%e8%bf%90%e8%a1%8c" aria-label="运行-停止-运行">运行-停止-运行</a></li><li>
        <a href="#generator-%e5%87%bd%e6%95%b0%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95" aria-label="Generator 函数基本语法">Generator 函数基本语法</a></li><li>
        <a href="#generator-%e5%87%bd%e6%95%b0%e8%bf%90%e8%a1%8c%e6%8e%a7%e5%88%b6" aria-label="Generator 函数运行控制">Generator 函数运行控制</a></li><li>
        <a href="#generator-%e9%81%8d%e5%8e%86%e5%99%a8%e5%af%b9%e8%b1%a1" aria-label="Generator 遍历器对象">Generator 遍历器对象</a></li><li>
        <a href="#forof-%e5%be%aa%e7%8e%af" aria-label="for&amp;hellip;of 循环">for&hellip;of 循环</a></li><li>
        <a href="#generator-%e5%87%bd%e6%95%b0%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" aria-label="Generator 函数错误处理">Generator 函数错误处理</a></li><li>
        <a href="#generator-%e5%87%bd%e6%95%b0%e5%a7%94%e6%89%98" aria-label="Generator 函数委托">Generator 函数委托</a></li></ul>
    </li><li>
        <a href="#generator-%e5%87%bd%e6%95%b0%e7%9a%84%e5%bc%82%e6%ad%a5%e5%ba%94%e7%94%a8" aria-label="Generator 函数的异步应用">Generator 函数的异步应用</a><ul>
            <li>
        <a href="#generator-%e4%b8%8e-promise-%e7%9a%84%e7%bb%93%e5%90%88" aria-label="Generator 与 Promise 的结合">Generator 与 Promise 的结合</a></li></ul>
    </li><li>
        <a href="#async-%e5%87%bd%e6%95%b0" aria-label="async 函数">async 函数</a><ul>
            <li>
        <a href="#async-%e5%87%bd%e6%95%b0%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95" aria-label="async 函数基本用法">async 函数基本用法</a></li></ul>
    </li><li>
        <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
      </blockquote>
    </details>
  </div>
  <div class="post-content">
<h2 id="generator-函数基本概念">Generator 函数基本概念<a hidden class="anchor" aria-hidden="true" href="#generator-函数基本概念">#</a></h2>
<h3 id="关于协程">关于协程<a hidden class="anchor" aria-hidden="true" href="#关于协程">#</a></h3>
<p>首先我们要讨论的是 Generator 函数和普通函数在运行方式上有什么区别。</p>
<h3 id="运行-完成">运行-完成<a hidden class="anchor" aria-hidden="true" href="#运行-完成">#</a></h3>
<p>对于一个普通函数而言，一旦函数开始运行，除非运行完毕，否则其余的 JS 代码无法运行。这句话应该如何理解？看一个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hello World&#34;</span>);
}, <span style="color:#ae81ff">1</span>);

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#75715e">// 提示: 最好不要尝试这样的迭代
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#a6e22e">e10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>);
  }
}

<span style="color:#a6e22e">foo</span>();
<span style="color:#75715e">// 0..1E10
</span><span style="color:#75715e">// &#34;Hello World&#34;
</span></code></pre></div><p>在这个例子中，<code>foo()</code> 函数的运行时间超过了 1ms，但是 Hello World 出现在了最后面。所以，在 <code>foo()</code> 函数运行过程中，上面的 <code>setTimeout()</code> 函数不会被运行，直到 <code>foo()</code> 函数运行结束。</p>
<h3 id="运行-停止-运行">运行-停止-运行<a hidden class="anchor" aria-hidden="true" href="#运行-停止-运行">#</a></h3>
<p><strong>Generator 函数允许在运行的过程中暂停一次或多次，随后再恢复运行。暂停的过程中允许其它的代码执行</strong>。</p>
<p>这里引申到 <strong>协程（coroutine）</strong> 的概念。可以这么理解：一个进程（这里可以将它理解为一个 function）本身可以选择何时被中断以便与其它代码进行协作。</p>
<p>在 ES6 中，Generator 函数使用协程来进行并发操作。在 Generator 函数体内，通过使用新的 <code>yield</code> 关键字从内部将函数的运行打断。除了 Generator 函数内部的 <code>yield</code> 关键字，你不可能从任何地方（包括函数外部）中断函数的运行。</p>
<p>一旦 Generator 函数被中断，它不可能自行恢复运行，除非通过外部的控制来重新该函数。稍后会介绍如何做到这一点。</p>
<p>更重要的一点是，<strong>Generator 函数的执行，允许信息的双向传递</strong>。普通函数在开始的时候获取参数，在结束的时候返回一个值，而 Generator 函数可以在每次 <code>yield</code> 的时候返回值，并且在下一次重新启动的时候再传入值。这样就能完美实现各线程之间的通信。</p>
<h3 id="generator-函数基本语法">Generator 函数基本语法<a hidden class="anchor" aria-hidden="true" href="#generator-函数基本语法">#</a></h3>
<p>看一个简单例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">helloWorldGenerator</span>() {
  <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#34;world&#34;</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;ending&#34;</span>;
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">hw</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">helloWorldGenerator</span>();
</code></pre></div><p>与普通函数相比，例子中多了一个 <code>*</code> 来进行标示，表示这是一个 Generator 函数。另外，函数体内有关键字 <code>yield</code> ，称作 yield 表达式。</p>
<p>那么，yield 表达式的作用是什么？有两点：</p>
<ol>
<li>每次函数中断时将 yield 表达式的结果输出。</li>
<li>重新启动函数时，传入的值会作为 yield 表达式计算的结果。</li>
</ol>
<p>举例说明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#34;foo&#34;</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>);
}
</code></pre></div><p>在 <code>foo()</code> 函数暂停时，<code>yield &quot;foo&quot;</code> 表达式会返回字符串&quot;foo&quot;，下一次 <code>foo()</code> 函数重新启动时，传入的值会代替 <code>yield &quot;foo&quot;</code> ，结果就是将 <strong>1 + 传入值</strong> 的结果赋值给 <code>x</code>。</p>
<h3 id="generator-函数运行控制">Generator 函数运行控制<a hidden class="anchor" aria-hidden="true" href="#generator-函数运行控制">#</a></h3>
<h3 id="generator-遍历器对象">Generator 遍历器对象<a hidden class="anchor" aria-hidden="true" href="#generator-遍历器对象">#</a></h3>
<p>执行 Generator 函数会返回一个遍历器对象，该遍历器对象可以依次遍历 Generator 函数内部的每一个状态。这听起来好像有点复杂，考虑下面这个简单的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">4</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">5</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">6</span>;
}
<span style="color:#75715e">// 返回了遍历器对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">foo</span>();
<span style="color:#75715e">// 第一次通过next()调用，返回第一个yield的值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">message</span>); <span style="color:#75715e">// { value:1, done:false }
</span><span style="color:#75715e">// 事实上每次调用next()方法都会返回一个object对象，其中的value属性就是yield表达式返回的值。
</span><span style="color:#75715e">// 属性done是一个boolean类型，用来表示对Generator函数的遍历是否已经结束。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// { value:2, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// { value:3, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// { value:4, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// { value:5, done:false }
</span><span style="color:#75715e">// 这里注意到，执行到yield 5时，done属性依然是false。
</span><span style="color:#75715e">// 这是因为从技术上来说，Generator函数还没有执行完。
</span><span style="color:#75715e">// 我们必须再调用一次next()方法，然后Generator函数才算执行完毕。
</span><span style="color:#75715e">// 注意到最后一次的value是return语句的返回值。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// { value:6, done:true }
</span></code></pre></div><p>仔细看完上面的例子，相信已经可以理解 Generator 函数运行控制的基本概念了。这里还没有涉及到值的传入，给一个稍微复杂的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">x</span>) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">z</span>;
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">foo</span>(<span style="color:#ae81ff">5</span>);

<span style="color:#75715e">// 注意这里在调用next()方法时没有传入任何值
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>()); <span style="color:#75715e">// { value:6, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">12</span>)); <span style="color:#75715e">// { value:8, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">13</span>)); <span style="color:#75715e">// { value:42, done:true }
</span></code></pre></div><p>这里解释一下上面的例子中发生了什么：</p>
<ol>
<li>构造 Generator 函数遍历器的时候，通过语句 foo(5)，我们将参数 x 的值设置为 5。</li>
<li>第一次调用 next()方法时，没有传入任何值。因为此时没有 yield 表达式来接收我们传入的值。如果在第一次调用 next()方法时传入一个值，也不会有任何影响，该值会被抛弃掉。按照 ES6 标准的规定，此时 Generator 函数会直接忽略掉该值。</li>
<li>表达式 <code>yield(x + 1)</code> 的返回值是 6，然后第二个 <code>next(12)</code> 将 12 作为参数传入，用来代替表达式 <code>yield(x + 1)</code> ，因此变量 y 的值就是 12 * 2 = 24。随后的 <code>yield(y / 3)</code>（即 <code>yield(24 / 3)</code> ）返回值 8。然后第三个 <code>next(13)</code> 将 13 作为参数传入，用来代替表达式 <code>yield(y / 3)</code> ，所以变量 z 的值是 13。</li>
<li>最后，语句 <code>return (x + y + z)</code> 即 <code>return (5 + 24 + 13)</code> ，所以最终的返回值是 42。</li>
</ol>
<h3 id="forof-循环">for&hellip;of 循环<a hidden class="anchor" aria-hidden="true" href="#forof-循环">#</a></h3>
<p>ES6 从语法层面上对遍历器提供了直接的支持，即 for&hellip;of 循环。因此 Generator 函数遍历器也可以使用下面的方式进行循环控制：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">4</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">5</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">6</span>;
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">foo</span>()) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">v</span>);
}
<span style="color:#75715e">// 1 2 3 4 5
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">v</span>); <span style="color:#75715e">// 仍然是5，而不是6
</span></code></pre></div><p>注意到，for&hellip;of 循环忽略并抛弃了返回值 6，这是因为此处没有对应的 <code>next()</code> 方法被调用，另外，for&hellip;of 循环不支持将值传递到 Generator 函数内。</p>
<h3 id="generator-函数错误处理">Generator 函数错误处理<a hidden class="anchor" aria-hidden="true" href="#generator-函数错误处理">#</a></h3>
<p>ES6 Generators 函数内部的代码是同步的，即使在 Generator 函数外部控制是异步进行的。也就是说，你可以使用任何你所熟悉的错误处理机制来简单地在 Generator 函数中处理错误，例如使用 <code>try/catch</code> 机制。
来看一个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;x: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>);
  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Error: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">err</span>);
  }
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">foo</span>();

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value:3, done:false }
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这里我们不调用next()方法，而直接抛出一个异常：
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#e6db74">&#34;Oops!&#34;</span>); <span style="color:#75715e">// Error: Oops!
</span></code></pre></div><p>这里我们使用了另一个方法 <code>throw()</code>，它会在 Generator 函数暂停的位置抛出一个错误，然后函数内部的 <code>try/catch</code> 语句捕获了这个错误。</p>
<p>如果函数内部没有 <code>try/catch</code> 语句，会发生什么？错误因为没有被任何代码捕获，会被当作一个未处理的异常向上抛出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">foo</span>();
<span style="color:#66d9ef">try</span> {
  <span style="color:#a6e22e">it</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#e6db74">&#34;Oops!&#34;</span>);
} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Error: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">err</span>); <span style="color:#75715e">// Error: Oops!
</span><span style="color:#75715e"></span>}
</code></pre></div><p>很显然，如果在 Generator 函数内部发生的错误没有被捕获，也会被向上抛出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// 可能会引发类型错误！
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">y</span>;
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">foo</span>();

<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value:3, done:false }
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">try</span> {
  <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">42</span>); <span style="color:#75715e">// 42没有toUpperCase()方法
</span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">err</span>); <span style="color:#75715e">// toUpperCase()引发TypeError错误
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="generator-函数委托">Generator 函数委托<a hidden class="anchor" aria-hidden="true" href="#generator-函数委托">#</a></h3>
<p>在一个 Generator 函数体内，可以调用另一个 Generator 函数，实际上是将当前 Generator 函数的迭代控制 <strong>委托</strong> 给另一个 Generator 函数。我们通过关键字 <code>yield *</code> 来实现。看下面的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">4</span>;
}

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">bar</span>() {
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>;
  <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>(); <span style="color:#75715e">// `yield *` 将当前函数的迭代控制委托给另一个Generator函数foo()
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">5</span>;
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">bar</span>()) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">v</span>);
}
<span style="color:#75715e">// 1 2 3 4 5
</span></code></pre></div><p>在关键字 <code>yield *</code> 的位置，程序将迭代控制委托给另一个 Generator 函数 <code>foo()</code>，随后 <code>for...of</code> 循环将通过 <code>next()</code> 方法遍历 <code>foo()</code>。当对 <code>foo()</code> 的遍历结束后，委托控制又重新回到之前的 Generator 函数。</p>
<p>不使用 <code>for...of</code> 循环，通过 <code>next()</code> 方法控制并传入相应的值来进行遍历，这些传入的值也会通过 <code>yield *</code> 关键字传递给对应的 yield 表达式中。另外，<code>yield *</code> 表达式可以接收被委托的 Generator 函数的返回值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">4</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;z: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">z</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, w: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">w</span>);
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;foo&#34;</span>;
}

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">bar</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>;
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>(); <span style="color:#75715e">// `yield*` 将控制权委托给 `foo()`，并且接受了字符串`foo`
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;f: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">f</span>);
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">5</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;x: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, y: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, v: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>);
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">bar</span>();

<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value:1, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#e6db74">&#34;X&#34;</span>); <span style="color:#75715e">// { value:2, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#e6db74">&#34;Y&#34;</span>); <span style="color:#75715e">// { value:3, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#e6db74">&#34;Z&#34;</span>); <span style="color:#75715e">// { value:4, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#e6db74">&#34;W&#34;</span>); <span style="color:#75715e">// { value:5, done:false },f=&#34;foo&#34;
</span><span style="color:#75715e">// z: Z, w: W
</span><span style="color:#75715e">// f: foo
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#e6db74">&#34;V&#34;</span>); <span style="color:#75715e">// { value:undefined, done:true }
</span><span style="color:#75715e">// x: X, y: Y, v: V
</span></code></pre></div><p>对于<code>yield *</code> 表达式中的错误传递，道理也很简单：在被委托函数内的错误如果未被捕获，就会抛出到委托函数中。若在委托函数中仍未被处理，就会继续向上抛出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>;
  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;foo caught: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">err</span>);
  }

  <span style="color:#66d9ef">yield</span>; <span style="color:#75715e">// 暂停
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 抛出一个错误
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">throw</span> <span style="color:#e6db74">&#34;Oops!&#34;</span>;
}

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">bar</span>() {
  <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">foo</span>();
  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;bar caught: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">err</span>);
  }
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">bar</span>();

<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value:1, done:false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value:2, done:false }
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">it</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#e6db74">&#34;Uh oh!&#34;</span>); <span style="color:#75715e">// 将会被foo()中的try..catch捕获
</span><span style="color:#75715e">// foo caught: Uh oh!
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value:undefined, done:true } --&gt; 注意这里不会出现错误！
</span><span style="color:#75715e">// bar caught: Oops!
</span></code></pre></div><h2 id="generator-函数的异步应用">Generator 函数的异步应用<a hidden class="anchor" aria-hidden="true" href="#generator-函数的异步应用">#</a></h2>
<p>前文所述所有对 Generator 函数的控制都是同步执行的，现在来看看如何利用 Generator 函数开发异步应用。</p>
<h3 id="generator-与-promise-的结合">Generator 与 Promise 的结合<a hidden class="anchor" aria-hidden="true" href="#generator-与-promise-的结合">#</a></h3>
<p>从这里开始理解起来会稍有困难，我的建议是自己动手去运行一下这些实例，有助于加快理解。最新的 <a href="http://nodejs.cn/">Node.js</a> 环境已经支持所有示例。</p>
<p>设想一下：yield 表达式返回了一个 Promise 对象。之后我们可以做些什么动作？我们可以通过 Promise 对象的状态（resolved/rejected）来对 Generator 函数的流程进行控制。</p>
<p>先从一个简单一点的例子说起：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">num</span>) {
  <span style="color:#75715e">// 注意：返回的是一个Promise对象
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
      <span style="color:#a6e22e">num</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
      <span style="color:#75715e">// 返回新num值
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Promise resolved.&#34;</span>);
      <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">num</span>);
    }, <span style="color:#ae81ff">1000</span>);
  });
}

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">ret1</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Number: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret2</span>);
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">main</span>();

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">step1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>();
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">step1</span>);
<span style="color:#a6e22e">step1</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">num</span>) {
  <span style="color:#a6e22e">step2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">num</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">step2</span>);
  <span style="color:#a6e22e">step2</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">num2</span>) {
    <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">num2</span>);
  });
});

<span style="color:#75715e">// 结果：
</span><span style="color:#75715e">// { value: Promise { &lt;pending&gt; }, done: false }
</span><span style="color:#75715e">// Promise resolved.
</span><span style="color:#75715e">// { value: Promise { &lt;pending&gt; }, done: false }
</span><span style="color:#75715e">// Promise resolved.
</span><span style="color:#75715e">// Number: 2
</span></code></pre></div><p>这个例子还比较好理解：每次调用 <code>it.next()</code> 都会 <strong>立即</strong> 返回一个 Promise 对象，但是该对象内部的状态为 <code>pending</code> ，因此之后调用该 Promise 对象的 <code>then()</code> 方法等待对象状态改变。这里有一点很关键，在 Promise 对象中， <code>resolve()</code> 方法传出的值，会被 <code>then()</code> 方法参数中的函数接受，随后再传入到 <code>it.next()</code> 中。</p>
<p>但是仔细看看，控制 Generator 函数的流程依旧是层层嵌套的，有没有办法解决这个问题？上例中，嵌套控制的部分每一层的结构基本是一致的，因此我们可以用递归函数实现它：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// Generator函数自动执行器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runGenerator</span>(<span style="color:#a6e22e">generator</span>) {
  <span style="color:#75715e">// 取得Generator遍历器
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>();
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">retVal</span>;
  <span style="color:#75715e">// 异步迭代该遍历器
</span><span style="color:#75715e"></span>  (<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">iterate</span>(<span style="color:#a6e22e">val</span>) {
    <span style="color:#a6e22e">retVal</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">val</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">retVal</span>);
    <span style="color:#75715e">// 当迭代未完成，就继续执行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">retVal</span>.<span style="color:#a6e22e">done</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#34;then&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">retVal</span>.<span style="color:#a6e22e">value</span>) {
        <span style="color:#75715e">// 等待Promise对象状态改变，随后递归调用自身，重新迭代。同时Promise传出的值传入到函数iterate中
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">retVal</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">iterate</span>);
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 非Promise对象，立即执行下一步迭代
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 避免同步递归调用
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
          <span style="color:#a6e22e">iterate</span>(<span style="color:#a6e22e">retVal</span>.<span style="color:#a6e22e">value</span>);
        }, <span style="color:#ae81ff">0</span>);
      }
    }
  })();
}

<span style="color:#a6e22e">runGenerator</span>(<span style="color:#a6e22e">main</span>);

<span style="color:#75715e">// 结果：
</span><span style="color:#75715e">// { value: Promise { &lt;pending&gt; }, done: false }
</span><span style="color:#75715e">// Promise resolved.
</span><span style="color:#75715e">// { value: Promise { &lt;pending&gt; }, done: false }
</span><span style="color:#75715e">// Promise resolved.
</span><span style="color:#75715e">// Number: 2
</span><span style="color:#75715e">// { value: undefined, done: true }
</span></code></pre></div><p><code>runGenerator()</code> 函数传入一个 Generator 函数作为参数并取得它的遍历器，随后在 <code>iterate()</code> 函数中进行迭代。如果 yield 表达式返回了一个 Promise 对象，就等待其执行完毕再递归迭代，否则立即执行下一步迭代。注意到在 <code>else</code> 语句中使用了一个 <code>setTimeout()</code> 语句，在这里我们不能立即执行 <code>it.next()</code> 函数，否则会报错。因为当前线程仍在 Generator 函数中（yield 表达式没有计算完毕），Generator 函数不在暂停状态。而 <code>setTimeout()</code> 语句会在该线程执行完毕后立即执行。</p>
<p>当然，在 yield 表达式中，完全可以不用返回 Promise 对象，而是自行编写异步代码，但是使用 Promise 来管理 Generator 函数中异步调用部分的代码，有许许多多的优势：</p>
<ul>
<li>Promise 拥有内置的错误处理机制。在上面的例子中没有展现出来，这并不难做到：Promise 监听到错误后状态变为 rejected，随后可以在 <code>runGenerator()</code> 函数中使用 <code>try/catch</code> 处理，或者使用 <code>it.throw()</code> 将错误抛出。</li>
<li>我们通过 Promise 强大的 API 来控制所有的流程。</li>
<li>可以利用 Promise 处理各种复杂的“并行”任务。例如，使用 <code>yield Promise.all([...])</code> 或者 <code>yield Promise.race([...])</code> 接收一个“并行”任务的 Promise，随后就可以根据该 Promise 进行流程控制。</li>
</ul>
<p>我们把上面的例子稍作改动，看看 <code>yield Promise.all([...])</code> 如何使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">num</span>) {
  <span style="color:#75715e">// 注意：返回的是一个Promise对象
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
      <span style="color:#a6e22e">num</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
      <span style="color:#75715e">// 返回新num值
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Promise resolved, num = &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">num</span>);
      <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">num</span>);
    }, <span style="color:#ae81ff">1000</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">num</span>);
  });
}

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">100</span>), <span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">300</span>), <span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">200</span>)]);
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">ret1</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret1</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret1</span>[<span style="color:#ae81ff">2</span>]);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Number: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret2</span>);
}
<span style="color:#75715e">// Generator函数自动执行器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runGenerator</span>(<span style="color:#a6e22e">generator</span>) {
  <span style="color:#75715e">// ...code
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 与上文一致
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">runGenerator</span>(<span style="color:#a6e22e">main</span>);
<span style="color:#75715e">// 结果：
</span><span style="color:#75715e">// { value: Promise { &lt;pending&gt; }, done: false }
</span><span style="color:#75715e">// Promise resolved, num = 101
</span><span style="color:#75715e">// Promise resolved, num = 201
</span><span style="color:#75715e">// Promise resolved, num = 301
</span><span style="color:#75715e">// { value: Promise { &lt;pending&gt; }, done: false }
</span><span style="color:#75715e">// Promise resolved, num = 604
</span><span style="color:#75715e">// Number: 604
</span><span style="color:#75715e">// { value: undefined, done: true }
</span></code></pre></div><p>注意以下两点：</p>
<ol>
<li>第一个 yield 表达式传入了 <code>Promise.all(...])</code> ，立即返回一个新的 Promise 对象，该对象的状态根据传入的三个 Promise 对象决定，不懂的话可以参考我的上一篇博客。</li>
<li>我把 <code>request()</code> 方法中的 <code>setTimeout()</code> 时间参数改为 <code>1000 + num</code> ，这样可以从结果清晰的看出三个 Promise 对象中的异步任务是并发执行的。</li>
</ol>
<h2 id="async-函数">async 函数<a hidden class="anchor" aria-hidden="true" href="#async-函数">#</a></h2>
<p>使用 Generator 函数进行异步开发时，需要有一个 Generator 函数自动执行器来实现上面介绍的 Generator+Promise 模式。目前网上有许多开源库提供了这样的工具，例如 <a href="https://github.com/tj/co">co 模块</a> 。</p>
<p>ES2017 标准引入了 async 函数，其中最重要的一点是 <strong>async 函数内置 Generator 函数自动执行器</strong>。也就是说，它可以自动地执行 Promise（或者异步函数）并在它们执行完后恢复运行。</p>
<h3 id="async-函数基本用法">async 函数基本用法<a hidden class="anchor" aria-hidden="true" href="#async-函数基本用法">#</a></h3>
<p>我们将上文的例子改成使用 async 函数来实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">num</span>) {
  <span style="color:#75715e">// 注意：返回的是一个Promise对象
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
      <span style="color:#a6e22e">num</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
      <span style="color:#75715e">// 返回新num值
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Promise resolved, num = &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">num</span>);
      <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">num</span>);
    }, <span style="color:#ae81ff">1000</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">num</span>);
  });
}

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">100</span>), <span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">300</span>), <span style="color:#a6e22e">request</span>(<span style="color:#ae81ff">200</span>)]);
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">ret1</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret1</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret1</span>[<span style="color:#ae81ff">2</span>]);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Number: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">ret2</span>);
}

<span style="color:#a6e22e">main</span>();
<span style="color:#75715e">// 结果：
</span><span style="color:#75715e">// Promise resolved, num = 101
</span><span style="color:#75715e">// Promise resolved, num = 201
</span><span style="color:#75715e">// Promise resolved, num = 301
</span><span style="color:#75715e">// Promise resolved, num = 604
</span><span style="color:#75715e">// Number: 604
</span></code></pre></div><p>从语法上看，async 函数与 Generator 函数的区别只有两点：</p>
<ol>
<li><code>*</code> 标识符换成了 <code>async</code> 关键字，表示这是一个 async 函数。</li>
<li><code>yield</code> 关键字换成了 <code>await</code> 关键字，它会告诉 async 函数需要在这里等待 Promise 完成之后继续运行。</li>
</ol>
<p>其实，async 函数完全可以看作多个异步操作所包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>Generator 函数与 Promise 对象结合起来的模式功能已经足够强大，可以利用它们自如的控制同步、异步流程。并且现在许多开源库提供了 Generator 函数自动执行器，其中还包含了错误处理机制，我们可以很方便的进行运用。</p>
<p>async 函数已经在 ES2017 标准中加入，未来将会成为（也许现在已经是）JavaScript 异步控制的主流方案。</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ruihusky.github.io/ruihusky/tags/javascript/">JavaScript</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>ruihusky&rsquo;s Blog</span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/ruihusky/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
