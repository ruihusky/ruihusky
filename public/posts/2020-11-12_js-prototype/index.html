<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JavaScript原型与继承 | ruihusky&#39;s Blog</title>

<meta name="keywords" content="JavaScript" />
<meta name="description" content="理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：
function Person() {} Person.prototype.name = &#34;Nicholas&#34;; Person.prototype.age = 29; Person.prototype.job = &#34;Software Engineer&#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); person1.sayName(); // &#34;Nicholas&#34; var person2 = new Person(); person2.sayName(); // &#34;Nicholas&#34; alert(person1.sayName == person2.sayName); // true 原型搜索机制 访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 delete 删除实例对象属性即可。下面是例子：
function Person() {} Person.prototype.name = &#34;Nicholas&#34;; Person.prototype.age = 29; Person.prototype.job = &#34;Software Engineer&#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.">
<meta name="author" content="ruihusky">
<link rel="canonical" href="https://ruihusky.github.io/ruihusky/posts/2020-11-12_js-prototype/" />
<link href="/ruihusky/assets/css/stylesheet.min.3b4ed2e80185ab356f837eda72c1debdea24ca2d707d78b82f2534624843aaa0.css" integrity="sha256-O07S6AGFqzVvg37acsHeveokyi1wfXi4LyU0YkhDqqA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://ruihusky.github.io/ruihusky/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ruihusky.github.io/ruihusky/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ruihusky.github.io/ruihusky/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ruihusky.github.io/ruihusky/apple-touch-icon.png">
<link rel="mask-icon" href="https://ruihusky.github.io/ruihusky/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="JavaScript原型与继承" />
<meta property="og:description" content="理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：
function Person() {} Person.prototype.name = &#34;Nicholas&#34;; Person.prototype.age = 29; Person.prototype.job = &#34;Software Engineer&#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); person1.sayName(); // &#34;Nicholas&#34; var person2 = new Person(); person2.sayName(); // &#34;Nicholas&#34; alert(person1.sayName == person2.sayName); // true 原型搜索机制 访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 delete 删除实例对象属性即可。下面是例子：
function Person() {} Person.prototype.name = &#34;Nicholas&#34;; Person.prototype.age = 29; Person.prototype.job = &#34;Software Engineer&#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ruihusky.github.io/ruihusky/posts/2020-11-12_js-prototype/" />
<meta property="article:published_time" content="2020-11-12T20:00:00+08:00" />
<meta property="article:modified_time" content="2020-11-12T20:00:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JavaScript原型与继承"/>
<meta name="twitter:description" content="理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：
function Person() {} Person.prototype.name = &#34;Nicholas&#34;; Person.prototype.age = 29; Person.prototype.job = &#34;Software Engineer&#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); person1.sayName(); // &#34;Nicholas&#34; var person2 = new Person(); person2.sayName(); // &#34;Nicholas&#34; alert(person1.sayName == person2.sayName); // true 原型搜索机制 访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 delete 删除实例对象属性即可。下面是例子：
function Person() {} Person.prototype.name = &#34;Nicholas&#34;; Person.prototype.age = 29; Person.prototype.job = &#34;Software Engineer&#34;; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript原型与继承",
  "name": "JavaScript原型与继承",
  "description": "理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：\nfunction Person() {} Person.prototype.name = \u0026amp;#34;Nicholas\u0026amp;#34;; …",
  "keywords": [
    "JavaScript"
  ],
  "articleBody": "理解原型对象 在 JavaScript 中，创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：\nfunction Person() {} Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); person1.sayName(); // \"Nicholas\" var person2 = new Person(); person2.sayName(); // \"Nicholas\" alert(person1.sayName == person2.sayName); // true 原型搜索机制 访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 delete 删除实例对象属性即可。下面是例子：\nfunction Person() {} Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function () { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.name = \"Greg\"; alert(person1.name); // \"Greg\"--来自实例 alert(person2.name); // \"Nicholas\"--来自原型  delete person1.name; alert(person1.name); // \"Nicholas\"--来自原型 继承 ECMAScript 中描述了 原型链 的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。实现原型链的一种基本模式是让 原型对象等于另一个类型的实例。这么说比较抽象，先看一段代码：\nfunction SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function () { return this.property; }; function SubType() { this.subProperty = false; } // 继承了SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subProperty; }; var instance = new SubType(); alert(instance.getSuperValue()); // true 以上代码定义了 SuperType、SubType 两个类型，他们分别有自己的属性和方法。通过重写 Subtype 的原型对象（让其等于 SuperType 的实例），可以让存在于 SuperType 实例中的所有属性和方法在 SubType.prototype 访问到。\n结合上文的原型搜索机制来理解：访问一个实例属性时，首先在实例中搜索该属性。如果没有找到则会继续搜索该实例的原型。通过原型链实现继承后，搜索过程就会沿着原型链继续向上。拿上面的例子来说，调用 instance.getSuperValue() 的过程如下：\n搜索实例 – 搜索SubType.prototype– 搜索SuperType.prototype\n另外，所有的默认原型都是 Object 的实例。因此可以这么概括：SubType 继承自 SuperType ，SuperType 继承自 Object。\n原型链的问题 使用原型链实现继承，最主要的问题是包含引用类型值的原型。举例来说：\nfunction SuperType() { this.colors = [\"red\", \"blue\", \"green\"]; } function SubType() {} // 继承了SuperType SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); // \"red,blue,green,black\"  var instance2 = new SubType(); alert(instance2.colors); // \"red,blue,green,black\" 可以看到，对 instance1.colors 所做的修改，会在 instance2 反映出来。\n原型链的第二个问题是：创建子类实例时，无法向超类的构造函数传递参数。\n为了解决这些问题，通常会使用下面这些技术来实现继承。\n组合继承 通过将原型链和借用构造函数技术相结合达到目的。使用原型链实现对原型属性、方法的继承，通过借用构造函数实现对实例属性的继承。\nfunction SuperType(name) { this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function () { alert(this.name); }; function SubType(name, age) { // 继承属性，通过call()函数在实例内部创建属性  SuperType.call(this, name); this.age = age; } // 继承方法，来自子类原型对象的原型对象-也就是超类原型对象 SubType.prototype = new SuperType(); // 默认情况下，所有原型对象会自动获得一个constructor（构造函数）属性，指向原型对象所在函数。 // 覆写的prototype对象没有constructor属性，需要重新指定。 SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function () { alert(this.age); }; var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); alert(instance1.colors); // \"red,blue,green,black\" instance1.sayName(); // \"Nicholas\"; instance1.sayAge(); // 29  var instance2 = new SubType(\"Greg\", 27); alert(instance2.colors); // \"red,blue,green\" instance2.sayName(); // \"Greg\"; instance2.sayAge(); // 27 在这个例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 超类实例直接赋值给子类原型，Subtype.prototype 也有 name、colors 属性。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  这种继承方式是 JavaScript 中最为常见的继承模式。并且 instanceof 和 isPrototypeOf() 也能够用于识别子类实例。但是可以看到，子类的原型有多余的属性。接下来的继承方式则解决了这个问题。\n寄生组合式继承 这里可能稍微有些复杂，先看其基本模式：\n// 这里是原型式继承-通过该函数，将实例的原型指定为对象o，从而拥有o的属性。 function object(o) { function F() {} F.prototype = o; return new F(); } // 寄生组合式继承基本模式 // 接受两个参数：子类构造函数、超类构造函数 function inheritPrototype(subType, superType) { // 创建prototype对象，目的是准备把它当成子类的原型。同时该prototype对象的原型是超类原型。  var prototype = object(superType.prototype); //创建对象  // 覆写的prototype对象没有constructor属性，需要重新指定。  prototype.constructor = subType; // 将prototype对象赋值给子类原型  subType.prototype = prototype; } 基本想法就是自行创建子类的原型对象，同时将该原型对象的原型指向超类原型。这样一来子类只继承了超类的原型，而与超类实例无关。 下面看一个更加具体的例子加深理解：\nfunction SuperType(name) { this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; } SuperType.prototype.sayName = function () { alert(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function () { alert(this.age); }; 在上面的例子中，通过子类创建的实例会包含下列属性、方法：\n name、colors 通过 SuperType.call() 创建，它们属于子类实例。 age 通过 SubType 构造函数创建，属于子类实例。 sayName() 方法继承自超类原型。 sayAge() 方法来自子类原型。  与上述组合继承方式相比，这种继承方式避免了在 SubType.prototype 上创建多余的属性，同时保持了原型链不变。\n",
  "wordCount" : "422",
  "inLanguage": "zh",
  "datePublished": "2020-11-12T20:00:00+08:00",
  "dateModified": "2020-11-12T20:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "ruihusky"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ruihusky.github.io/ruihusky/posts/2020-11-12_js-prototype/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ruihusky's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ruihusky.github.io/ruihusky/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ruihusky.github.io/ruihusky/" accesskey="h" title="ruihusky&#39;s Blog (Alt + H)">ruihusky&#39;s Blog</a>
            <span class="logo-switches">
                <a id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </a>
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://ruihusky.github.io/ruihusky/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
<div class="breadcrumbs">

    <a href="https://ruihusky.github.io/ruihusky/">Home</a>&nbsp;»&nbsp;<a href="https://ruihusky.github.io/ruihusky/posts/">Posts</a>
</div>

    <h1 class="post-title">
      JavaScript原型与继承
    </h1>
    <div class="post-meta">

November 12, 2020&nbsp;·&nbsp;ruihusky

</div>
  </header> 

  <div class="toc">
    <details >
      <summary accesskey="c" title="(Alt + C)">
        <div class="details">目录</div>
      </summary>
      <div class="inner"><ul><li>
        <a href="#%e7%90%86%e8%a7%a3%e5%8e%9f%e5%9e%8b%e5%af%b9%e8%b1%a1" aria-label="理解原型对象">理解原型对象</a></li><li>
        <a href="#%e5%8e%9f%e5%9e%8b%e6%90%9c%e7%b4%a2%e6%9c%ba%e5%88%b6" aria-label="原型搜索机制">原型搜索机制</a></li><li>
        <a href="#%e7%bb%a7%e6%89%bf" aria-label="继承">继承</a></li><li>
        <a href="#%e5%8e%9f%e5%9e%8b%e9%93%be%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="原型链的问题">原型链的问题</a></li><li>
        <a href="#%e7%bb%84%e5%90%88%e7%bb%a7%e6%89%bf" aria-label="组合继承">组合继承</a></li><li>
        <a href="#%e5%af%84%e7%94%9f%e7%bb%84%e5%90%88%e5%bc%8f%e7%bb%a7%e6%89%bf" aria-label="寄生组合式继承">寄生组合式继承</a></li></ul>
      </div>
    </details>
  </div>
  <div class="post-content">
<h2 id="理解原型对象">理解原型对象<a hidden class="anchor" aria-hidden="true" href="#理解原型对象">#</a></h2>
<p>在 JavaScript 中，创建的每个函数都有一个 <code>prototype</code> （原型）属性，这个属性是一个指针，指向原型对象。通过调用构造函数创建的所有对象实例都可以访问该原型对象。举例来说：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Person</span>() {}

<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Nicholas&#34;</span>;
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">29</span>;
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">job</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Software Engineer&#34;</span>;
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">person1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();
<span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">sayName</span>(); <span style="color:#75715e">// &#34;Nicholas&#34;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">person2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();
<span style="color:#a6e22e">person2</span>.<span style="color:#a6e22e">sayName</span>(); <span style="color:#75715e">// &#34;Nicholas&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">person2</span>.<span style="color:#a6e22e">sayName</span>); <span style="color:#75715e">// true
</span></code></pre></div><h2 id="原型搜索机制">原型搜索机制<a hidden class="anchor" aria-hidden="true" href="#原型搜索机制">#</a></h2>
<p>访问实例对象的属性时，会先从实例对象的属性找起，找不到再去原型对象中寻找。为实例对象添加属性会屏蔽对原型对象中同名属性的访问。要恢复对原型对象属性的访问，使用 <code>delete</code> 删除实例对象属性即可。下面是例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Person</span>() {}

<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Nicholas&#34;</span>;
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">29</span>;
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">job</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Software Engineer&#34;</span>;
<span style="color:#a6e22e">Person</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">person1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">person2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();

<span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Greg&#34;</span>;
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// &#34;Greg&#34;--来自实例
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">person2</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// &#34;Nicholas&#34;--来自原型
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">name</span>;
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">person1</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// &#34;Nicholas&#34;--来自原型
</span></code></pre></div><h2 id="继承">继承<a hidden class="anchor" aria-hidden="true" href="#继承">#</a></h2>
<p>ECMAScript 中描述了 <strong>原型链</strong> 的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。实现原型链的一种基本模式是让 <strong>原型对象等于另一个类型的实例</strong>。这么说比较抽象，先看一段代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SuperType</span>() {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">property</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
}

<span style="color:#a6e22e">SuperType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">getSuperValue</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">property</span>;
};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SubType</span>() {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">subProperty</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
}
<span style="color:#75715e">// 继承了SuperType
</span><span style="color:#75715e"></span><span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SuperType</span>();

<span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">getSubValue</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">subProperty</span>;
};
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SubType</span>();
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">getSuperValue</span>()); <span style="color:#75715e">// true
</span></code></pre></div><p>以上代码定义了 <code>SuperType</code>、<code>SubType</code> 两个类型，他们分别有自己的属性和方法。通过重写 <code>Subtype</code> 的原型对象（让其等于 <code>SuperType</code> 的实例），可以让存在于 <code>SuperType</code> 实例中的所有属性和方法在 <code>SubType.prototype</code> 访问到。</p>
<p>结合上文的原型搜索机制来理解：访问一个实例属性时，首先在实例中搜索该属性。如果没有找到则会继续搜索该实例的原型。通过原型链实现继承后，搜索过程就会沿着原型链继续向上。拿上面的例子来说，调用 <code>instance.getSuperValue()</code> 的过程如下：</p>
<p><strong>搜索实例 &ndash;&gt; 搜索<code>SubType.prototype</code>&ndash;&gt; 搜索<code>SuperType.prototype</code></strong></p>
<p>另外，所有的默认原型都是 <code>Object</code> 的实例。因此可以这么概括：<code>SubType</code> 继承自 <code>SuperType</code> ，<code>SuperType</code> 继承自 <code>Object</code>。</p>
<h2 id="原型链的问题">原型链的问题<a hidden class="anchor" aria-hidden="true" href="#原型链的问题">#</a></h2>
<p>使用原型链实现继承，最主要的问题是包含引用类型值的原型。举例来说：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SuperType</span>() {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">colors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;blue&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>];
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SubType</span>() {}

<span style="color:#75715e">// 继承了SuperType
</span><span style="color:#75715e"></span><span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SuperType</span>();

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SubType</span>();
<span style="color:#a6e22e">instance1</span>.<span style="color:#a6e22e">colors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;black&#34;</span>);
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">instance1</span>.<span style="color:#a6e22e">colors</span>); <span style="color:#75715e">// &#34;red,blue,green,black&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SubType</span>();
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">instance2</span>.<span style="color:#a6e22e">colors</span>); <span style="color:#75715e">// &#34;red,blue,green,black&#34;
</span></code></pre></div><p>可以看到，对 <code>instance1.colors</code> 所做的修改，会在 <code>instance2</code> 反映出来。</p>
<p>原型链的第二个问题是：创建子类实例时，无法向超类的构造函数传递参数。</p>
<p>为了解决这些问题，通常会使用下面这些技术来实现继承。</p>
<h2 id="组合继承">组合继承<a hidden class="anchor" aria-hidden="true" href="#组合继承">#</a></h2>
<p>通过将原型链和借用构造函数技术相结合达到目的。使用原型链实现对原型属性、方法的继承，通过借用构造函数实现对实例属性的继承。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SuperType</span>(<span style="color:#a6e22e">name</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">colors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;blue&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>];
}
<span style="color:#a6e22e">SuperType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
};
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SubType</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span>) {
  <span style="color:#75715e">// 继承属性，通过call()函数在实例内部创建属性
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">SuperType</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">name</span>);
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">age</span>;
}
<span style="color:#75715e">// 继承方法，来自子类原型对象的原型对象-也就是超类原型对象
</span><span style="color:#75715e"></span><span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SuperType</span>();
<span style="color:#75715e">// 默认情况下，所有原型对象会自动获得一个constructor（构造函数）属性，指向原型对象所在函数。
</span><span style="color:#75715e">// 覆写的prototype对象没有constructor属性，需要重新指定。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">constructor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">SubType</span>;
<span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">sayAge</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span>);
};
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SubType</span>(<span style="color:#e6db74">&#34;Nicholas&#34;</span>, <span style="color:#ae81ff">29</span>);
<span style="color:#a6e22e">instance1</span>.<span style="color:#a6e22e">colors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;black&#34;</span>);
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">instance1</span>.<span style="color:#a6e22e">colors</span>); <span style="color:#75715e">// &#34;red,blue,green,black&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">instance1</span>.<span style="color:#a6e22e">sayName</span>(); <span style="color:#75715e">// &#34;Nicholas&#34;;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">instance1</span>.<span style="color:#a6e22e">sayAge</span>(); <span style="color:#75715e">// 29
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SubType</span>(<span style="color:#e6db74">&#34;Greg&#34;</span>, <span style="color:#ae81ff">27</span>);
<span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">instance2</span>.<span style="color:#a6e22e">colors</span>); <span style="color:#75715e">// &#34;red,blue,green&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">instance2</span>.<span style="color:#a6e22e">sayName</span>(); <span style="color:#75715e">// &#34;Greg&#34;;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">instance2</span>.<span style="color:#a6e22e">sayAge</span>(); <span style="color:#75715e">// 27
</span></code></pre></div><p>在这个例子中，通过子类创建的实例会包含下列属性、方法：</p>
<ol>
<li><code>name</code>、<code>colors</code> 通过 <code>SuperType.call()</code> 创建，它们属于子类实例。</li>
<li><strong>超类实例直接赋值给子类原型，<code>Subtype.prototype</code> 也有 <code>name</code>、<code>colors</code> 属性。</strong></li>
<li><code>age</code> 通过 <code>SubType</code> 构造函数创建，属于子类实例。</li>
<li><code>sayName()</code> 方法继承自超类原型。</li>
<li><code>sayAge()</code> 方法来自子类原型。</li>
</ol>
<p>这种继承方式是 JavaScript 中最为常见的继承模式。并且 <code>instanceof</code> 和 <code>isPrototypeOf()</code> 也能够用于识别子类实例。但是可以看到，子类的原型有多余的属性。接下来的继承方式则解决了这个问题。</p>
<h2 id="寄生组合式继承">寄生组合式继承<a hidden class="anchor" aria-hidden="true" href="#寄生组合式继承">#</a></h2>
<p>这里可能稍微有些复杂，先看其基本模式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 这里是原型式继承-通过该函数，将实例的原型指定为对象o，从而拥有o的属性。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">object</span>(<span style="color:#a6e22e">o</span>) {
  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">F</span>() {}
  <span style="color:#a6e22e">F</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">o</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">F</span>();
}
<span style="color:#75715e">// 寄生组合式继承基本模式
</span><span style="color:#75715e">// 接受两个参数：子类构造函数、超类构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inheritPrototype</span>(<span style="color:#a6e22e">subType</span>, <span style="color:#a6e22e">superType</span>) {
  <span style="color:#75715e">// 创建prototype对象，目的是准备把它当成子类的原型。同时该prototype对象的原型是超类原型。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">object</span>(<span style="color:#a6e22e">superType</span>.<span style="color:#a6e22e">prototype</span>); <span style="color:#75715e">//创建对象
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 覆写的prototype对象没有constructor属性，需要重新指定。
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">constructor</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">subType</span>;
  <span style="color:#75715e">// 将prototype对象赋值给子类原型
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">subType</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">prototype</span>;
}
</code></pre></div><p>基本想法就是自行创建子类的原型对象，同时将该原型对象的原型指向超类原型。<strong>这样一来子类只继承了超类的原型，而与超类实例无关。</strong>
下面看一个更加具体的例子加深理解：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SuperType</span>(<span style="color:#a6e22e">name</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">colors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;red&#34;</span>, <span style="color:#e6db74">&#34;blue&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>];
}
<span style="color:#a6e22e">SuperType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">sayName</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
};
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SubType</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span>) {
  <span style="color:#a6e22e">SuperType</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">name</span>);
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">age</span>;
}
<span style="color:#a6e22e">inheritPrototype</span>(<span style="color:#a6e22e">SubType</span>, <span style="color:#a6e22e">SuperType</span>);
<span style="color:#a6e22e">SubType</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">sayAge</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">age</span>);
};
</code></pre></div><p>在上面的例子中，通过子类创建的实例会包含下列属性、方法：</p>
<ol>
<li><code>name</code>、<code>colors</code> 通过 <code>SuperType.call()</code> 创建，它们属于子类实例。</li>
<li><code>age</code> 通过 <code>SubType</code> 构造函数创建，属于子类实例。</li>
<li><code>sayName()</code> 方法继承自超类原型。</li>
<li><code>sayAge()</code> 方法来自子类原型。</li>
</ol>
<p>与上述组合继承方式相比，这种继承方式避免了在 <code>SubType.prototype</code> 上创建多余的属性，同时保持了原型链不变。</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ruihusky.github.io/ruihusky/tags/javascript/">JavaScript</a></li>
    </ul>
    <nav class="paginav">
      <a class="prev" href="https://ruihusky.github.io/ruihusky/posts/2020-11-16_js-promise/">
        <span class="title">« 上一页</span>
        <br>
        <span>JavaScript异步编程：回调函数与Promise</span>
      </a>
    </nav>
  </footer>

<script
  src="https://utteranc.es/client.js"
  repo="ruihusky/ruihusky"
  issue-term="pathname"
  label="comment"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>


</article>
    </main><footer class="footer">
    <span>ruihusky&rsquo;s Blog</span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/ruihusky/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
