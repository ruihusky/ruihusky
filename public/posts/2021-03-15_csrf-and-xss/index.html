<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CSRF的原理与防御 | ruihusky's Blog</title><meta name=keywords content="网络安全"><meta name=description content="CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。
举一个经典的例子：
用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：
https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
攻击者在一个恶意网站上放置如下代码：
<img src=&#34;https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman&#34; />。
如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。
注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。
CSRF 防御 CSRF 具备两个特点：
 CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。
检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。
这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。
CSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。"><meta name=author content="ruihusky"><link rel=canonical href=https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/><link crossorigin=anonymous href=/ruihusky/assets/css/stylesheet.min.b4a96aabd0f808032bf8cffb299bb9b7bf22b92efba2c0cf58292ce09db9917b.css integrity="sha256-tKlqq9D4CAMr+M/7KZu5t78iuS77osDPWCks4J25kXs=" rel="preload stylesheet" as=style><link rel=icon href=https://ruihusky.github.io/ruihusky/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ruihusky.github.io/ruihusky/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ruihusky.github.io/ruihusky/favicon-32x32.png><link rel=apple-touch-icon href=https://ruihusky.github.io/ruihusky/apple-touch-icon.png><link rel=mask-icon href=https://ruihusky.github.io/ruihusky/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><meta property="og:title" content="CSRF的原理与防御"><meta property="og:description" content="CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。
举一个经典的例子：
用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：
https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
攻击者在一个恶意网站上放置如下代码：
<img src=&#34;https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman&#34; />。
如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。
注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。
CSRF 防御 CSRF 具备两个特点：
 CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。
检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。
这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。
CSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。"><meta property="og:type" content="article"><meta property="og:url" content="https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-14T20:00:00+08:00"><meta property="article:modified_time" content="2021-03-14T20:00:00+08:00"><meta property="og:site_name" content="ruihusky's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="CSRF的原理与防御"><meta name=twitter:description content="CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。
举一个经典的例子：
用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：
https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
攻击者在一个恶意网站上放置如下代码：
<img src=&#34;https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman&#34; />。
如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。
注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。
CSRF 防御 CSRF 具备两个特点：
 CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。
检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。
这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。
CSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ruihusky.github.io/ruihusky/posts/"},{"@type":"ListItem","position":2,"name":"CSRF的原理与防御","item":"https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CSRF的原理与防御","name":"CSRF的原理与防御","description":"CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。\n举一个经典的例子：\n用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：\nhttps://bank.example.com/withdraw?account=AccoutName\u0026amp;amount=1000\u0026amp;for=PayeeName。\n攻击者在一个恶意网站上放置如下代码：\n\u0026lt;img src=\u0026quot;https://bank.example.com/withdraw?account=Alice\u0026amp;amount=1000\u0026amp;for=Badman\u0026quot; /\u0026gt;。\n如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。\n注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。\nCSRF 防御 CSRF 具备两个特点：\n CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。\n检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。\n这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。\nCSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。","keywords":["网络安全"],"articleBody":"CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。\n举一个经典的例子：\n用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：\nhttps://bank.example.com/withdraw?account=AccoutName\u0026amount=1000\u0026for=PayeeName。\n攻击者在一个恶意网站上放置如下代码：\n。\n如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。\n注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。\nCSRF 防御 CSRF 具备两个特点：\n CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。\n检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。\n这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。\nCSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。\n大部分 Web 框架都带有这种功能，例如 Django：\n1  form method=\"post\"{% csrf_token %}form   渲染后的效果：\n1 2 3 4 5 6 7  form method=\"post\" input type=\"hidden\" name=\"csrfmiddlewaretoken\" value=\"KbyUmhTLMpYj7CD2di7JKP1P3qmLlkPt\" / form   但 CSRF token 的防御方式也有不足。因为 token 是唯一且随机的，如果每次请求都使用一个唯一的 token，则服务器对于每一个请求都需要进行校验，工作量与服务器压力都会增加。使用会话（session）等级的 token 代替的话，负担将没有那么重。但在大型网站中，使用 session 等级的 CSRF token 会带来一些问题。大型网站很可能会使用分布式环境，用户的多个 http 请求可能会落到不同的服务器之上，那么分布式环境中的 session 信息需要存储在公共存储空间中，比如 redis 里。访问 session 中的 CSRF token 会带来性能问题。目前很多网站采用 Encrypted Token 模式解决该问题。在该模式下，token 不是随机生成的字符串，而是一个计算出来的结果（通常使用一些用户信息、时间戳、随机数等加密生成）。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。\nSameSite cookies 为了从源头解决 CSRF 的问题，Google Chrome 版本 51 引入了 SetCookie SameSite 规范作为可选属性。SameSite 是 http 响应头 Set-Cookie 的属性之一。该属性用于声明该 cookie 是否仅限于同一站点使用。目前该属性尚未纳入 http 标准，还是草案阶段，但大部分现代浏览器已经支持（链接：SameSite#浏览器兼容性）。\nSameSite 可以被设置为三个值：Strict、Lax、None\nSameSite=Strict 该规则最为严格，浏览器将仅发送第一方上下文请求的 cookie（源自设置 cookie 的站点的请求）。如果请求源自于当前位置不同的 URL，则不会发送使用被该 Strict 属性标记的任何 cookie。\nSet-Cookie: CookieName=CookieValue; SameSite=Strict; 该规则过于严格，可能造成不好的用户体验。例如：某网站有一个 GitHub 的跳转链接，用户点击跳转到 GitHub 网站后，由于 cookie 被标记为 SameSite=Strict，跳转过去后将是未登录状态。\nSameSite=Lax(浏览器默认值) Lax 规则相对宽松一些，在满足下述两条规则的情况下，浏览器会在跨源请求中携带 cookie：\n 请求为顶级导航。可以理解为通过超链接跳转到 cookie 所在网站。 请求方法是安全的，包括 GET、HEAD、OPTIONS 请求。  Set-Cookie: CookieName=CookieValue; SameSite=Lax; 举几个例子用来说明 Lax 与 Strict 之间的区别：\n 用户访问了 a.com 网站，并点击网站中的一个链接导航至 b.com，则发起 b.com 请求的请求源是 a.com，是一个跨源请求，则 Strict cookies 不会被发送。但这是一个顶级导航，因此 Lax cookies 会被发送。 用户访问了 a.com 网站，该网站中有一个 iframe 请求 b.com，这种情况下 Lax cookies 也不会被发送。因为这不是一次顶级导航。 用户访问了 a.com 网站，该网站对 b.com 网站发起了一次 POST 请求，这种情况下 Lax cookies 也不会被发送。因为请求方法不是安全方法。  SameSite=None cookie 将同时在第一方上下文和跨源请求中发送；但是，必须将该值显式设置为 None ，且设置 Secure 属性。这也意味着所有请求必须遵循 https 协议。\nSet-Cookie: CookieName=CookieValue; SameSite=None; Secure; ","wordCount":"232","inLanguage":"zh","datePublished":"2021-03-14T20:00:00+08:00","dateModified":"2021-03-14T20:00:00+08:00","author":{"@type":"Person","name":"ruihusky"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/"},"publisher":{"@type":"Organization","name":"ruihusky's Blog","logo":{"@type":"ImageObject","url":"https://ruihusky.github.io/ruihusky/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ruihusky.github.io/ruihusky/ accesskey=h title="ruihusky's Blog (Alt + H)">ruihusky's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ruihusky.github.io/ruihusky/archives title=Archives><span>Archives</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/categories title=Categories><span>Categories</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ruihusky.github.io/ruihusky/>Home</a>&nbsp;»&nbsp;<a href=https://ruihusky.github.io/ruihusky/posts/>Posts</a></div><h1 class=post-title>CSRF的原理与防御</h1><div class=post-meta>2021年3月14日&nbsp;·&nbsp;ruihusky</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>目录</div></summary><div class=inner><ul><li><a href=#csrf-%e5%8e%9f%e7%90%86 aria-label="CSRF 原理">CSRF 原理</a></li><li><a href=#csrf-%e9%98%b2%e5%be%a1 aria-label="CSRF 防御">CSRF 防御</a><ul><li><a href=#%e6%a3%80%e6%9f%a5-referer-%e5%ad%97%e6%ae%b5 aria-label="检查 Referer 字段">检查 Referer 字段</a></li><li><a href=#csrf-token aria-label="CSRF token">CSRF token</a></li><li><a href=#samesite-cookies aria-label="SameSite cookies">SameSite cookies</a><ul><li><a href=#samesitestrict aria-label="SameSite=Strict">SameSite=Strict</a></li><li><a href=#samesitelax%e6%b5%8f%e8%a7%88%e5%99%a8%e9%bb%98%e8%ae%a4%e5%80%bc aria-label="SameSite=Lax(浏览器默认值)">SameSite=Lax(浏览器默认值)</a></li><li><a href=#samesitenone aria-label="SameSite=None">SameSite=None</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=csrf-原理>CSRF 原理<a hidden class=anchor aria-hidden=true href=#csrf-原理>#</a></h2><p>CSRF 的全称是 Cross Site Request Forgery 的缩写，即<strong>跨站请求伪造</strong>。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。</p><p>举一个经典的例子：</p><p>用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：</p><p><code>https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName</code>。</p><p>攻击者在一个恶意网站上放置如下代码：</p><p><code>&lt;img src="https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman" /></code>。</p><p>如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述<code>img</code>标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。</p><p>注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是<strong>欺骗用户的浏览器，让其以用户的名义执行操作</strong>。</p><h2 id=csrf-防御>CSRF 防御<a hidden class=anchor aria-hidden=true href=#csrf-防御>#</a></h2><p>CSRF 具备两个特点：</p><ul><li>CSRF 通常是发生在第三方域名的</li><li>CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作</li></ul><p>针对这两个特点，我们可以制定对应的防护策略。</p><h3 id=检查-referer-字段>检查 Referer 字段<a hidden class=anchor aria-hidden=true href=#检查-referer-字段>#</a></h3><p>http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。</p><p>这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。</p><h3 id=csrf-token>CSRF token<a hidden class=anchor aria-hidden=true href=#csrf-token>#</a></h3><p>CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。</p><p>大部分 Web 框架都带有这种功能，例如 Django：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-html data-lang=html><span class=p>&lt;</span><span class=nt>form</span> <span class=na>method</span><span class=o>=</span><span class=s>&#34;post&#34;</span><span class=p>&gt;</span>{% csrf_token %}<span class=p>&lt;/</span><span class=nt>form</span><span class=p>&gt;</span>
</code></pre></td></tr></table></div></div><p>渲染后的效果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-html data-lang=html><span class=p>&lt;</span><span class=nt>form</span> <span class=na>method</span><span class=o>=</span><span class=s>&#34;post&#34;</span><span class=p>&gt;</span>
  <span class=p>&lt;</span><span class=nt>input</span>
    <span class=na>type</span><span class=o>=</span><span class=s>&#34;hidden&#34;</span>
    <span class=na>name</span><span class=o>=</span><span class=s>&#34;csrfmiddlewaretoken&#34;</span>
    <span class=na>value</span><span class=o>=</span><span class=s>&#34;KbyUmhTLMpYj7CD2di7JKP1P3qmLlkPt&#34;</span>
  <span class=p>/&gt;</span>
<span class=p>&lt;/</span><span class=nt>form</span><span class=p>&gt;</span>
</code></pre></td></tr></table></div></div><p>但 CSRF token 的防御方式也有不足。因为 token 是唯一且随机的，如果每次请求都使用一个唯一的 token，则服务器对于每一个请求都需要进行校验，工作量与服务器压力都会增加。使用会话（session）等级的 token 代替的话，负担将没有那么重。但在大型网站中，使用 session 等级的 CSRF token 会带来一些问题。大型网站很可能会使用分布式环境，用户的多个 http 请求可能会落到不同的服务器之上，那么分布式环境中的 session 信息需要存储在公共存储空间中，比如 redis 里。访问 session 中的 CSRF token 会带来性能问题。目前很多网站采用 Encrypted Token 模式解决该问题。在该模式下，token 不是随机生成的字符串，而是一个计算出来的结果（通常使用一些用户信息、时间戳、随机数等加密生成）。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。</p><h3 id=samesite-cookies>SameSite cookies<a hidden class=anchor aria-hidden=true href=#samesite-cookies>#</a></h3><p>为了从源头解决 CSRF 的问题，Google Chrome 版本 51 引入了 <code>SetCookie SameSite</code> 规范作为可选属性。SameSite 是 http 响应头 Set-Cookie 的属性之一。该属性用于声明该 cookie 是否仅限于同一站点使用。目前该属性尚未纳入 http 标准，还是草案阶段，但大部分现代浏览器已经支持（<a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7>链接：SameSite#浏览器兼容性</a>）。</p><p>SameSite 可以被设置为三个值：<code>Strict</code>、<code>Lax</code>、<code>None</code></p><h4 id=samesitestrict>SameSite=Strict<a hidden class=anchor aria-hidden=true href=#samesitestrict>#</a></h4><p>该规则最为严格，浏览器将仅发送第一方上下文请求的 cookie（源自设置 cookie 的站点的请求）。如果请求源自于当前位置不同的 URL，则不会发送使用被该 Strict 属性标记的任何 cookie。</p><pre><code class=language-raw data-lang=raw>Set-Cookie: CookieName=CookieValue; SameSite=Strict;
</code></pre><p>该规则过于严格，可能造成不好的用户体验。例如：某网站有一个 GitHub 的跳转链接，用户点击跳转到 GitHub 网站后，由于 cookie 被标记为 SameSite=Strict，跳转过去后将是未登录状态。</p><h4 id=samesitelax浏览器默认值>SameSite=Lax(浏览器默认值)<a hidden class=anchor aria-hidden=true href=#samesitelax浏览器默认值>#</a></h4><p>Lax 规则相对宽松一些，在满足下述两条规则的情况下，浏览器会在跨源请求中携带 cookie：</p><ol><li>请求为顶级导航。可以理解为通过超链接跳转到 cookie 所在网站。</li><li>请求方法是安全的，包括 GET、HEAD、OPTIONS 请求。</li></ol><pre><code class=language-raw data-lang=raw>Set-Cookie: CookieName=CookieValue; SameSite=Lax;
</code></pre><p>举几个例子用来说明 Lax 与 Strict 之间的区别：</p><ol><li>用户访问了 a.com 网站，并点击网站中的一个链接导航至 b.com，则发起 b.com 请求的请求源是 a.com，是一个跨源请求，则 Strict cookies 不会被发送。但这是一个顶级导航，因此 Lax cookies 会被发送。</li><li>用户访问了 a.com 网站，该网站中有一个 iframe 请求 b.com，这种情况下 Lax cookies 也不会被发送。因为这不是一次顶级导航。</li><li>用户访问了 a.com 网站，该网站对 b.com 网站发起了一次 POST 请求，这种情况下 Lax cookies 也不会被发送。因为请求方法不是安全方法。</li></ol><h4 id=samesitenone>SameSite=None<a hidden class=anchor aria-hidden=true href=#samesitenone>#</a></h4><p>cookie 将同时在第一方上下文和跨源请求中发送；但是，必须将该值显式设置为 <strong>None</strong> ，且设置 <strong>Secure</strong> 属性。这也意味着所有请求必须遵循 https 协议。</p><pre><code class=language-raw data-lang=raw>Set-Cookie: CookieName=CookieValue; SameSite=None; Secure;
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://ruihusky.github.io/ruihusky/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a></li></ul><nav class=paginav><a class=prev href=https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/><span class=title>« 上一页</span><br><span>React Hooks 原理简析</span></a>
<a class=next href=https://ruihusky.github.io/ruihusky/posts/2021-02-21_sorting-algorithm/><span class=title>下一页 »</span><br><span>十大经典排序算法</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ruihusky/ruihusky issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article><script>for(var content=document.querySelector(".post-content"),links=content.getElementsByTagName("a"),i=0,linksLength=links.length;i<linksLength;i++)links[i].hostname!=window.location.hostname&&(links[i].target='_blank')</script></main><footer class=footer><span>ruihusky&rsquo;s Blog</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>