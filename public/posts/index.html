<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | ruihusky&#39;s Blog</title>

<meta name="keywords" content="" />
<meta name="description" content="ruihusky&#39;s Blog - https://ruihusky.github.io/ruihusky/">
<meta name="author" content="ruihusky">
<link rel="canonical" href="https://ruihusky.github.io/ruihusky/posts/" />
<link href="/ruihusky/assets/css/stylesheet.min.3b4ed2e80185ab356f837eda72c1debdea24ca2d707d78b82f2534624843aaa0.css" integrity="sha256-O07S6AGFqzVvg37acsHeveokyi1wfXi4LyU0YkhDqqA=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://ruihusky.github.io/ruihusky/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ruihusky.github.io/ruihusky/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ruihusky.github.io/ruihusky/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ruihusky.github.io/ruihusky/apple-touch-icon.png">
<link rel="mask-icon" href="https://ruihusky.github.io/ruihusky/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<link rel="alternate" type="application/rss&#43;xml" href="https://ruihusky.github.io/ruihusky/posts/index.xml">


<meta property="og:title" content="Posts" />
<meta property="og:description" content="ruihusky&#39;s Blog - https://ruihusky.github.io/ruihusky/" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ruihusky.github.io/ruihusky/posts/" />
<meta property="og:updated_time" content="2021-03-14T20:00:00+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="ruihusky&#39;s Blog - https://ruihusky.github.io/ruihusky/"/>



</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ruihusky.github.io/ruihusky/" accesskey="h" title="ruihusky&#39;s Blog (Alt + H)">ruihusky&#39;s Blog</a>
            <span class="logo-switches">
                <a id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </a>
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://ruihusky.github.io/ruihusky/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ruihusky.github.io/ruihusky/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main"> 
<header class="page-header">
<div class="breadcrumbs">

    <a href="https://ruihusky.github.io/ruihusky/">Home</a>
</div>

  <h1>Posts</h1>
</header>



<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      CSRF的原理与防御
    </h2>
  </header>
  <section class="entry-content">
    <p>CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。
举一个经典的例子：
用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：
https://bank.example.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。
攻击者在一个恶意网站上放置如下代码：
&lt;img src=&#34;https://bank.example.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&#34; /&gt;。
如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。
注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。
CSRF 防御 CSRF 具备两个特点：
 CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作  针对这两个特点，我们可以制定对应的防护策略。
检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。
这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。
CSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。...</p>
  </section>
  <footer class="entry-footer">

March 14, 2021&nbsp;·&nbsp;ruihusky
</footer>
  <a class="entry-link" aria-label="post link to CSRF的原理与防御" href="https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      十大经典排序算法
    </h2>
  </header>
  <section class="entry-content">
    <p>概览与术语 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法，最常用到的排序方式之一就是数值顺序。
排序算法依照稳定性可分为稳定算法和不稳定算法。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，则在排序过的列表中 R 也将会是在 S 之前。
排序算法依照排序过程中占用空间的方式分为 In-place 算法 与 Out-place 算法。In-place 是原地算法，基本上不需要额外的辅助空间，可允许固定数量的辅助变量。非原地算法就是 Out-place，其开辟的辅助空间与问题规模相关。例如，冒泡排序只需要数据在原序列中交换位置，不需要额外的辅助空间，是 In-place 算法。
不同的排序算法会有不同的时间复杂度（最差、平均、和最好性能），下表列出了十种经典排序算法的概览：
冒泡排序（Bubble Sort） 一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为：越的元素会经由交换慢慢“浮”到数列的顶端。
冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。
算法描述
 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到没有任何一对数字需要比较； 可选的优化步骤：某次步骤 1~3 执行过程中没有元素发生交换，则证明该序列已经有序，不需要再进行下一次序列遍历。  动图演示
代码实现
// TypeScript实现 export function bubbleSort(arr: number[]) { const len = arr.length; for (let i = 0; i &lt; len - 1; i&#43;&#43;) { let sorted = true; for (let j = 0; j &lt; len - 1 - i; j&#43;&#43;) { if (arr[j] &gt; arr[j &#43; 1]) { sorted = false; [arr[j], arr[j &#43; 1]] = [arr[j &#43; 1], arr[j]]; } } if (sorted) break; } return arr; } 算法分析...</p>
  </section>
  <footer class="entry-footer">

February 20, 2021&nbsp;·&nbsp;ruihusky
</footer>
  <a class="entry-link" aria-label="post link to 十大经典排序算法" href="https://ruihusky.github.io/ruihusky/posts/2021-02-21_sorting-algorithm/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      CSS flex-basis: auto 与弹性布局
    </h2>
  </header>
  <section class="entry-content">
    <p>flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：
页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。
这个问题看起来不难。使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：
&lt;div class=&#34;page-container&#34;&gt; &lt;!-- ...其他flex子项 --&gt; &lt;div class=&#34;image-wrap&#34;&gt; &lt;!-- 为了实现多个动画效果，图片被一个div包裹 --&gt; &lt;img class=&#34;image&#34; src=&#34;...&#34; /&gt; &lt;/div&gt; &lt;!-- ...其他flex子项 --&gt; &lt;/div&gt; &lt;!-- vue css scope --&gt; &lt;style&gt; .page-container { width: 750px; /* 父元素固定100vh */ height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } .image-wrap { /* 让flex子元素自动伸展、自动压缩，并且设置最大、最小高度 */ flex-grow: 1; flex-shrink: 1; max-height: 688px; min-height: 613px; } ....</p>
  </section>
  <footer class="entry-footer">

January 26, 2021&nbsp;·&nbsp;ruihusky
</footer>
  <a class="entry-link" aria-label="post link to CSS flex-basis: auto 与弹性布局" href="https://ruihusky.github.io/ruihusky/posts/2021-01-26_css-flex-basis/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Unicode 编码与 UTF-32、UTF-16、UTF-8
    </h2>
  </header>
  <section class="entry-content">
    <p>字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。
Unicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U&#43;0000 ~ U&#43;FFFF。
经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：
 辅助平面 1：U&#43;10000 ~ U&#43;1FFFF 辅助平面 2：U&#43;20000 ~ U&#43;2FFFF … 辅助平面 15：U&#43;F0000 ~ U&#43;FFFFF 辅助平面 16：U&#43;100000 ~ U&#43;10FFFF  所有辅助平面的编码范围为 U&#43;10000 ~ U&#43;10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。
到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。...</p>
  </section>
  <footer class="entry-footer">

December 16, 2020&nbsp;·&nbsp;ruihusky
</footer>
  <a class="entry-link" aria-label="post link to Unicode 编码与 UTF-32、UTF-16、UTF-8" href="https://ruihusky.github.io/ruihusky/posts/2020-12-16_unicode-utf/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Windows 10 WSL 2 网络配置
    </h2>
  </header>
  <section class="entry-content">
    <p>使用 WSL 2 时建议将 Windows 10 升级到 版本 2004 或更高版本。
WSL 2 使用轻量级虚拟机 (VM) 技术运行 Linux 内核，因此 WSL 2 是有自己的独立 IP 地址的，进行网络应用开发时的情况与 WSL 1 有所不同。
从 Windows 访问 WSL 2 网络 在 Windows 使用 localhost 可以直接访问 WSL 2 中运行的网络应用。
从 WSL 2 访问 Windows 网络 需要使用主机的 IP 地址进行访问。可以使用以下命令获取主机 IP 地址：
$ cat /etc/resolv.conf | grep -oP &#39;(?&lt;=nameserver\ ).*&#39; 172.20.144.1 以在 WSL 2 (Ubuntu 18.04) 中使用 Windows 网络代理（此处为 socks5 代理）为例，向 ~/.bashrc 中写入以下内容：...</p>
  </section>
  <footer class="entry-footer">

December 11, 2020&nbsp;·&nbsp;ruihusky
</footer>
  <a class="entry-link" aria-label="post link to Windows 10 WSL 2 网络配置" href="https://ruihusky.github.io/ruihusky/posts/2020-12-11_wsl2-net-config/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://ruihusky.github.io/ruihusky/posts/page/2/">下一页 »</a>
  </nav>
</footer>

    </main><footer class="footer">
    <span>ruihusky&rsquo;s Blog</span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
