<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>React Hooks 原理简析 | ruihusky's Blog</title><meta name=keywords content="框架原理"><meta name=description content="说明 本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。
函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。
先看概括 React 设计理念的公式：
1  UI = render(data)   React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。
类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。
不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () => { alert('Followed ' + this."><meta name=author content="ruihusky"><link rel=canonical href=https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/><link crossorigin=anonymous href=/ruihusky/assets/css/stylesheet.min.b4a96aabd0f808032bf8cffb299bb9b7bf22b92efba2c0cf58292ce09db9917b.css integrity="sha256-tKlqq9D4CAMr+M/7KZu5t78iuS77osDPWCks4J25kXs=" rel="preload stylesheet" as=style><link rel=icon href=https://ruihusky.github.io/ruihusky/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ruihusky.github.io/ruihusky/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ruihusky.github.io/ruihusky/favicon-32x32.png><link rel=apple-touch-icon href=https://ruihusky.github.io/ruihusky/apple-touch-icon.png><link rel=mask-icon href=https://ruihusky.github.io/ruihusky/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><meta property="og:title" content="React Hooks 原理简析"><meta property="og:description" content="说明 本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。
函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。
先看概括 React 设计理念的公式：
1  UI = render(data)   React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。
类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。
不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () => { alert('Followed ' + this."><meta property="og:type" content="article"><meta property="og:url" content="https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-20T20:00:00+08:00"><meta property="article:modified_time" content="2021-06-20T20:00:00+08:00"><meta property="og:site_name" content="ruihusky's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="React Hooks 原理简析"><meta name=twitter:description content="说明 本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。
函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。
先看概括 React 设计理念的公式：
1  UI = render(data)   React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。
类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。
不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () => { alert('Followed ' + this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ruihusky.github.io/ruihusky/posts/"},{"@type":"ListItem","position":2,"name":"React Hooks 原理简析","item":"https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React Hooks 原理简析","name":"React Hooks 原理简析","description":"说明 本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。\n函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。\n先看概括 React 设计理念的公式：\n1  UI = render(data)   React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。\n类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。\n不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + this.","keywords":["框架原理"],"articleBody":"说明 本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。\n函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。\n先看概括 React 设计理念的公式：\n1  UI = render(data)   React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。\n类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。\n不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () = { alert('Followed ' + this.props.user); }; handleClick = () = { setTimeout(this.showMessage, 3000); }; render() { return button onClick={this.handleClick}Followbutton; } }   如果在点击 Follow 后，在 setTimeout 回调触发之前，传入组件的 props.user 改变了，那么 showMessage 将会提示你关注了改变后的 props.user 。\n可以点击 这个示例 自己动手操作，点击页面上的 Follow(class) ，并在三秒之内通过上方的 select 切换 user 。\n按照数据应和渲染结果绑定的设计理念，alert 的表现也是渲染结果的一部分，应与点击按钮那一刻的状态绑定。\n问题在于，在类组件中是通过 this 访问 props 的，而 this 是可变的。具体到这个例子，点击按钮时的 this.props 和三秒之后的 this.props 是不一样的。\n函数组件与数据捕获 将上文的类组件改为函数组件：\n1 2 3 4 5 6 7 8 9 10 11  function ProfilePage(props) { const showMessage = () = { alert('Followed ' + props.user); }; const handleClick = () = { setTimeout(showMessage, 3000); }; return ( button onClick={handleClick}Followbutton ); }   然后以同样的方式操作，会发现函数组件的表现与类组件不同：\n可以点击 这个示例 自己动手操作，点击页面上的 Follow(function) ，并在三秒之内通过上方的 select 切换 user 。\n在函数组件的 showMessage 函数中，被访问的 props 在函数执行的时刻就被“捕获”了，只要确保 props 是不可变的，在 setTimeout 中访问到的 props.user 就是点击按钮那一刻的值。\n生命周期函数与副作用 在类组件中，副作用通常是在 componentDidMount 或 componentDidUpdate 生命周期函数中执行的。\n 函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量），修改参数或改变外部存储。\n 假设有一个聊天室页面，该页面需要根据不同的聊天室ID与后端建立对应的 websocket 连接。在类组件中，我们可以在 componentDidMount 和 componentDidUpdate 中根据当前的 ID 执行建立、销毁 websocket 连接的操作。但我们需要在两个生命周期函数中写这段逻辑。如果还有其它的副作用需要执行，我们就需要在这两个生命周期函数中重复多个逻辑。\n在函数组件中，函数的主要任务就是通过数据渲染出视图，相应的副作用则可以通过 useEffect Hook 执行，代码不再需要分散到各个生命周期函数中，逻辑清晰。\nuseState 我们先通过 useState 这个最常用的 Hook 来了解 Hook 的实现原理。\n先看一下 React 给出的 Hook 的使用原则：\n   只在最顶层使用 Hook ，不要在循环、条件或嵌套函数中调用 Hook\n  只在 React 函数中调用 Hook ，即只在 React 函数组件和自定义 Hook 中调用 React Hook\n   React 也给出了说明：React 要求每次渲染时 Hook 的调用顺序保持一致，这样 React 就能正确地将内部 state 和对应的 Hook 进行关联。\n背后的原因是：Hook 是通过链表实现的。在一个函数组件中多次调用 useState 将会创建一个单向环状链表。\n先看一个示例：（Code Sandbox: React Conditionally Hook）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  import { useState } from \"react\"; let isMounted = false; // 组件初次渲染时，两个 useState 都会执行。 // 点击按钮触发更新渲染时，只会执行第二个 useState export default function App() { let valueA, setValueA, valueB, setValueB; console.log(\"isMounted ?\", isMounted); if (!isMounted) { [valueA, setValueA] = useState(\"initial value a\"); console.log(\"valueA =\", valueA); isMounted = true; } [valueB, setValueB] = useState(\"initial value b\"); console.log(\"valueB =\", valueB); return ( div className=\"App\" h1React conditionally hook exampleh1 divA: {valueA}div divB: {valueB}div button onClick={() = { setValueA(\"changed value a\"); setValueB(\"changed value b\"); }}  Click to change values button divClick the button and view the console outputdiv div ); }   挂载该组件，页面将正常显示。点击按钮改变 valueB 的值，React 将会报错，我们查看控制台的输出信息：\n1 2 3 4 5  isMounted ? false valueA = initial value a valueB = initial value b isMounted ? true valueB = changed value a   注意第二次渲染时控制台的输出：valueB = changed value a，明明调用的是[valueB, setValueB] = useState(\"initial value b\")，为什么valueB的值变成了changed value a呢？\n带着疑问我们看看源码中 React 做了哪些事情。\nmount 阶段 在函数组件初次渲染时，调用 useState 实际上最终是调用了 mountState 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  function mountStateS( initialState: (() = S) | S, ): [S, DispatchBasicStateActionS] { // 创建新的 hook 对象  const hook = mountWorkInProgressHook(); if (typeof initialState === 'function') { initialState = initialState(); } // 设置 hook 的初始值  hook.memoizedState = hook.baseState = initialState; // 创建 hook 队列  const queue = (hook.queue = { pending: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), }); // 创建 dispatch  const dispatch: Dispatch BasicStateActionS,  = (queue.dispatch = (dispatchAction.bind( null, currentlyRenderingFiber, queue, ): any)); return [hook.memoizedState, dispatch]; }   mountState 函数通过 mountWorkInProgressHook 函数创建了新的 hook 对象，然后为 hook 赋予初始值、创建 dispatch 函数，最后返回。\n再看看 mountWorkInProgressHook 是如何创建 hook 对象的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // This is the first hook in the list  currentlyRenderingFiber.memoizedState = workInProgressHook = hook; } else { // Append to the end of the list  workInProgressHook = workInProgressHook.next = hook; } return workInProgressHook; }   上例的 mount 阶段调用了两次 useState ，并产生如下的 Hook 链表：\n1 2 3  hook: { memoizedState: 'initial value a' } ↓next hook: { memoizedState: 'initial value b' }   点击按钮之后，将会调用如下代码：\n1 2 3 4  onClick={() = { setValueA(\"changed value a\"); setValueB(\"changed value b\"); }}   在 onClick 事件中多次调用的 setState 将会合并，并异步触发更新。\nReact 将执行之前通过调用 mountState 返回的两个 dispatch ，更新两个 hook 节点的 memoizedState ，更新后的 hook 链表如下：\n1 2 3  hook: { memoizedState: 'changed value a' } ↓next hook: { memoizedState: 'changed value b' }   随后进入异步的 update 阶段，重新执行函数组件。\nupdate 阶段 在 update 阶段，useState 最终调用了 updateReducer 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function updateReducerS, I, A( reducer: (S, A) = S, initialArg: I, init?: I = S, ): [S, DispatchA] { // 按照顺序从之前的链表获取当前 hook  const hook = updateWorkInProgressHook(); const queue = hook.queue; queue.lastRenderedReducer = reducer; // ...  // 获取 newState 并赋值给 hook.memoizedState  hook.memoizedState = newState; // ...  const dispatch: DispatchA = (queue.dispatch: any); return [hook.memoizedState, dispatch]; }   updateReducer 中逻辑较多，这里有所省略。简单来说，它会按顺序遍历之前构建的链表，取出对应的数据进行渲染。\n上例的 update 阶段，第一个 useState 将被跳过，只调用了第二个 useState ，并将返回值赋值给 valueB：\n但对于 React 来说，这是该函数组件第一次调用 useState ，因此 React 按照顺序取出第一个 hook ，并返回对应的 memoizedState 和 dispatch ：\n1 2 3  hook: { memoizedState: 'changed value a' } // 实际被取出的 hook ，因此 valueB = 'changed value a' ↓next hook: { memoizedState: 'changed value b' }   以上就是对 useState Hook 的原理简析。\nuseEffect 先提出两个问题：\n 若父子组件都使用了 useEffect ，他们的执行顺序是怎么样的？ 同级兄弟组件之间的 useEffect 执行顺序又是怎么样的？  读者可以带着疑问继续往下阅读。\n首先看一段 React 官方文档对 useEffect 的说明：\n 传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用\n React 是如何实现这一点的呢？这涉及到 Fiber 架构的工作流程，这里简单展开说一下。\nFiber 架构工作流程 React 将组件树渲染到真实 DOM 的过程分为两大阶段： render 与 commit 。\n在 render 阶段，React 会为每个 React 元素生成一个 Fiber 节点，节点之间通过指针连接起来，形成 Fiber 树。可以将 Fiber 树理解为虚拟 DOM ，它保存着 React 如何渲染真实 DOM 的各种信息。Fiber 树是一个基于单链表的树结构，类似于下图结构：\n每个 Fiber 节点会有三个指针属性：\n child 指向该节点子节点列表的第一个节点 sibling 指向该节点的下一个兄弟节点 return 指向该节点的父节点  React 以上图中箭头标识的顺序创建、走访所有 Fiber 节点，可以理解为一个递归过程（请注意，只有 Legacy 模式下的 render 过程才是一个同步的递归过程）。\n在“递”阶段，React 会从根节点开始向下深度优先遍历，为每个 Fiber 节点调用 beginWork 函数。该函数会创建子 Fiber 节点，并将两个 Fiber 节点连接起来。当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。\n在“归”阶段，React 会调用 completeWork 处理 Fiber 节点。当某个 Fiber 节点执行完 completeWork ，如果其存在兄弟 Fiber 节点，会进入其兄弟 Fiber 节点的“递”阶段。如果不存在兄弟 Fiber 节点，会进入父 Fiber 节点的“归”阶段。\n整个递归过程最终会回到根节点。到此 render 阶段结束，进入 commit 阶段。\n在 commit 阶段，React 会将 Fiber 树同步到真实 DOM 。这一阶段的主要工作就是操作 DOM ，除此之外会有一些其他工作，例如执行 effect 。\nrender - beginWork 阶段 在 beginWork 函数创建 Fiber 节点的过程中有大量逻辑，这里只需要关注其中会执行组件的 render 函数。对于函数组件，就会执行其中可能存在的 useEffect Hook 。\n在函数组件初次渲染时，调用 useEffect 最终会执行 mountEffect 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function mountEffect( create: () = (() = void) | void, deps: Arraymixed | void | null, ): void { // ...  return mountEffectImpl( // 传入的 fiberFlags ，PassiveEffect 代表惰性 effect  UpdateEffect | PassiveEffect, // 传入的 hookFlags，HookPassive 代表惰性 hook  HookPassive, create, deps, ); }   mountEffect 调用了 mountEffectImpl 函数，并传入了当前 Fiber 节点的标志位 flags 和 Hook 的标志位 hookFlags ，这些标志位将在后续流程被 React 使用。\n需要留意的是 HookPassive 这个 hookFlag ，它代表该 Hook 是一个惰性 Hook ，将被异步调度。\nmountEffectImpl 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function mountEffectImpl(fiberFlags, hookFlags, create, deps): void { // 创建 hook 对象  const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; currentlyRenderingFiber.flags |= fiberFlags; hook.memoizedState = pushEffect( // hookFlags: HookHasEffect 代表该 hook 需要被执行  HookHasEffect | hookFlags, // create 就是实际传入的 effect 函数  create, // 上个 effect 的销毁函数。由于是第一次执行，不存在该函数。  undefined, // nextDeps 是传入的依赖项数组  nextDeps, ); }   mountEffectImpl 创建了一个新的 hook 对象，并将其 memoizedState 属性设置为 pushEffect 的返回值。\n传入 pushEffect 函数的 hookFlags 参数中，HookHasEffect 标志位代表该 Hook 需要被执行，React 将会在后续流程检测这个标志位。\n再来看看 pushEffect 函数做了什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  function pushEffect(tag, create, destroy, deps) { // 创建 effect 对象  const effect: Effect = { tag, create, destroy, deps, // Circular  next: (null: any), }; // componentUpdateQueue 是当前正在执行渲染函数的 Fiber 节点所维护的一个队列  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any); if (componentUpdateQueue === null) { // componentUpdateQueue 不存在，则创建一个  componentUpdateQueue = createFunctionComponentUpdateQueue(); currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any); // componentUpdateQueue 是一个单向环状链表  componentUpdateQueue.lastEffect = effect.next = effect; } else { const lastEffect = componentUpdateQueue.lastEffect; if (lastEffect === null) { componentUpdateQueue.lastEffect = effect.next = effect; } else { // 维护单向环状链表的数据结构  const firstEffect = lastEffect.next; lastEffect.next = effect; effect.next = firstEffect; componentUpdateQueue.lastEffect = effect; } } return effect; }   总结一下 pushEffect 所做的事情：\n 根据传入的参数创建新的 effect 对象 获取或创建当前正在执行渲染的 Fiber 节点的 Fiber.updateQueue 将新的 effect 赋值给 Fiber.updateQueue.lastEffect，并维护 effect 的单向环状链表数据结构 返回 effect 对象  因此 hook.memoizedState 中保存的是一个 effect 对象，而该对象是一个 effect 单向环状链表中的一员。函数组件所对应的 Fiber 数据结构中， Fiber.updateQueue.lastEffect 始终指向最后一个 effect 。\nbeginWork 阶段最终会为该 Fiber 节点创建 effect 链表，该链表的顺序与组件中调用 useEffect 的顺序保持一致。\nrender - completeWork 阶段 我们先不关注 completeWork 函数做了什么。\n在 completeWork 函数执行结束后，其上层函数 completeUnitOfWork 会检测当前 Fiber 节点是否存在 effect 链表，若存在就将该 Fiber 节点添加到父 Fiber 节点所维护的一份 effectList 链表中。可以参考源码中的注释：completeUnitOfWork 。（请注意，这里父节点的 effectList 是一个 Fiber 节点链表，与子节点里的 Fiber.updateQueue 中维护的 effectList 不是同一个概念）\n最终所有具有 effect 的 Fiber 节点在递归过程结束后会形成一个链表，维护在根节点的 effectList 中，其顺序与节点执行 completeWork 的顺序一致。\n上文有一点没有提到：除了 useEffect 产生的 effect 之外，React 也会将待进行的 DOM 更新操作标记成 effect ，保存在 effect 链表中。commit 阶段将根据 effectList 执行所有的 DOM 更新。\ncommit 阶段 这里先不关注 commit 阶段是如何更新 DOM 的，只关注 useEffect 所产生副作用的执行时机。\n在 React 完成 DOM 更新之后，将调用 commitLayoutEffects 函数，其中调用了 commitLayoutEffectOnFiber 函数，该函数是 commitLifeCycles 函数的别名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function commitLifeCycles( finishedRoot: FiberRoot, current: Fiber | null, finishedWork: Fiber, committedLanes: Lanes, ): void { switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: { // ...  // useEffect 产生的 effect 属于 PassiveEffect ，将在这里调度执行  schedulePassiveEffects(finishedWork); return; } // ...  } // ... }   再来看看 schedulePassiveEffects 做了什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function schedulePassiveEffects(finishedWork: Fiber) { const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any); const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null; if (lastEffect !== null) { const firstEffect = lastEffect.next; let effect = firstEffect; do { const {next, tag} = effect; if ( // 如果 effect 的标志位存在 HookHasEffect 和 HookPassive  (tag \u0026 HookPassive) !== NoHookEffect \u0026\u0026 (tag \u0026 HookHasEffect) !== NoHookEffect ) { // 将 effect 的销毁函数推入队列 pendingPassiveHookEffectsUnmount  // 相当于 pendingPassiveHookEffectsUnmount.push(effect, finishedWork);  enqueuePendingPassiveHookEffectUnmount(finishedWork, effect); // 将 effect 的执行函数推入队列 pendingPassiveHookEffectsMount  // 相当于 pendingPassiveHookEffectsMount.push(effect, finishedWork)  enqueuePendingPassiveHookEffectMount(finishedWork, effect); } // 移动指针，访问整个 effect 链表  effect = next; } while (effect !== firstEffect); } }   schedulePassiveEffects 遍历 effect 链表，找到所有具有 HookHasEffect 和 HookPassive 标志位的 effect ，将 effect 的销毁函数、执行函数推入了各自所属的队列。队列中的任务将会异步执行。\n队列最终是在什么时间执行的呢？这与 React 的调度机制有关，不再展开叙述。我们先简单认为这两个队列将在某个适当的时机异步执行，其执行函数就是 flushPassiveEffects ，该函数最终会调用 flushPassiveEffectsImpl ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  function flushPassiveEffectsImpl() { // ...  // 阶段一：执行销毁函数  const unmountEffects = pendingPassiveHookEffectsUnmount; pendingPassiveHookEffectsUnmount = []; for (let i = 0; i  unmountEffects.length; i += 2) { const effect = ((unmountEffects[i]: any): HookEffect); const fiber = ((unmountEffects[i + 1]: any): Fiber); const destroy = effect.destroy; effect.destroy = undefined; // ...  // 如果存在销毁函数则执行，这里省略了一些不相关的逻辑  if (typeof destroy === 'function') { try { destroy(); } finally { // ...  } } } // 阶段二：执行副作用函数  const mountEffects = pendingPassiveHookEffectsMount; pendingPassiveHookEffectsMount = []; for (let i = 0; i  mountEffects.length; i += 2) { const effect = ((mountEffects[i]: any): HookEffect); const fiber = ((mountEffects[i + 1]: any): Fiber); // ...  // 重新执行副作用函数，这里省略了一些不相关的逻辑  try { effect.destroy = create(); } finally { // ...  } } // ... }   flushPassiveEffectsImpl 先依次执行了所有 effect 销毁函数，然后再依次执行 effect 执行函数。到这里，整个 useEffect 的执行过程结束。\n现在已经可以回答上文的问题了：\n 若父子组件都使用了 useEffect ，子组件的 effect 将先执行。 同级兄弟组件， effect 将会按照组件顺序依次执行。  update 阶段 组件 update 阶段执行 useEffect 时，将会执行 updateEffectImpl 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function updateEffectImpl(fiberFlags, hookFlags, create, deps): void { // 从 hook 链表中取出 useEffect hook 对象  const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; let destroy = undefined; if (currentHook !== null) { const prevEffect = currentHook.memoizedState; destroy = prevEffect.destroy; if (nextDeps !== null) { const prevDeps = prevEffect.deps; // deps 一致则不添加 HookHasEffect 标志，本次更新该 Hook 不执行  if (areHookInputsEqual(nextDeps, prevDeps)) { pushEffect(hookFlags, create, destroy, nextDeps); return; } } } currentlyRenderingFiber.flags |= fiberFlags; // deps 有变化则重新计算 memoizedState  hook.memoizedState = pushEffect( // 为 hookFlags 添加 HookHasEffect 标志  HookHasEffect | hookFlags, create, destroy, nextDeps, ); }   对比 mountEffectImpl ，updateEffectImpl 多了比较 deps 的步骤，若 deps 改变才会对 effect 添加 HookHasEffect 标志，这样才会在后续的 commit 阶段执行该 effect 。\nuseRef  useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。\n ref 是 reference（引用）的缩写。React 推荐使用不可变数据，但某些情况下用户希望使用可变数据，ref 就提供了这样的能力。\nuseRef Hook 的实现 useRef Hook 的 hook.memoizedState 中保存着 ref 对象。例如：\nconst ref = useRef('hello') // ref = hook.memoizedState = { current: 'hello' } 这可以从 useRef 实际调用的 mountRef 、 updateRef 函数看出：\n1 2 3 4 5 6 7 8 9 10 11 12  function mountRefT(initialValue: T): {|current: T|} { const hook = mountWorkInProgressHook(); const ref = {current: initialValue}; hook.memoizedState = ref; return ref; } function updateRefT(initialValue: T): {|current: T|} { const hook = updateWorkInProgressHook(); return hook.memoizedState; }   React 元素的 Refs React 支持通过 Refs 访问 DOM 元素或者类组件：\n1 2 3 4  // DOM 元素 div ref={domRef}div // React 类组件 ClassComponent ref={classComponentRef} /   对于元素上的 ref 声明，React 是如何对 ref.current 赋值的呢？\n在 render 的 beginWork 阶段，React 将通过 beginWork: markRef 函数为含有 ref 属性的 Fiber 添加 flag: Ref 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // ReactFiberFlags.js 中定义的 Ref flag export const Ref = 0b000000000010000000; // beginWork 阶段的 markRef function markRef(current: Fiber | null, workInProgress: Fiber) { const ref = workInProgress.ref; if ( (current === null \u0026\u0026 ref !== null) || (current !== null \u0026\u0026 current.ref !== ref) ) { // Schedule a Ref effect  workInProgress.flags |= Ref; } }   markRef 将在 finishClassComponent 函数和 updateHostComponent 函数中调用。其中 finishClassComponent 用于类组件， updateHostComponent 用于原生 DOM 元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function finishClassComponent( current: Fiber | null, workInProgress: Fiber, Component: any, shouldUpdate: boolean, hasContext: boolean, renderLanes: Lanes, ) { // 即使 shouldComponentUpdate 返回了 false ，Refs 也应该更新  markRef(current, workInProgress); const didCaptureError = (workInProgress.flags \u0026 DidCapture) !== NoFlags; if (!shouldUpdate \u0026\u0026 !didCaptureError) { // Context providers should defer to sCU for rendering  if (hasContext) { invalidateContextProvider(workInProgress, Component, false); } return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes); } // ... } function updateHostComponent( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes, ) { // ...  markRef(current, workInProgress); reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; }   另外在 render 的 completeWork 阶段，React 将通过 completeWork: markRef 为需要进行 ref 更新的节点进行标记：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function markRef(workInProgress: Fiber) { workInProgress.flags |= Ref; } function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes, ): Fiber | null { // ...  switch (workInProgress.tag) { // ...  case HostComponent: { // ...  if (current !== null \u0026\u0026 workInProgress.stateNode != null) { // ...  // 更新节点的情形，ref 属性发生变化  if (current.ref !== workInProgress.ref) { markRef(workInProgress); } } else { // ...  // 新建节点的情形，节点存在 ref 属性  if (workInProgress.ref !== null) { markRef(workInProgress); } } return null; } // ...  } // ... }   在 commit 阶段，React 将为需要操作 ref 的 Fiber 节点执行两类操作：清除之前的 ref 、赋值新的 ref 。\n有两种情形需要清除之前的 ref ，第一种是 Fiber 节点包含 flag: Ref ，通过 commitMutationEffects 函数执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function commitMutationEffects( root: FiberRoot, renderPriorityLevel: ReactPriorityLevel, ) { while (nextEffect !== null) { const flags = nextEffect.flags; // ...  if (flags \u0026 Ref) { const current = nextEffect.alternate; if (current !== null) { commitDetachRef(current); } } // ...  } // ... }   commitDetachRef 是实际执行 ref 清除的函数：\n1 2 3 4 5 6 7 8 9 10  function commitDetachRef(current: Fiber) { const currentRef = current.ref; if (currentRef !== null) { if (typeof currentRef === 'function') { currentRef(null); } else { currentRef.current = null; } } }   第二种情形是 Fiber 节点需要被移除：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function commitMutationEffects( root: FiberRoot, renderPriorityLevel: ReactPriorityLevel, ) { while (nextEffect !== null) { // ...  const flags = nextEffect.flags; // ...  const primaryFlags = flags \u0026 (Placement | Update | Deletion | Hydrating); switch (primaryFlags) { // ...  // 需要删除节点  case Deletion: { commitDeletion(root, nextEffect, renderPriorityLevel); break; } } // ...  } }   commitDeletion 函数最终会调用 safelyDetachRef 函数，负责 ref 清除的工作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function safelyDetachRef(current: Fiber) { const ref = current.ref; if (ref !== null) { if (typeof ref === 'function') { // ...  try { ref(null); } catch (refError) { captureCommitPhaseError(current, refError); } } else { ref.current = null; } } }   完成 ref 的清除除工作后，接下来是 ref 的赋值工作，在 commitLayoutEffect 函数中会执行 commitAttachRef 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function commitAttachRef(finishedWork: Fiber) { const ref = finishedWork.ref; if (ref !== null) { const instance = finishedWork.stateNode; let instanceToUse; switch (finishedWork.tag) { // 原生 DOM 元素  case HostComponent: instanceToUse = getPublicInstance(instance); break; // 类组件  default: instanceToUse = instance; } // ...  if (typeof ref === 'function') { ref(instanceToUse); } else { // ...  ref.current = instanceToUse; } } }   useCallback 与 useMemo 相比于上文的几种 Hook ，useCallback 和 useMemo 的实现比较简单。\nmount 阶段 先看 mount 阶段 mountCallback 与 mountMemo 的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function mountCallbackT(callback: T, deps: Arraymixed | void | null): T { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; hook.memoizedState = [callback, nextDeps]; return callback; } function mountMemoT( nextCreate: () = T, deps: Arraymixed | void | null, ): T { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; }   两者的区别在于：mountCallback 保存传入的函数与依赖项，mountMemo 保存传入函数的执行结果与依赖项。\nupdate 阶段 在 update 阶段，useCallback 与 useMemo 将会比较依赖项，若依赖项改变则保存新值，否则返回之前保存的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  function updateCallbackT(callback: T, deps: Arraymixed | void | null): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { if (nextDeps !== null) { const prevDeps: Arraymixed | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { return prevState[0]; } } } hook.memoizedState = [callback, nextDeps]; return callback; } function updateMemoT( nextCreate: () = T, deps: Arraymixed | void | null, ): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { // Assume these are defined. If they're not, areHookInputsEqual will warn.  if (nextDeps !== null) { const prevDeps: Arraymixed | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { return prevState[0]; } } } const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; }   比较函数 areHookInputsEqual 的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function areHookInputsEqual( nextDeps: Arraymixed, prevDeps: Arraymixed | null, ) { // ...  if (prevDeps === null) { // ...  return false; } // ...  for (let i = 0; i  prevDeps.length \u0026\u0026 i  nextDeps.length; i++) { // is 是 Object.is 的 polyfill  if (is(nextDeps[i], prevDeps[i])) { continue; } return false; } return true; }   areHookInputsEqual 对依赖项进行了浅层的 Object.is 比较，因此修改依赖项的深层数据并不会触发 useCallback 和 useMemo 重新计算的逻辑。\n","wordCount":"3150","inLanguage":"zh","datePublished":"2021-06-20T20:00:00+08:00","dateModified":"2021-06-20T20:00:00+08:00","author":{"@type":"Person","name":"ruihusky"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/"},"publisher":{"@type":"Organization","name":"ruihusky's Blog","logo":{"@type":"ImageObject","url":"https://ruihusky.github.io/ruihusky/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ruihusky.github.io/ruihusky/ accesskey=h title="ruihusky's Blog (Alt + H)">ruihusky's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ruihusky.github.io/ruihusky/archives title=Archives><span>Archives</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/categories title=Categories><span>Categories</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ruihusky.github.io/ruihusky/>Home</a>&nbsp;»&nbsp;<a href=https://ruihusky.github.io/ruihusky/posts/>Posts</a></div><h1 class=post-title>React Hooks 原理简析</h1><div class=post-meta>2021年6月20日&nbsp;·&nbsp;ruihusky</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>目录</div></summary><div class=inner><ul><li><a href=#%e8%af%b4%e6%98%8e aria-label=说明>说明</a></li><li><a href=#%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e4%b8%8e%e7%b1%bb%e7%bb%84%e4%bb%b6 aria-label=函数组件与类组件>函数组件与类组件</a><ul><li><a href=#%e7%b1%bb%e7%bb%84%e4%bb%b6%e4%b8%8e%e5%8f%af%e5%8f%98%e7%9a%84-this aria-label="类组件与可变的 this">类组件与可变的 this</a></li><li><a href=#%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e4%b8%8e%e6%95%b0%e6%8d%ae%e6%8d%95%e8%8e%b7 aria-label=函数组件与数据捕获>函数组件与数据捕获</a></li><li><a href=#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%87%bd%e6%95%b0%e4%b8%8e%e5%89%af%e4%bd%9c%e7%94%a8 aria-label=生命周期函数与副作用>生命周期函数与副作用</a></li></ul></li><li><a href=#usestate aria-label=useState>useState</a><ul><li><a href=#mount-%e9%98%b6%e6%ae%b5 aria-label="mount 阶段">mount 阶段</a></li><li><a href=#update-%e9%98%b6%e6%ae%b5 aria-label="update 阶段">update 阶段</a></li></ul></li><li><a href=#useeffect aria-label=useEffect>useEffect</a><ul><li><a href=#fiber-%e6%9e%b6%e6%9e%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b aria-label="Fiber 架构工作流程">Fiber 架构工作流程</a></li><li><a href=#render---beginwork-%e9%98%b6%e6%ae%b5 aria-label="render - beginWork 阶段">render - beginWork 阶段</a></li><li><a href=#render---completework-%e9%98%b6%e6%ae%b5 aria-label="render - completeWork 阶段">render - completeWork 阶段</a></li><li><a href=#commit-%e9%98%b6%e6%ae%b5 aria-label="commit 阶段">commit 阶段</a></li><li><a href=#update-%e9%98%b6%e6%ae%b5-1 aria-label="update 阶段">update 阶段</a></li></ul></li><li><a href=#useref aria-label=useRef>useRef</a><ul><li><a href=#useref-hook-%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="useRef Hook 的实现">useRef Hook 的实现</a></li><li><a href=#react-%e5%85%83%e7%b4%a0%e7%9a%84-refs aria-label="React 元素的 Refs">React 元素的 Refs</a></li></ul></li><li><a href=#usecallback-%e4%b8%8e-usememo aria-label="useCallback 与 useMemo">useCallback 与 useMemo</a><ul><li><a href=#mount-%e9%98%b6%e6%ae%b5-1 aria-label="mount 阶段">mount 阶段</a></li><li><a href=#update-%e9%98%b6%e6%ae%b5-2 aria-label="update 阶段">update 阶段</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=说明>说明<a hidden class=anchor aria-hidden=true href=#说明>#</a></h2><p>本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。</p><h2 id=函数组件与类组件>函数组件与类组件<a hidden class=anchor aria-hidden=true href=#函数组件与类组件>#</a></h2><p>想要理解 Hooks，需要先理解函数组件与类组件之间的区别。</p><p>先看概括 React 设计理念的公式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>UI</span> <span class=o>=</span> <span class=nx>render</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。</p><h3 id=类组件与可变的-this>类组件与可变的 this<a hidden class=anchor aria-hidden=true href=#类组件与可变的-this>#</a></h3><p>在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。</p><p>不过就算使用不可变数据，类组件中还是会有<code>this</code>的问题。先看一个类组件示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-jsx data-lang=jsx><span class=cm>/**
</span><span class=cm>  假设这里是某个用户的个人信息页
</span><span class=cm>  点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功
</span><span class=cm>  通过 setTimeout 模拟了一个响应较慢的接口
</span><span class=cm>*/</span>
<span class=kr>class</span> <span class=nx>ProfilePage</span> <span class=kr>extends</span> <span class=nx>React</span><span class=p>.</span><span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>showMessage</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>alert</span><span class=p>(</span><span class=s1>&#39;Followed &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>user</span><span class=p>);</span>
  <span class=p>};</span>
  <span class=nx>handleClick</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>setTimeout</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>showMessage</span><span class=p>,</span> <span class=mi>3000</span><span class=p>);</span>
  <span class=p>};</span>
  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleClick</span><span class=p>}&gt;</span><span class=nx>Follow</span><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果在点击 Follow 后，在 setTimeout 回调触发之前，传入组件的 props.user 改变了，那么 showMessage 将会提示你关注了改变后的 props.user 。</p><p><img loading=lazy src=/ruihusky/assets/img/2021-06-20_react-hooks/class-component-follow.gif alt="类组件 Follow 演示"></p><p>可以点击 <a href=https://codesandbox.io/s/pjqnl16lm7>这个示例</a> 自己动手操作，点击页面上的 Follow(class) ，并在三秒之内通过上方的 select 切换 user 。</p><p>按照数据应和渲染结果绑定的设计理念，alert 的表现也是渲染结果的一部分，应与点击按钮那一刻的状态绑定。</p><p>问题在于，在类组件中是通过 this 访问 props 的，而 this 是可变的。具体到这个例子，点击按钮时的 this.props 和三秒之后的 this.props 是不一样的。</p><h3 id=函数组件与数据捕获>函数组件与数据捕获<a hidden class=anchor aria-hidden=true href=#函数组件与数据捕获>#</a></h3><p>将上文的类组件改为函数组件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-jsx data-lang=jsx><span class=kd>function</span> <span class=nx>ProfilePage</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>showMessage</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>alert</span><span class=p>(</span><span class=s1>&#39;Followed &#39;</span> <span class=o>+</span> <span class=nx>props</span><span class=p>.</span><span class=nx>user</span><span class=p>);</span>
  <span class=p>};</span>
  <span class=kr>const</span> <span class=nx>handleClick</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>showMessage</span><span class=p>,</span> <span class=mi>3000</span><span class=p>);</span>
  <span class=p>};</span>
  <span class=k>return</span> <span class=p>(</span>
    <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{</span><span class=nx>handleClick</span><span class=p>}&gt;</span><span class=nx>Follow</span><span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
  <span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>然后以同样的方式操作，会发现函数组件的表现与类组件不同：</p><p><img loading=lazy src=/ruihusky/assets/img/2021-06-20_react-hooks/function-component-follow.gif alt="函数组件 Follow 演示"></p><p>可以点击 <a href=https://codesandbox.io/s/pjqnl16lm7>这个示例</a> 自己动手操作，点击页面上的 Follow(function) ，并在三秒之内通过上方的 select 切换 user 。</p><p>在函数组件的 showMessage 函数中，被访问的 props 在函数执行的时刻就被“捕获”了，只要确保 props 是不可变的，在 setTimeout 中访问到的 props.user 就是点击按钮那一刻的值。</p><h3 id=生命周期函数与副作用>生命周期函数与副作用<a hidden class=anchor aria-hidden=true href=#生命周期函数与副作用>#</a></h3><p>在类组件中，副作用通常是在 componentDidMount 或 componentDidUpdate 生命周期函数中执行的。</p><blockquote><p>函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量），修改参数或改变外部存储。</p></blockquote><p>假设有一个聊天室页面，该页面需要根据不同的聊天室ID与后端建立对应的 websocket 连接。在类组件中，我们可以在 componentDidMount 和 componentDidUpdate 中根据当前的 ID 执行建立、销毁 websocket 连接的操作。但我们需要在两个生命周期函数中写这段逻辑。如果还有其它的副作用需要执行，我们就需要在这两个生命周期函数中重复多个逻辑。</p><p>在函数组件中，函数的主要任务就是通过数据渲染出视图，相应的副作用则可以通过 useEffect Hook 执行，代码不再需要分散到各个生命周期函数中，逻辑清晰。</p><h2 id=usestate>useState<a hidden class=anchor aria-hidden=true href=#usestate>#</a></h2><p>我们先通过 useState 这个最常用的 Hook 来了解 Hook 的实现原理。</p><p>先看一下 React 给出的 Hook 的使用原则：</p><blockquote><ol><li><p>只在最顶层使用 Hook ，不要在循环、条件或嵌套函数中调用 Hook</p></li><li><p>只在 React 函数中调用 Hook ，即只在 React 函数组件和自定义 Hook 中调用 React Hook</p></li></ol></blockquote><p>React 也给出了<a href=https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation>说明</a>：React 要求每次渲染时 Hook 的调用顺序保持一致，这样 React 就能正确地将内部 state 和对应的 Hook 进行关联。</p><p>背后的原因是：Hook 是通过链表实现的。在一个函数组件中多次调用 useState 将会创建一个<strong>单向环状链表</strong>。</p><p>先看一个示例：（<a href=https://codesandbox.io/s/react-conditionally-hook-ik8s4>Code Sandbox: React Conditionally Hook</a>）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-jsx data-lang=jsx><span class=kr>import</span> <span class=p>{</span> <span class=nx>useState</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>

<span class=kd>let</span> <span class=nx>isMounted</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>

<span class=c1>// 组件初次渲染时，两个 useState 都会执行。
</span><span class=c1>// 点击按钮触发更新渲染时，只会执行第二个 useState
</span><span class=c1></span><span class=kr>export</span> <span class=k>default</span> <span class=kd>function</span> <span class=nx>App</span><span class=p>()</span> <span class=p>{</span>
  <span class=kd>let</span> <span class=nx>valueA</span><span class=p>,</span> <span class=nx>setValueA</span><span class=p>,</span> <span class=nx>valueB</span><span class=p>,</span> <span class=nx>setValueB</span><span class=p>;</span>

  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;isMounted ?&#34;</span><span class=p>,</span> <span class=nx>isMounted</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>isMounted</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>[</span><span class=nx>valueA</span><span class=p>,</span> <span class=nx>setValueA</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;initial value a&#34;</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;valueA =&#34;</span><span class=p>,</span> <span class=nx>valueA</span><span class=p>);</span>
    <span class=nx>isMounted</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=p>[</span><span class=nx>valueB</span><span class=p>,</span> <span class=nx>setValueB</span><span class=p>]</span> <span class=o>=</span> <span class=nx>useState</span><span class=p>(</span><span class=s2>&#34;initial value b&#34;</span><span class=p>);</span>
  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;valueB =&#34;</span><span class=p>,</span> <span class=nx>valueB</span><span class=p>);</span>

  <span class=k>return</span> <span class=p>(</span>
    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>className</span><span class=o>=</span><span class=s>&#34;App&#34;</span><span class=p>&gt;</span>
      <span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span><span class=nx>React</span> <span class=nx>conditionally</span> <span class=nx>hook</span> <span class=nx>example</span><span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
      <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span><span class=nx>A</span><span class=o>:</span> <span class=p>{</span><span class=nx>valueA</span><span class=p>}&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
      <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span><span class=nx>B</span><span class=o>:</span> <span class=p>{</span><span class=nx>valueB</span><span class=p>}&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
      <span class=p>&lt;</span><span class=nt>button</span>
        <span class=na>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=p>{</span>
          <span class=nx>setValueA</span><span class=p>(</span><span class=s2>&#34;changed value a&#34;</span><span class=p>);</span>
          <span class=nx>setValueB</span><span class=p>(</span><span class=s2>&#34;changed value b&#34;</span><span class=p>);</span>
        <span class=p>}}</span>
      <span class=p>&gt;</span>
        <span class=nx>Click</span> <span class=nx>to</span> <span class=nx>change</span> <span class=nx>values</span>
      <span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
      <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span><span class=nx>Click</span> <span class=nx>the</span> <span class=nx>button</span> <span class=nx>and</span> <span class=nx>view</span> <span class=nx>the</span> <span class=nx>console</span> <span class=nx>output</span><span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
    <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
  <span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>挂载该组件，页面将正常显示。点击按钮改变 valueB 的值，React 将会报错，我们查看控制台的输出信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-text data-lang=text>isMounted ? false
valueA = initial value a
valueB = initial value b
isMounted ? true
valueB = changed value a
</code></pre></td></tr></table></div></div><p>注意第二次渲染时控制台的输出：<code>valueB = changed value a</code>，明明调用的是<code>[valueB, setValueB] = useState("initial value b")</code>，为什么<code>valueB</code>的值变成了<code>changed value a</code>呢？</p><p>带着疑问我们看看源码中 React 做了哪些事情。</p><h3 id=mount-阶段>mount 阶段<a hidden class=anchor aria-hidden=true href=#mount-阶段>#</a></h3><p>在函数组件初次渲染时，调用 useState 实际上最终是调用了 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1113>mountState</a> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>mountState</span><span class=o>&lt;</span><span class=nx>S</span><span class=o>&gt;</span><span class=p>(</span>
  <span class=nx>initialState</span><span class=o>:</span> <span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>S</span><span class=p>)</span> <span class=o>|</span> <span class=nx>S</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=p>[</span><span class=nx>S</span><span class=p>,</span> <span class=nx>Dispatch</span><span class=o>&lt;</span><span class=nx>BasicStateAction</span><span class=o>&lt;</span><span class=nx>S</span><span class=o>&gt;&gt;</span><span class=p>]</span> <span class=p>{</span>
  <span class=c1>// 创建新的 hook 对象
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>mountWorkInProgressHook</span><span class=p>();</span>
  <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>initialState</span> <span class=o>===</span> <span class=s1>&#39;function&#39;</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>initialState</span> <span class=o>=</span> <span class=nx>initialState</span><span class=p>();</span>
  <span class=p>}</span>
  <span class=c1>// 设置 hook 的初始值
</span><span class=c1></span>  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=nx>hook</span><span class=p>.</span><span class=nx>baseState</span> <span class=o>=</span> <span class=nx>initialState</span><span class=p>;</span>
  <span class=c1>// 创建 hook 队列
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>queue</span> <span class=o>=</span> <span class=p>(</span><span class=nx>hook</span><span class=p>.</span><span class=nx>queue</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>pending</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
    <span class=nx>dispatch</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
    <span class=nx>lastRenderedReducer</span><span class=o>:</span> <span class=nx>basicStateReducer</span><span class=p>,</span>
    <span class=nx>lastRenderedState</span><span class=o>:</span> <span class=p>(</span><span class=nx>initialState</span><span class=o>:</span> <span class=nx>any</span><span class=p>),</span>
  <span class=p>});</span>
  <span class=c1>// 创建 dispatch
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>dispatch</span><span class=o>:</span> <span class=nx>Dispatch</span><span class=o>&lt;</span>
    <span class=nx>BasicStateAction</span><span class=o>&lt;</span><span class=nx>S</span><span class=o>&gt;</span><span class=p>,</span>
  <span class=o>&gt;</span> <span class=o>=</span> <span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nx>dispatch</span> <span class=o>=</span> <span class=p>(</span><span class=nx>dispatchAction</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span>
    <span class=kc>null</span><span class=p>,</span>
    <span class=nx>currentlyRenderingFiber</span><span class=p>,</span>
    <span class=nx>queue</span><span class=p>,</span>
  <span class=p>)</span><span class=o>:</span> <span class=nx>any</span><span class=p>));</span>
  <span class=k>return</span> <span class=p>[</span><span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span><span class=p>,</span> <span class=nx>dispatch</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>mountState 函数通过 mountWorkInProgressHook 函数创建了新的 hook 对象，然后为 hook 赋予初始值、创建 dispatch 函数，最后返回。</p><p>再看看 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L531>mountWorkInProgressHook</a> 是如何创建 hook 对象的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>mountWorkInProgressHook</span><span class=p>()</span><span class=o>:</span> <span class=nx>Hook</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span><span class=o>:</span> <span class=nx>Hook</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>memoizedState</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
    <span class=nx>baseState</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
    <span class=nx>baseQueue</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
    <span class=nx>queue</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
    <span class=nx>next</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
  <span class=p>};</span>

  <span class=k>if</span> <span class=p>(</span><span class=nx>workInProgressHook</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// This is the first hook in the list
</span><span class=c1></span>    <span class=nx>currentlyRenderingFiber</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=nx>workInProgressHook</span> <span class=o>=</span> <span class=nx>hook</span><span class=p>;</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=c1>// Append to the end of the list
</span><span class=c1></span>    <span class=nx>workInProgressHook</span> <span class=o>=</span> <span class=nx>workInProgressHook</span><span class=p>.</span><span class=nx>next</span> <span class=o>=</span> <span class=nx>hook</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>workInProgressHook</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>上例的 mount 阶段调用了两次 useState ，并产生如下的 Hook 链表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>hook</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memoizedState</span><span class=o>:</span> <span class=s1>&#39;initial value a&#39;</span> <span class=p>}</span>
<span class=err>↓</span><span class=nx>next</span>
<span class=nx>hook</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memoizedState</span><span class=o>:</span> <span class=s1>&#39;initial value b&#39;</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>点击按钮之后，将会调用如下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=nx>setValueA</span><span class=p>(</span><span class=s2>&#34;changed value a&#34;</span><span class=p>);</span>
  <span class=nx>setValueB</span><span class=p>(</span><span class=s2>&#34;changed value b&#34;</span><span class=p>);</span>
<span class=p>}}</span>
</code></pre></td></tr></table></div></div><p>在 onClick 事件中多次调用的 setState 将会合并，并异步触发更新。</p><p>React 将执行之前通过调用 mountState 返回的两个 dispatch ，更新两个 hook 节点的 memoizedState ，更新后的 hook 链表如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>hook</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memoizedState</span><span class=o>:</span> <span class=s1>&#39;changed value a&#39;</span> <span class=p>}</span>
<span class=err>↓</span><span class=nx>next</span>
<span class=nx>hook</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memoizedState</span><span class=o>:</span> <span class=s1>&#39;changed value b&#39;</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>随后进入异步的 update 阶段，重新执行函数组件。</p><h3 id=update-阶段>update 阶段<a hidden class=anchor aria-hidden=true href=#update-阶段>#</a></h3><p>在 update 阶段，useState 最终调用了 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L651>updateReducer</a> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>updateReducer</span><span class=o>&lt;</span><span class=nx>S</span><span class=p>,</span> <span class=nx>I</span><span class=p>,</span> <span class=nx>A</span><span class=o>&gt;</span><span class=p>(</span>
  <span class=nx>reducer</span><span class=o>:</span> <span class=p>(</span><span class=nx>S</span><span class=p>,</span> <span class=nx>A</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>S</span><span class=p>,</span>
  <span class=nx>initialArg</span><span class=o>:</span> <span class=nx>I</span><span class=p>,</span>
  <span class=nx>init</span><span class=o>?:</span> <span class=nx>I</span> <span class=p>=&gt;</span> <span class=nx>S</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=p>[</span><span class=nx>S</span><span class=p>,</span> <span class=nx>Dispatch</span><span class=o>&lt;</span><span class=nx>A</span><span class=o>&gt;</span><span class=p>]</span> <span class=p>{</span>
  <span class=c1>// 按照顺序从之前的链表获取当前 hook
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>updateWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>queue</span> <span class=o>=</span> <span class=nx>hook</span><span class=p>.</span><span class=nx>queue</span><span class=p>;</span>
  
  <span class=nx>queue</span><span class=p>.</span><span class=nx>lastRenderedReducer</span> <span class=o>=</span> <span class=nx>reducer</span><span class=p>;</span>

  <span class=c1>// ...
</span><span class=c1></span>  <span class=c1>// 获取 newState 并赋值给 hook.memoizedState
</span><span class=c1></span>  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=nx>newState</span><span class=p>;</span>
  <span class=c1>// ...
</span><span class=c1></span>
  <span class=kr>const</span> <span class=nx>dispatch</span><span class=o>:</span> <span class=nx>Dispatch</span><span class=o>&lt;</span><span class=nx>A</span><span class=o>&gt;</span> <span class=o>=</span> <span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nx>dispatch</span><span class=o>:</span> <span class=nx>any</span><span class=p>);</span>
  <span class=k>return</span> <span class=p>[</span><span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span><span class=p>,</span> <span class=nx>dispatch</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>updateReducer 中逻辑较多，这里有所省略。简单来说，它会按顺序遍历之前构建的链表，取出对应的数据进行渲染。</p><p>上例的 update 阶段，第一个 useState 将被跳过，只调用了第二个 useState ，并将返回值赋值给 valueB：</p><p>但对于 React 来说，这是该函数组件第一次调用 useState ，因此 React 按照顺序取出第一个 hook ，并返回对应的 memoizedState 和 dispatch ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=nx>hook</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memoizedState</span><span class=o>:</span> <span class=s1>&#39;changed value a&#39;</span> <span class=p>}</span> <span class=c1>// 实际被取出的 hook ，因此 valueB = &#39;changed value a&#39;
</span><span class=c1></span><span class=err>↓</span><span class=nx>next</span>
<span class=nx>hook</span><span class=o>:</span> <span class=p>{</span> <span class=nx>memoizedState</span><span class=o>:</span> <span class=s1>&#39;changed value b&#39;</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>以上就是对 useState Hook 的原理简析。</p><h2 id=useeffect>useEffect<a hidden class=anchor aria-hidden=true href=#useeffect>#</a></h2><p>先提出两个问题：</p><ol><li>若父子组件都使用了 useEffect ，他们的执行顺序是怎么样的？</li><li>同级兄弟组件之间的 useEffect 执行顺序又是怎么样的？</li></ol><p>读者可以带着疑问继续往下阅读。</p><p>首先看一段 React 官方文档对 useEffect 的说明：</p><blockquote><p>传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用</p></blockquote><p>React 是如何实现这一点的呢？这涉及到 Fiber 架构的工作流程，这里简单展开说一下。</p><h3 id=fiber-架构工作流程>Fiber 架构工作流程<a hidden class=anchor aria-hidden=true href=#fiber-架构工作流程>#</a></h3><p>React 将组件树渲染到真实 DOM 的过程分为两大阶段： render 与 commit 。</p><p>在 render 阶段，React 会为每个 React 元素生成一个 Fiber 节点，节点之间通过指针连接起来，形成 Fiber 树。可以将 Fiber 树理解为虚拟 DOM ，它保存着 React 如何渲染真实 DOM 的各种信息。Fiber 树是一个基于单链表的树结构，类似于下图结构：</p><p><img loading=lazy src=/ruihusky/assets/img/2021-06-20_react-hooks/react-fiber-tree.png alt="Fiber Tree"></p><p>每个 Fiber 节点会有三个指针属性：</p><ul><li>child 指向该节点子节点列表的第一个节点</li><li>sibling 指向该节点的下一个兄弟节点</li><li>return 指向该节点的父节点</li></ul><p>React 以上图中箭头标识的顺序创建、走访所有 Fiber 节点，可以理解为一个递归过程（请注意，只有 Legacy 模式下的 render 过程才是一个同步的递归过程）。</p><p>在“递”阶段，React 会从根节点开始向下深度优先遍历，为每个 Fiber 节点调用 beginWork 函数。该函数会创建子 Fiber 节点，并将两个 Fiber 节点连接起来。当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p><p>在“归”阶段，React 会调用 completeWork 处理 Fiber 节点。当某个 Fiber 节点执行完 completeWork ，如果其存在兄弟 Fiber 节点，会进入其兄弟 Fiber 节点的“递”阶段。如果不存在兄弟 Fiber 节点，会进入父 Fiber 节点的“归”阶段。</p><p>整个递归过程最终会回到根节点。到此 render 阶段结束，进入 commit 阶段。</p><p>在 commit 阶段，React 会将 Fiber 树同步到真实 DOM 。这一阶段的主要工作就是操作 DOM ，除此之外会有一些其他工作，例如执行 effect 。</p><h3 id=render---beginwork-阶段>render - beginWork 阶段<a hidden class=anchor aria-hidden=true href=#render---beginwork-阶段>#</a></h3><p>在 beginWork 函数创建 Fiber 节点的过程中有大量逻辑，这里只需要关注其中会执行组件的 render 函数。对于函数组件，就会执行其中可能存在的 useEffect Hook 。</p><p>在函数组件初次渲染时，调用 useEffect 最终会执行 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1232>mountEffect</a> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>mountEffect</span><span class=p>(</span>
  <span class=nx>create</span><span class=o>:</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>(()</span> <span class=p>=&gt;</span> <span class=k>void</span><span class=p>)</span> <span class=o>|</span> <span class=k>void</span><span class=p>,</span>
  <span class=nx>deps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=k>void</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=k>void</span> <span class=p>{</span>
  <span class=c1>// ...
</span><span class=c1></span>  <span class=k>return</span> <span class=nx>mountEffectImpl</span><span class=p>(</span>
    <span class=c1>// 传入的 fiberFlags ，PassiveEffect 代表惰性 effect
</span><span class=c1></span>    <span class=nx>UpdateEffect</span> <span class=o>|</span> <span class=nx>PassiveEffect</span><span class=p>,</span>
    <span class=c1>// 传入的 hookFlags，HookPassive 代表惰性 hook
</span><span class=c1></span>    <span class=nx>HookPassive</span><span class=p>,</span>
    <span class=nx>create</span><span class=p>,</span>
    <span class=nx>deps</span><span class=p>,</span>
  <span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>mountEffect 调用了 mountEffectImpl 函数，并传入了当前 Fiber 节点的标志位 flags 和 Hook 的标志位 hookFlags ，这些标志位将在后续流程被 React 使用。</p><p>需要留意的是 HookPassive 这个 hookFlag ，它代表该 Hook 是一个惰性 Hook ，将被异步调度。</p><p><a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1193>mountEffectImpl</a> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>mountEffectImpl</span><span class=p>(</span><span class=nx>fiberFlags</span><span class=p>,</span> <span class=nx>hookFlags</span><span class=p>,</span> <span class=nx>create</span><span class=p>,</span> <span class=nx>deps</span><span class=p>)</span><span class=o>:</span> <span class=k>void</span> <span class=p>{</span>
  <span class=c1>// 创建 hook 对象
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>mountWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>nextDeps</span> <span class=o>=</span> <span class=nx>deps</span> <span class=o>===</span> <span class=kc>undefined</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=nx>deps</span><span class=p>;</span>
  <span class=nx>currentlyRenderingFiber</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>fiberFlags</span><span class=p>;</span>
  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=nx>pushEffect</span><span class=p>(</span>
    <span class=c1>// hookFlags: HookHasEffect 代表该 hook 需要被执行
</span><span class=c1></span>    <span class=nx>HookHasEffect</span> <span class=o>|</span> <span class=nx>hookFlags</span><span class=p>,</span>
    <span class=c1>// create 就是实际传入的 effect 函数
</span><span class=c1></span>    <span class=nx>create</span><span class=p>,</span>
    <span class=c1>// 上个 effect 的销毁函数。由于是第一次执行，不存在该函数。
</span><span class=c1></span>    <span class=kc>undefined</span><span class=p>,</span>
    <span class=c1>// nextDeps 是传入的依赖项数组
</span><span class=c1></span>    <span class=nx>nextDeps</span><span class=p>,</span>
  <span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>mountEffectImpl 创建了一个新的 hook 对象，并将其 memoizedState 属性设置为 pushEffect 的返回值。</p><p>传入 pushEffect 函数的 hookFlags 参数中，HookHasEffect 标志位代表该 Hook 需要被执行，React 将会在后续流程检测这个标志位。</p><p>再来看看 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1150>pushEffect</a> 函数做了什么：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>pushEffect</span><span class=p>(</span><span class=nx>tag</span><span class=p>,</span> <span class=nx>create</span><span class=p>,</span> <span class=nx>destroy</span><span class=p>,</span> <span class=nx>deps</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// 创建 effect 对象
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>effect</span><span class=o>:</span> <span class=nx>Effect</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>tag</span><span class=p>,</span>
    <span class=nx>create</span><span class=p>,</span>
    <span class=nx>destroy</span><span class=p>,</span>
    <span class=nx>deps</span><span class=p>,</span>
    <span class=c1>// Circular
</span><span class=c1></span>    <span class=nx>next</span><span class=o>:</span> <span class=p>(</span><span class=kc>null</span><span class=o>:</span> <span class=nx>any</span><span class=p>),</span>
  <span class=p>};</span>
  <span class=c1>// componentUpdateQueue 是当前正在执行渲染函数的 Fiber 节点所维护的一个队列
</span><span class=c1></span>  <span class=kd>let</span> <span class=nx>componentUpdateQueue</span><span class=o>:</span> <span class=kc>null</span> <span class=o>|</span> <span class=nx>FunctionComponentUpdateQueue</span> <span class=o>=</span> <span class=p>(</span><span class=nx>currentlyRenderingFiber</span><span class=p>.</span><span class=nx>updateQueue</span><span class=o>:</span> <span class=nx>any</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>componentUpdateQueue</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// componentUpdateQueue 不存在，则创建一个
</span><span class=c1></span>    <span class=nx>componentUpdateQueue</span> <span class=o>=</span> <span class=nx>createFunctionComponentUpdateQueue</span><span class=p>();</span>
    <span class=nx>currentlyRenderingFiber</span><span class=p>.</span><span class=nx>updateQueue</span> <span class=o>=</span> <span class=p>(</span><span class=nx>componentUpdateQueue</span><span class=o>:</span> <span class=nx>any</span><span class=p>);</span>
    <span class=c1>// componentUpdateQueue 是一个单向环状链表
</span><span class=c1></span>    <span class=nx>componentUpdateQueue</span><span class=p>.</span><span class=nx>lastEffect</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>.</span><span class=nx>next</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>;</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>lastEffect</span> <span class=o>=</span> <span class=nx>componentUpdateQueue</span><span class=p>.</span><span class=nx>lastEffect</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>lastEffect</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>componentUpdateQueue</span><span class=p>.</span><span class=nx>lastEffect</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>.</span><span class=nx>next</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// 维护单向环状链表的数据结构
</span><span class=c1></span>      <span class=kr>const</span> <span class=nx>firstEffect</span> <span class=o>=</span> <span class=nx>lastEffect</span><span class=p>.</span><span class=nx>next</span><span class=p>;</span>
      <span class=nx>lastEffect</span><span class=p>.</span><span class=nx>next</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>;</span>
      <span class=nx>effect</span><span class=p>.</span><span class=nx>next</span> <span class=o>=</span> <span class=nx>firstEffect</span><span class=p>;</span>
      <span class=nx>componentUpdateQueue</span><span class=p>.</span><span class=nx>lastEffect</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>effect</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>总结一下 pushEffect 所做的事情：</p><ol><li>根据传入的参数创建新的 effect 对象</li><li>获取或创建当前正在执行渲染的 Fiber 节点的 Fiber.updateQueue</li><li>将新的 effect 赋值给 Fiber.updateQueue.lastEffect，并维护 effect 的单向环状链表数据结构</li><li>返回 effect 对象</li></ol><p>因此 hook.memoizedState 中保存的是一个 effect 对象，而该对象是一个 effect 单向环状链表中的一员。函数组件所对应的 Fiber 数据结构中， Fiber.updateQueue.lastEffect 始终指向最后一个 effect 。</p><p>beginWork 阶段最终会为该 Fiber 节点创建 effect 链表，该链表的顺序与组件中调用 useEffect 的顺序保持一致。</p><h3 id=render---completework-阶段>render - completeWork 阶段<a hidden class=anchor aria-hidden=true href=#render---completework-阶段>#</a></h3><p>我们先不关注 completeWork 函数做了什么。</p><p>在 completeWork 函数执行结束后，其上层函数 completeUnitOfWork 会检测当前 Fiber 节点是否存在 effect 链表，若存在就将<strong>该 Fiber 节点</strong>添加到父 Fiber 节点所维护的一份 effectList 链表中。可以参考源码中的注释：<a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L1711>completeUnitOfWork</a> 。（请注意，这里父节点的 effectList 是一个 Fiber 节点链表，与子节点里的 Fiber.updateQueue 中维护的 effectList 不是同一个概念）</p><p>最终所有具有 effect 的 Fiber 节点在递归过程结束后会形成一个链表，维护在根节点的 effectList 中，其顺序与节点执行 completeWork 的顺序一致。</p><p>上文有一点没有提到：除了 useEffect 产生的 effect 之外，React 也会将待进行的 DOM 更新操作<a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberFlags.js#L17>标记成 effect</a> ，保存在 effect 链表中。commit 阶段将根据 effectList 执行所有的 DOM 更新。</p><h3 id=commit-阶段>commit 阶段<a hidden class=anchor aria-hidden=true href=#commit-阶段>#</a></h3><p>这里先不关注 commit 阶段是如何更新 DOM 的，只关注 useEffect 所产生副作用的执行时机。</p><p>在 React 完成 DOM 更新之后，将调用 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2385>commitLayoutEffects</a> 函数，其中调用了 commitLayoutEffectOnFiber 函数，该函数是 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L454>commitLifeCycles</a> 函数的别名：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>commitLifeCycles</span><span class=p>(</span>
  <span class=nx>finishedRoot</span><span class=o>:</span> <span class=nx>FiberRoot</span><span class=p>,</span>
  <span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
  <span class=nx>finishedWork</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>,</span>
  <span class=nx>committedLanes</span><span class=o>:</span> <span class=nx>Lanes</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=k>void</span> <span class=p>{</span>
  <span class=k>switch</span> <span class=p>(</span><span class=nx>finishedWork</span><span class=p>.</span><span class=nx>tag</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>case</span> <span class=nx>FunctionComponent</span><span class=o>:</span>
    <span class=k>case</span> <span class=nx>ForwardRef</span><span class=o>:</span>
    <span class=k>case</span> <span class=nx>SimpleMemoComponent</span><span class=o>:</span>
    <span class=k>case</span> <span class=nx>Block</span><span class=o>:</span> <span class=p>{</span>
      <span class=c1>// ...
</span><span class=c1></span>      <span class=c1>// useEffect 产生的 effect 属于 PassiveEffect ，将在这里调度执行
</span><span class=c1></span>      <span class=nx>schedulePassiveEffects</span><span class=p>(</span><span class=nx>finishedWork</span><span class=p>);</span>
      <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
  <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>再来看看 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L379>schedulePassiveEffects</a> 做了什么：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>schedulePassiveEffects</span><span class=p>(</span><span class=nx>finishedWork</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>updateQueue</span><span class=o>:</span> <span class=nx>FunctionComponentUpdateQueue</span> <span class=o>|</span> <span class=kc>null</span> <span class=o>=</span> <span class=p>(</span><span class=nx>finishedWork</span><span class=p>.</span><span class=nx>updateQueue</span><span class=o>:</span> <span class=nx>any</span><span class=p>);</span>
  <span class=kr>const</span> <span class=nx>lastEffect</span> <span class=o>=</span> <span class=nx>updateQueue</span> <span class=o>!==</span> <span class=kc>null</span> <span class=o>?</span> <span class=nx>updateQueue</span><span class=p>.</span><span class=nx>lastEffect</span> <span class=o>:</span> <span class=kc>null</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>lastEffect</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>firstEffect</span> <span class=o>=</span> <span class=nx>lastEffect</span><span class=p>.</span><span class=nx>next</span><span class=p>;</span>
    <span class=kd>let</span> <span class=nx>effect</span> <span class=o>=</span> <span class=nx>firstEffect</span><span class=p>;</span>
    <span class=k>do</span> <span class=p>{</span>
      <span class=kr>const</span> <span class=p>{</span><span class=nx>next</span><span class=p>,</span> <span class=nx>tag</span><span class=p>}</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>;</span>
      <span class=k>if</span> <span class=p>(</span>
        <span class=c1>// 如果 effect 的标志位存在 HookHasEffect 和 HookPassive
</span><span class=c1></span>        <span class=p>(</span><span class=nx>tag</span> <span class=o>&amp;</span> <span class=nx>HookPassive</span><span class=p>)</span> <span class=o>!==</span> <span class=nx>NoHookEffect</span> <span class=o>&amp;&amp;</span>
        <span class=p>(</span><span class=nx>tag</span> <span class=o>&amp;</span> <span class=nx>HookHasEffect</span><span class=p>)</span> <span class=o>!==</span> <span class=nx>NoHookEffect</span>
      <span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 将 effect 的销毁函数推入队列 pendingPassiveHookEffectsUnmount
</span><span class=c1></span>        <span class=c1>// 相当于 pendingPassiveHookEffectsUnmount.push(effect, finishedWork);
</span><span class=c1></span>        <span class=nx>enqueuePendingPassiveHookEffectUnmount</span><span class=p>(</span><span class=nx>finishedWork</span><span class=p>,</span> <span class=nx>effect</span><span class=p>);</span>
        <span class=c1>// 将 effect 的执行函数推入队列 pendingPassiveHookEffectsMount
</span><span class=c1></span>        <span class=c1>// 相当于 pendingPassiveHookEffectsMount.push(effect, finishedWork)
</span><span class=c1></span>        <span class=nx>enqueuePendingPassiveHookEffectMount</span><span class=p>(</span><span class=nx>finishedWork</span><span class=p>,</span> <span class=nx>effect</span><span class=p>);</span>
      <span class=p>}</span>
      <span class=c1>// 移动指针，访问整个 effect 链表
</span><span class=c1></span>      <span class=nx>effect</span> <span class=o>=</span> <span class=nx>next</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nx>effect</span> <span class=o>!==</span> <span class=nx>firstEffect</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>schedulePassiveEffects 遍历 effect 链表，找到所有具有 HookHasEffect 和 HookPassive 标志位的 effect ，将 effect 的销毁函数、执行函数推入了各自所属的队列。队列中的任务将会异步执行。</p><p>队列最终是在什么时间执行的呢？这与 React 的调度机制有关，不再展开叙述。我们先简单认为这两个队列将在某个适当的时机异步执行，其执行函数就是 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2434>flushPassiveEffects</a> ，该函数最终会调用 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2512>flushPassiveEffectsImpl</a> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>flushPassiveEffectsImpl</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// ...
</span><span class=c1></span>
  <span class=c1>// 阶段一：执行销毁函数
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>unmountEffects</span> <span class=o>=</span> <span class=nx>pendingPassiveHookEffectsUnmount</span><span class=p>;</span>
  <span class=nx>pendingPassiveHookEffectsUnmount</span> <span class=o>=</span> <span class=p>[];</span>
  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>unmountEffects</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>effect</span> <span class=o>=</span> <span class=p>((</span><span class=nx>unmountEffects</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=o>:</span> <span class=nx>any</span><span class=p>)</span><span class=o>:</span> <span class=nx>HookEffect</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>fiber</span> <span class=o>=</span> <span class=p>((</span><span class=nx>unmountEffects</span><span class=p>[</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=o>:</span> <span class=nx>any</span><span class=p>)</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>destroy</span> <span class=o>=</span> <span class=nx>effect</span><span class=p>.</span><span class=nx>destroy</span><span class=p>;</span>
    <span class=nx>effect</span><span class=p>.</span><span class=nx>destroy</span> <span class=o>=</span> <span class=kc>undefined</span><span class=p>;</span>

    <span class=c1>// ...
</span><span class=c1></span>
    <span class=c1>// 如果存在销毁函数则执行，这里省略了一些不相关的逻辑
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>destroy</span> <span class=o>===</span> <span class=s1>&#39;function&#39;</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>try</span> <span class=p>{</span>
        <span class=nx>destroy</span><span class=p>();</span>
      <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
        <span class=c1>// ...
</span><span class=c1></span>      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=c1>// 阶段二：执行副作用函数
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>mountEffects</span> <span class=o>=</span> <span class=nx>pendingPassiveHookEffectsMount</span><span class=p>;</span>
  <span class=nx>pendingPassiveHookEffectsMount</span> <span class=o>=</span> <span class=p>[];</span>
  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>mountEffects</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>effect</span> <span class=o>=</span> <span class=p>((</span><span class=nx>mountEffects</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=o>:</span> <span class=nx>any</span><span class=p>)</span><span class=o>:</span> <span class=nx>HookEffect</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>fiber</span> <span class=o>=</span> <span class=p>((</span><span class=nx>mountEffects</span><span class=p>[</span><span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=o>:</span> <span class=nx>any</span><span class=p>)</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>);</span>

    <span class=c1>// ...
</span><span class=c1></span>
    <span class=c1>// 重新执行副作用函数，这里省略了一些不相关的逻辑
</span><span class=c1></span>    <span class=k>try</span> <span class=p>{</span>
      <span class=nx>effect</span><span class=p>.</span><span class=nx>destroy</span> <span class=o>=</span> <span class=nx>create</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
      <span class=c1>// ...
</span><span class=c1></span>    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>flushPassiveEffectsImpl 先依次执行了所有 effect 销毁函数，然后再依次执行 effect 执行函数。到这里，整个 useEffect 的执行过程结束。</p><p>现在已经可以回答上文的问题了：</p><ol><li>若父子组件都使用了 useEffect ，子组件的 effect 将先执行。</li><li>同级兄弟组件， effect 将会按照组件顺序依次执行。</li></ol><h3 id=update-阶段-1>update 阶段<a hidden class=anchor aria-hidden=true href=#update-阶段-1>#</a></h3><p>组件 update 阶段执行 useEffect 时，将会执行 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1205>updateEffectImpl</a> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>updateEffectImpl</span><span class=p>(</span><span class=nx>fiberFlags</span><span class=p>,</span> <span class=nx>hookFlags</span><span class=p>,</span> <span class=nx>create</span><span class=p>,</span> <span class=nx>deps</span><span class=p>)</span><span class=o>:</span> <span class=k>void</span> <span class=p>{</span>
  <span class=c1>// 从 hook 链表中取出 useEffect hook 对象
</span><span class=c1></span>  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>updateWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>nextDeps</span> <span class=o>=</span> <span class=nx>deps</span> <span class=o>===</span> <span class=kc>undefined</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=nx>deps</span><span class=p>;</span>
  <span class=kd>let</span> <span class=nx>destroy</span> <span class=o>=</span> <span class=kc>undefined</span><span class=p>;</span>

  <span class=k>if</span> <span class=p>(</span><span class=nx>currentHook</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>prevEffect</span> <span class=o>=</span> <span class=nx>currentHook</span><span class=p>.</span><span class=nx>memoizedState</span><span class=p>;</span>
    <span class=nx>destroy</span> <span class=o>=</span> <span class=nx>prevEffect</span><span class=p>.</span><span class=nx>destroy</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>nextDeps</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
      <span class=kr>const</span> <span class=nx>prevDeps</span> <span class=o>=</span> <span class=nx>prevEffect</span><span class=p>.</span><span class=nx>deps</span><span class=p>;</span>
      <span class=c1>// deps 一致则不添加 HookHasEffect 标志，本次更新该 Hook 不执行
</span><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=nx>areHookInputsEqual</span><span class=p>(</span><span class=nx>nextDeps</span><span class=p>,</span> <span class=nx>prevDeps</span><span class=p>))</span> <span class=p>{</span>
        <span class=nx>pushEffect</span><span class=p>(</span><span class=nx>hookFlags</span><span class=p>,</span> <span class=nx>create</span><span class=p>,</span> <span class=nx>destroy</span><span class=p>,</span> <span class=nx>nextDeps</span><span class=p>);</span>
        <span class=k>return</span><span class=p>;</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=nx>currentlyRenderingFiber</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>fiberFlags</span><span class=p>;</span>
  <span class=c1>// deps 有变化则重新计算 memoizedState
</span><span class=c1></span>  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=nx>pushEffect</span><span class=p>(</span>
    <span class=c1>// 为 hookFlags 添加 HookHasEffect 标志
</span><span class=c1></span>    <span class=nx>HookHasEffect</span> <span class=o>|</span> <span class=nx>hookFlags</span><span class=p>,</span>
    <span class=nx>create</span><span class=p>,</span>
    <span class=nx>destroy</span><span class=p>,</span>
    <span class=nx>nextDeps</span><span class=p>,</span>
  <span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>对比 mountEffectImpl ，updateEffectImpl 多了比较 deps 的步骤，若 deps 改变才会对 effect 添加 HookHasEffect 标志，这样才会在后续的 commit 阶段执行该 effect 。</p><h2 id=useref>useRef<a hidden class=anchor aria-hidden=true href=#useref>#</a></h2><blockquote><p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。</p></blockquote><p>ref 是 reference（引用）的缩写。React 推荐使用不可变数据，但某些情况下用户希望使用可变数据，ref 就提供了这样的能力。</p><h3 id=useref-hook-的实现>useRef Hook 的实现<a hidden class=anchor aria-hidden=true href=#useref-hook-的实现>#</a></h3><p>useRef Hook 的 hook.memoizedState 中保存着 ref 对象。例如：</p><pre><code>const ref = useRef('hello') // ref = hook.memoizedState = { current: 'hello' }
</code></pre><p>这可以从 useRef 实际调用的 mountRef 、 updateRef 函数看出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>mountRef</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=p>(</span><span class=nx>initialValue</span><span class=o>:</span> <span class=nx>T</span><span class=p>)</span><span class=o>:</span> <span class=p>{</span><span class=o>|</span><span class=nx>current</span><span class=o>:</span> <span class=nx>T</span><span class=o>|</span><span class=p>}</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>mountWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>ref</span> <span class=o>=</span> <span class=p>{</span><span class=nx>current</span><span class=o>:</span> <span class=nx>initialValue</span><span class=p>};</span>

  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=nx>ref</span><span class=p>;</span>
  <span class=k>return</span> <span class=nx>ref</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>function</span> <span class=nx>updateRef</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=p>(</span><span class=nx>initialValue</span><span class=o>:</span> <span class=nx>T</span><span class=p>)</span><span class=o>:</span> <span class=p>{</span><span class=o>|</span><span class=nx>current</span><span class=o>:</span> <span class=nx>T</span><span class=o>|</span><span class=p>}</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>updateWorkInProgressHook</span><span class=p>();</span>
  <span class=k>return</span> <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=react-元素的-refs>React 元素的 Refs<a hidden class=anchor aria-hidden=true href=#react-元素的-refs>#</a></h3><p>React 支持通过 Refs 访问 DOM 元素或者类组件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-html data-lang=html>// DOM 元素
<span class=p>&lt;</span><span class=nt>div</span> <span class=na>ref</span><span class=o>=</span><span class=s>{domRef}</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
// React 类组件
<span class=p>&lt;</span><span class=nt>ClassComponent</span> <span class=na>ref</span><span class=o>=</span><span class=s>{classComponentRef}</span> <span class=p>/&gt;</span>
</code></pre></td></tr></table></div></div><p>对于元素上的 ref 声明，React 是如何对 ref.current 赋值的呢？</p><p>在 render 的 beginWork 阶段，React 将通过 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L691>beginWork: markRef</a> 函数为含有 ref 属性的 Fiber 添加 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberFlags.js#L24>flag: Ref</a> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=c1>// ReactFiberFlags.js 中定义的 Ref flag
</span><span class=c1></span><span class=kr>export</span> <span class=kr>const</span> <span class=nx>Ref</span> <span class=o>=</span> <span class=mb>0b000000000010000000</span><span class=p>;</span>

<span class=c1>// beginWork 阶段的 markRef
</span><span class=c1></span><span class=kd>function</span> <span class=nx>markRef</span><span class=p>(</span><span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span> <span class=nx>workInProgress</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>ref</span> <span class=o>=</span> <span class=nx>workInProgress</span><span class=p>.</span><span class=nx>ref</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span>
    <span class=p>(</span><span class=nx>current</span> <span class=o>===</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=nx>ref</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=o>||</span>
    <span class=p>(</span><span class=nx>current</span> <span class=o>!==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=nx>current</span><span class=p>.</span><span class=nx>ref</span> <span class=o>!==</span> <span class=nx>ref</span><span class=p>)</span>
  <span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Schedule a Ref effect
</span><span class=c1></span>    <span class=nx>workInProgress</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>Ref</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>markRef 将在 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L956>finishClassComponent</a> 函数和 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L1154>updateHostComponent</a> 函数中调用。其中 finishClassComponent 用于类组件， updateHostComponent 用于原生 DOM 元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>finishClassComponent</span><span class=p>(</span>
  <span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
  <span class=nx>workInProgress</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>,</span>
  <span class=nx>Component</span><span class=o>:</span> <span class=nx>any</span><span class=p>,</span>
  <span class=nx>shouldUpdate</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>,</span>
  <span class=nx>hasContext</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>,</span>
  <span class=nx>renderLanes</span><span class=o>:</span> <span class=nx>Lanes</span><span class=p>,</span>
<span class=p>)</span> <span class=p>{</span>
  <span class=c1>// 即使 shouldComponentUpdate 返回了 false ，Refs 也应该更新
</span><span class=c1></span>  <span class=nx>markRef</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>workInProgress</span><span class=p>);</span>

  <span class=kr>const</span> <span class=nx>didCaptureError</span> <span class=o>=</span> <span class=p>(</span><span class=nx>workInProgress</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;</span> <span class=nx>DidCapture</span><span class=p>)</span> <span class=o>!==</span> <span class=nx>NoFlags</span><span class=p>;</span>

  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>shouldUpdate</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nx>didCaptureError</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Context providers should defer to sCU for rendering
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>hasContext</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>invalidateContextProvider</span><span class=p>(</span><span class=nx>workInProgress</span><span class=p>,</span> <span class=nx>Component</span><span class=p>,</span> <span class=kc>false</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>bailoutOnAlreadyFinishedWork</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>workInProgress</span><span class=p>,</span> <span class=nx>renderLanes</span><span class=p>);</span>
  <span class=p>}</span>
  <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>

<span class=kd>function</span> <span class=nx>updateHostComponent</span><span class=p>(</span>
  <span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
  <span class=nx>workInProgress</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>,</span>
  <span class=nx>renderLanes</span><span class=o>:</span> <span class=nx>Lanes</span><span class=p>,</span>
<span class=p>)</span> <span class=p>{</span>
  <span class=c1>// ...
</span><span class=c1></span>  <span class=nx>markRef</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>workInProgress</span><span class=p>);</span>
  <span class=nx>reconcileChildren</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>workInProgress</span><span class=p>,</span> <span class=nx>nextChildren</span><span class=p>,</span> <span class=nx>renderLanes</span><span class=p>);</span>
  <span class=k>return</span> <span class=nx>workInProgress</span><span class=p>.</span><span class=nx>child</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另外在 render 的 completeWork 阶段，React 将通过 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L146>completeWork: markRef</a> 为需要进行 ref 更新的节点进行标记：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>markRef</span><span class=p>(</span><span class=nx>workInProgress</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>workInProgress</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>Ref</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>function</span> <span class=nx>completeWork</span><span class=p>(</span>
  <span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
  <span class=nx>workInProgress</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>,</span>
  <span class=nx>renderLanes</span><span class=o>:</span> <span class=nx>Lanes</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=nx>Fiber</span> <span class=o>|</span> <span class=kc>null</span> <span class=p>{</span>
  <span class=c1>// ...
</span><span class=c1></span>  <span class=k>switch</span> <span class=p>(</span><span class=nx>workInProgress</span><span class=p>.</span><span class=nx>tag</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=k>case</span> <span class=nx>HostComponent</span><span class=o>:</span> <span class=p>{</span>
      <span class=c1>// ...
</span><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=nx>current</span> <span class=o>!==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=nx>workInProgress</span><span class=p>.</span><span class=nx>stateNode</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// ...
</span><span class=c1></span>        <span class=c1>// 更新节点的情形，ref 属性发生变化
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nx>current</span><span class=p>.</span><span class=nx>ref</span> <span class=o>!==</span> <span class=nx>workInProgress</span><span class=p>.</span><span class=nx>ref</span><span class=p>)</span> <span class=p>{</span>
          <span class=nx>markRef</span><span class=p>(</span><span class=nx>workInProgress</span><span class=p>);</span>
        <span class=p>}</span>
      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// ...
</span><span class=c1></span>        <span class=c1>// 新建节点的情形，节点存在 ref 属性
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nx>workInProgress</span><span class=p>.</span><span class=nx>ref</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
          <span class=nx>markRef</span><span class=p>(</span><span class=nx>workInProgress</span><span class=p>);</span>
        <span class=p>}</span>
      <span class=p>}</span>
      <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
  <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在 commit 阶段，React 将为需要操作 ref 的 Fiber 节点执行两类操作：清除之前的 ref 、赋值新的 ref 。</p><p>有两种情形需要清除之前的 ref ，第一种是 Fiber 节点包含 flag: Ref ，通过 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2302>commitMutationEffects</a> 函数执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>commitMutationEffects</span><span class=p>(</span>
  <span class=nx>root</span><span class=o>:</span> <span class=nx>FiberRoot</span><span class=p>,</span>
  <span class=nx>renderPriorityLevel</span><span class=o>:</span> <span class=nx>ReactPriorityLevel</span><span class=p>,</span>
<span class=p>)</span> <span class=p>{</span>
  <span class=k>while</span> <span class=p>(</span><span class=nx>nextEffect</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>flags</span> <span class=o>=</span> <span class=nx>nextEffect</span><span class=p>.</span><span class=nx>flags</span><span class=p>;</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>flags</span> <span class=o>&amp;</span> <span class=nx>Ref</span><span class=p>)</span> <span class=p>{</span>
      <span class=kr>const</span> <span class=nx>current</span> <span class=o>=</span> <span class=nx>nextEffect</span><span class=p>.</span><span class=nx>alternate</span><span class=p>;</span>
      <span class=k>if</span> <span class=p>(</span><span class=nx>current</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>commitDetachRef</span><span class=p>(</span><span class=nx>current</span><span class=p>);</span>
      <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
  <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p><a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L852>commitDetachRef</a> 是实际执行 ref 清除的函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>commitDetachRef</span><span class=p>(</span><span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>currentRef</span> <span class=o>=</span> <span class=nx>current</span><span class=p>.</span><span class=nx>ref</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>currentRef</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>currentRef</span> <span class=o>===</span> <span class=s1>&#39;function&#39;</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>currentRef</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=nx>currentRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>第二种情形是 Fiber 节点<a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2374>需要被移除</a>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>commitMutationEffects</span><span class=p>(</span>
  <span class=nx>root</span><span class=o>:</span> <span class=nx>FiberRoot</span><span class=p>,</span>
  <span class=nx>renderPriorityLevel</span><span class=o>:</span> <span class=nx>ReactPriorityLevel</span><span class=p>,</span>
<span class=p>)</span> <span class=p>{</span>
  <span class=k>while</span> <span class=p>(</span><span class=nx>nextEffect</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=kr>const</span> <span class=nx>flags</span> <span class=o>=</span> <span class=nx>nextEffect</span><span class=p>.</span><span class=nx>flags</span><span class=p>;</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=kr>const</span> <span class=nx>primaryFlags</span> <span class=o>=</span> <span class=nx>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=nx>Placement</span> <span class=o>|</span> <span class=nx>Update</span> <span class=o>|</span> <span class=nx>Deletion</span> <span class=o>|</span> <span class=nx>Hydrating</span><span class=p>);</span>
    <span class=k>switch</span> <span class=p>(</span><span class=nx>primaryFlags</span><span class=p>)</span> <span class=p>{</span>
      <span class=c1>// ...
</span><span class=c1></span>      <span class=c1>// 需要删除节点
</span><span class=c1></span>      <span class=k>case</span> <span class=nx>Deletion</span><span class=o>:</span> <span class=p>{</span>
        <span class=nx>commitDeletion</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span> <span class=nx>nextEffect</span><span class=p>,</span> <span class=nx>renderPriorityLevel</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
      <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>commitDeletion 函数最终会调用 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L178>safelyDetachRef</a> 函数，负责 ref 清除的工作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>safelyDetachRef</span><span class=p>(</span><span class=nx>current</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>ref</span> <span class=o>=</span> <span class=nx>current</span><span class=p>.</span><span class=nx>ref</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>ref</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>ref</span> <span class=o>===</span> <span class=s1>&#39;function&#39;</span><span class=p>)</span> <span class=p>{</span>
      <span class=c1>// ...
</span><span class=c1></span>      <span class=k>try</span> <span class=p>{</span>
        <span class=nx>ref</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span>
      <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>refError</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>captureCommitPhaseError</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>refError</span><span class=p>);</span>
      <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=nx>ref</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>完成 ref 的清除除工作后，接下来是 ref 的赋值工作，在 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2414>commitLayoutEffect</a> 函数中会执行 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L818>commitAttachRef</a> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>commitAttachRef</span><span class=p>(</span><span class=nx>finishedWork</span><span class=o>:</span> <span class=nx>Fiber</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>ref</span> <span class=o>=</span> <span class=nx>finishedWork</span><span class=p>.</span><span class=nx>ref</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>ref</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>instance</span> <span class=o>=</span> <span class=nx>finishedWork</span><span class=p>.</span><span class=nx>stateNode</span><span class=p>;</span>
    <span class=kd>let</span> <span class=nx>instanceToUse</span><span class=p>;</span>
    <span class=k>switch</span> <span class=p>(</span><span class=nx>finishedWork</span><span class=p>.</span><span class=nx>tag</span><span class=p>)</span> <span class=p>{</span>
      <span class=c1>// 原生 DOM 元素
</span><span class=c1></span>      <span class=k>case</span> <span class=nx>HostComponent</span><span class=o>:</span>
        <span class=nx>instanceToUse</span> <span class=o>=</span> <span class=nx>getPublicInstance</span><span class=p>(</span><span class=nx>instance</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
      <span class=c1>// 类组件
</span><span class=c1></span>      <span class=k>default</span><span class=o>:</span>
        <span class=nx>instanceToUse</span> <span class=o>=</span> <span class=nx>instance</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>ref</span> <span class=o>===</span> <span class=s1>&#39;function&#39;</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>ref</span><span class=p>(</span><span class=nx>instanceToUse</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// ...
</span><span class=c1></span>      <span class=nx>ref</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>instanceToUse</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=usecallback-与-usememo>useCallback 与 useMemo<a hidden class=anchor aria-hidden=true href=#usecallback-与-usememo>#</a></h2><p>相比于上文的几种 Hook ，useCallback 和 useMemo 的实现比较简单。</p><h3 id=mount-阶段-1>mount 阶段<a hidden class=anchor aria-hidden=true href=#mount-阶段-1>#</a></h3><p>先看 mount 阶段 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1374>mountCallback</a> 与 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L1397>mountMemo</a> 的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>mountCallback</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=p>(</span><span class=nx>callback</span><span class=o>:</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>deps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=k>void</span> <span class=o>|</span> <span class=kc>null</span><span class=p>)</span><span class=o>:</span> <span class=nx>T</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>mountWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>nextDeps</span> <span class=o>=</span> <span class=nx>deps</span> <span class=o>===</span> <span class=kc>undefined</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=nx>deps</span><span class=p>;</span>
  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=p>[</span><span class=nx>callback</span><span class=p>,</span> <span class=nx>nextDeps</span><span class=p>];</span>
  <span class=k>return</span> <span class=nx>callback</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>function</span> <span class=nx>mountMemo</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=p>(</span>
  <span class=nx>nextCreate</span><span class=o>:</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>T</span><span class=p>,</span>
  <span class=nx>deps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=k>void</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=nx>T</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>mountWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>nextDeps</span> <span class=o>=</span> <span class=nx>deps</span> <span class=o>===</span> <span class=kc>undefined</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=nx>deps</span><span class=p>;</span>
  <span class=kr>const</span> <span class=nx>nextValue</span> <span class=o>=</span> <span class=nx>nextCreate</span><span class=p>();</span>
  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=p>[</span><span class=nx>nextValue</span><span class=p>,</span> <span class=nx>nextDeps</span><span class=p>];</span>
  <span class=k>return</span> <span class=nx>nextValue</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>两者的区别在于：mountCallback 保存<strong>传入的函数</strong>与依赖项，mountMemo 保存<strong>传入函数的执行结果</strong>与依赖项。</p><h3 id=update-阶段-2>update 阶段<a hidden class=anchor aria-hidden=true href=#update-阶段-2>#</a></h3><p>在 update 阶段，useCallback 与 useMemo 将会比较依赖项，若依赖项改变则保存新值，否则返回之前保存的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>updateCallback</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=p>(</span><span class=nx>callback</span><span class=o>:</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>deps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=k>void</span> <span class=o>|</span> <span class=kc>null</span><span class=p>)</span><span class=o>:</span> <span class=nx>T</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>updateWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>nextDeps</span> <span class=o>=</span> <span class=nx>deps</span> <span class=o>===</span> <span class=kc>undefined</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=nx>deps</span><span class=p>;</span>
  <span class=kr>const</span> <span class=nx>prevState</span> <span class=o>=</span> <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>prevState</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>nextDeps</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
      <span class=kr>const</span> <span class=nx>prevDeps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=kc>null</span> <span class=o>=</span> <span class=nx>prevState</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
      <span class=k>if</span> <span class=p>(</span><span class=nx>areHookInputsEqual</span><span class=p>(</span><span class=nx>nextDeps</span><span class=p>,</span> <span class=nx>prevDeps</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>prevState</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=p>[</span><span class=nx>callback</span><span class=p>,</span> <span class=nx>nextDeps</span><span class=p>];</span>
  <span class=k>return</span> <span class=nx>callback</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>function</span> <span class=nx>updateMemo</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=p>(</span>
  <span class=nx>nextCreate</span><span class=o>:</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>T</span><span class=p>,</span>
  <span class=nx>deps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=k>void</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
<span class=p>)</span><span class=o>:</span> <span class=nx>T</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>hook</span> <span class=o>=</span> <span class=nx>updateWorkInProgressHook</span><span class=p>();</span>
  <span class=kr>const</span> <span class=nx>nextDeps</span> <span class=o>=</span> <span class=nx>deps</span> <span class=o>===</span> <span class=kc>undefined</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=nx>deps</span><span class=p>;</span>
  <span class=kr>const</span> <span class=nx>prevState</span> <span class=o>=</span> <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>prevState</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Assume these are defined. If they&#39;re not, areHookInputsEqual will warn.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>nextDeps</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
      <span class=kr>const</span> <span class=nx>prevDeps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=kc>null</span> <span class=o>=</span> <span class=nx>prevState</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
      <span class=k>if</span> <span class=p>(</span><span class=nx>areHookInputsEqual</span><span class=p>(</span><span class=nx>nextDeps</span><span class=p>,</span> <span class=nx>prevDeps</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>prevState</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=kr>const</span> <span class=nx>nextValue</span> <span class=o>=</span> <span class=nx>nextCreate</span><span class=p>();</span>
  <span class=nx>hook</span><span class=p>.</span><span class=nx>memoizedState</span> <span class=o>=</span> <span class=p>[</span><span class=nx>nextValue</span><span class=p>,</span> <span class=nx>nextDeps</span><span class=p>];</span>
  <span class=k>return</span> <span class=nx>nextValue</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>比较函数 <a href=https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberHooks.old.js#L295>areHookInputsEqual</a> 的实现如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>areHookInputsEqual</span><span class=p>(</span>
  <span class=nx>nextDeps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span><span class=p>,</span>
  <span class=nx>prevDeps</span><span class=o>:</span> <span class=nb>Array</span><span class=o>&lt;</span><span class=nx>mixed</span><span class=o>&gt;</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span>
<span class=p>)</span> <span class=p>{</span>
  <span class=c1>// ...
</span><span class=c1></span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>prevDeps</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// ...
</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>prevDeps</span><span class=p>.</span><span class=nx>length</span> <span class=o>&amp;&amp;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>nextDeps</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// is 是 Object.is 的 polyfill
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>is</span><span class=p>(</span><span class=nx>nextDeps</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>prevDeps</span><span class=p>[</span><span class=nx>i</span><span class=p>]))</span> <span class=p>{</span>
      <span class=k>continue</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>areHookInputsEqual 对依赖项进行了浅层的 <a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is>Object.is</a> 比较，因此修改依赖项的深层数据并不会触发 useCallback 和 useMemo 重新计算的逻辑。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ruihusky.github.io/ruihusky/tags/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/>框架原理</a></li></ul><nav class=paginav><a class=next href=https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/><span class=title>下一页 »</span><br><span>CSRF的原理与防御</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ruihusky/ruihusky issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article><script>for(var content=document.querySelector(".post-content"),links=content.getElementsByTagName("a"),i=0,linksLength=links.length;i<linksLength;i++)links[i].hostname!=window.location.hostname&&(links[i].target='_blank')</script></main><footer class=footer><span>ruihusky&rsquo;s Blog</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>