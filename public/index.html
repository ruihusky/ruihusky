<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ruihusky's Blog</title><meta name=keywords content="ruihusky,技术博客,个人博客"><meta name=description content="ruihusky's Blog - https://ruihusky.github.io/ruihusky/"><meta name=author content="ruihusky"><link rel=canonical href=https://ruihusky.github.io/ruihusky/><link crossorigin=anonymous href=/ruihusky/assets/css/stylesheet.min.b4a96aabd0f808032bf8cffb299bb9b7bf22b92efba2c0cf58292ce09db9917b.css integrity="sha256-tKlqq9D4CAMr+M/7KZu5t78iuS77osDPWCks4J25kXs=" rel="preload stylesheet" as=style><link rel=icon href=https://ruihusky.github.io/ruihusky/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ruihusky.github.io/ruihusky/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ruihusky.github.io/ruihusky/favicon-32x32.png><link rel=apple-touch-icon href=https://ruihusky.github.io/ruihusky/apple-touch-icon.png><link rel=mask-icon href=https://ruihusky.github.io/ruihusky/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><link rel=alternate type=application/rss+xml href=https://ruihusky.github.io/ruihusky/index.xml><meta property="og:title" content="ruihusky's Blog"><meta property="og:description" content="ruihusky's Blog - https://ruihusky.github.io/ruihusky/"><meta property="og:type" content="website"><meta property="og:url" content="https://ruihusky.github.io/ruihusky/"><meta property="og:site_name" content="ruihusky's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="ruihusky's Blog"><meta name=twitter:description content="ruihusky's Blog - https://ruihusky.github.io/ruihusky/"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"ruihusky's Blog","url":"https://ruihusky.github.io/ruihusky/","description":"ruihusky\u0026#39;s Blog - https://ruihusky.github.io/ruihusky/","thumbnailUrl":"https://ruihusky.github.io/ruihusky/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ruihusky.github.io/ruihusky/ accesskey=h title="ruihusky's Blog (Alt + H)">ruihusky's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ruihusky.github.io/ruihusky/archives title=Archives><span>Archives</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/categories title=Categories><span>Categories</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ruihusky.github.io/ruihusky/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2>React Hooks 原理简析</h2></header><section class=entry-content><p>说明 本文的原理简析基于 React 17.0.2 和 Legacy Mode ，不涉及 Concurrent Mode 。
函数组件与类组件 想要理解 Hooks，需要先理解函数组件与类组件之间的区别。
先看概括 React 设计理念的公式：
1 UI = render(data) React 根据状态渲染视图，且一个状态对应一个渲染结果。也就是说，数据是和渲染结果绑定的。
类组件与可变的 this 在 React 中，推荐使用不可变数据 (immutable data) 描述状态。需要更新状态时，应使用一份新的数据，而不是对原来的数据进行修改。
不过就算使用不可变数据，类组件中还是会有this的问题。先看一个类组件示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** 假设这里是某个用户的个人信息页 点击 Follow 将会关注该用户，关注成功后需要弹出消息，提示关注成功 通过 setTimeout 模拟了一个响应较慢的接口 */ class ProfilePage extends React.Component { showMessage = () => { alert('Followed ' + this....</p></section><footer class=entry-footer>2021年6月20日&nbsp;·&nbsp;ruihusky</footer><a class=entry-link aria-label="post link to React Hooks 原理简析" href=https://ruihusky.github.io/ruihusky/posts/2021-06-20_react-hooks/></a></article><article class=post-entry><header class=entry-header><h2>CSRF的原理与防御</h2></header><section class=entry-content><p>CSRF 原理 CSRF 的全称是 Cross Site Request Forgery 的缩写，即跨站请求伪造。简单的说，当用户在被攻击网站未退出登陆时，攻击者欺骗用户在攻击者的网站请求了被攻击网站某一需要登录权限的链接，则构成 CSRF。
举一个经典的例子：
用户登录了某一家银行网站，其登陆状态由浏览器 cookie 与服务器 session 维持。该网站有一用于执行转账操作的 get 请求：
https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
攻击者在一个恶意网站上放置如下代码：
&lt;img src="https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman" />。
如果用户登录了银行网站之后还未退出登陆，并访问了恶意网站，则上述img标签会发出转账请求，并携带银行网站的登录态 cookie。服务器收到了请求，并查看 cookie，发现用户依然是登陆状态，则认为该次请求合法。于是用户的银行账户就损失了 1000 资金。
注意到，攻击者并不能通过 CSRF 直接获取用户帐户的控制权限，也不能窃取用户的任何信息。攻击者能做的是欺骗用户的浏览器，让其以用户的名义执行操作。
CSRF 防御 CSRF 具备两个特点：
CSRF 通常是发生在第三方域名的 CSRF 通过欺骗浏览器来使用 cookie 中的信息，以获取用户权限来执行某些操作 针对这两个特点，我们可以制定对应的防护策略。
检查 Referer 字段 http 请求头中有一个 Referer 字段，用于标识该请求来源于哪个地址。如果是来自恶意网站的请求，则 Referer 字段将会是恶意网站的地址，服务器可以拒绝该次请求。服务器也可以设置为只允许来自于特定 Referer 的请求，相当于一个白名单规则。
这种方法实现简单，但也有其局限性。虽然 http 协议对 Referer 字段的内容有明确的规定，但无法保证浏览器的具体实现，也无法保证浏览器自身是否没有安全漏洞。使用检查 Referer 字段的方法，等于将安全性依赖于第三方浏览器实现。
CSRF token CSRF 中，攻击者只能利用 cookie 中的信息。我们可以要求所有的用户请求都携带一个攻击者无法获得的 token。原理是：当用户发送请求时，服务器端应用生成一个随机且唯一的令牌（token），并将其发送给客户端。客户端提交请求的时候，将 token 一起发送到服务端，服务端通过验证 token 是否有效来判断该次请求的合法性。...</p></section><footer class=entry-footer>2021年3月14日&nbsp;·&nbsp;ruihusky</footer><a class=entry-link aria-label="post link to CSRF的原理与防御" href=https://ruihusky.github.io/ruihusky/posts/2021-03-15_csrf-and-xss/></a></article><article class=post-entry><header class=entry-header><h2>十大经典排序算法</h2></header><section class=entry-content><p>概览与术语 在计算机科学与数学中，一个排序算法（Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法，最常用到的排序方式之一就是数值顺序。
排序算法依照稳定性可分为稳定算法和不稳定算法。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，则在排序过的列表中 R 也将会是在 S 之前。
排序算法依照排序过程中占用空间的方式分为 In-place 算法 与 Out-place 算法。In-place 是原地算法，基本上不需要额外的辅助空间，可允许固定数量的辅助变量。非原地算法就是 Out-place，其开辟的辅助空间与问题规模相关。例如，冒泡排序只需要数据在原序列中交换位置，不需要额外的辅助空间，是 In-place 算法。
不同的排序算法会有不同的时间复杂度（最差、平均、和最好性能），下表列出了十种经典排序算法的概览：
冒泡排序（Bubble Sort） 一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为：越的元素会经由交换慢慢“浮”到数列的顶端。
冒泡排序对 n 个项目需要 O(n2)的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。
算法描述
比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到没有任何一对数字需要比较； 可选的优化步骤：某次步骤 1~3 执行过程中没有元素发生交换，则证明该序列已经有序，不需要再进行下一次序列遍历。 动图演示
代码实现
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // TypeScript实现 export function bubbleSort(arr: number[]) { const len = arr....</p></section><footer class=entry-footer>2021年2月20日&nbsp;·&nbsp;ruihusky</footer><a class=entry-link aria-label="post link to 十大经典排序算法" href=https://ruihusky.github.io/ruihusky/posts/2021-02-21_sorting-algorithm/></a></article><article class=post-entry><header class=entry-header><h2>CSS flex-basis: auto 与弹性布局</h2></header><section class=entry-content><p>flex 布局中的问题 最近在开发一个移动端适配的 H5 应用时，遇到了一个布局上的问题。简单描述如下：
页面从上到下排列有多个元素，其中有几张图片。在高宽比较大的手机上展示时（也就是比较长的手机，例如 iPhone X），布局没什么问题。但在一些小手机上，屏幕的纵轴无法容纳这么多元素。特别当微信浏览器中出现下方的导航栏时，高宽比被进一步减小，纵轴空间更加局促了。
这个问题看起来不难。使用 flex 布局，让图片元素在小屏幕上自动控制高度，自适应等比缩放不就 OK 了吗？于是写出了如下的代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 &lt;div class="page-container"> &lt;!-- ...其他flex子项 --> &lt;div class="image-wrap"> &lt;!-- 为了实现多个动画效果，图片被一个div包裹 --> &lt;img class="image" src="..." /> &lt;/div> &lt;!-- ...其他flex子项 --> &lt;/div> &lt;!-- vue css scope --> &lt;style> ....</p></section><footer class=entry-footer>2021年1月26日&nbsp;·&nbsp;ruihusky</footer><a class=entry-link aria-label="post link to CSS flex-basis: auto 与弹性布局" href=https://ruihusky.github.io/ruihusky/posts/2021-01-26_css-flex-basis/></a></article><article class=post-entry><header class=entry-header><h2>Unicode 编码与 UTF-32、UTF-16、UTF-8</h2></header><section class=entry-content><p>字符编码与 Unicode 编码 字符，又或者说文本在计算机中是以字符编码的方式存储的。计算机以二进制处理信息，每一位只有 1 和 0 两种状态，每个字节就可以组合出2^8=256种状态（1 字节=8 位）。以 ASCII 为例，它用 7 位的二进制来表示字母、数字和其它符号编号，共计 128 个字符，通常会额外使用一个扩充的位，以便于以 1 个字节的方式存储。
Unicode 是一个庞大的字符编码集合，是一种用于展示世界上所有语言的字符的编码标准。在 20 世纪 80 年代开始启动设计工作时，人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展，理论上一共最多可以表示 2^16（即 65536）个字符。这 16 位统一码字符构成了基本多文种平面，其编码范围为 U+0000 ~ U+FFFF。
经过一段时间，Unicode 字符超过了 65536 个，基本多文种平面无法满足描述所有 Unicode 字符的需要了。为了扩展需求，Unicode 在原来的基础上新增了 16 个辅助平面，每个平面的编码范围为：
辅助平面 1：U+10000 ~ U+1FFFF 辅助平面 2：U+20000 ~ U+2FFFF … 辅助平面 15：U+F0000 ~ U+FFFFF 辅助平面 16：U+100000 ~ U+10FFFF 所有辅助平面的编码范围为 U+10000 ~ U+10FFFF，共计 16 个辅助平面，每个辅助平面最多可存储 2^16（即 65536）个字符，也可以说每个辅助平面都有 65536 个码位。
到这里为止，还只是 Unicode 的编码方式，下文简要说明其几种实现方式。...</p></section><footer class=entry-footer>2020年12月16日&nbsp;·&nbsp;ruihusky</footer><a class=entry-link aria-label="post link to Unicode 编码与 UTF-32、UTF-16、UTF-8" href=https://ruihusky.github.io/ruihusky/posts/2020-12-16_unicode-utf/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://ruihusky.github.io/ruihusky/page/2/>下一页 »</a></nav></footer></main><footer class=footer><span>ruihusky&rsquo;s Blog</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>